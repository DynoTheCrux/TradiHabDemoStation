
C:\Users\MTPANNY\AppData\Local\Temp\VMBuilds\TraDiHab\teensy36\Release/TraDiHab.ino.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <_VectorsFlash>:
       0:	00 00 03 20 d1 01 00 00 ed 1c 00 00 a5 1c 00 00     ... ............
      10:	a5 1c 00 00 a5 1c 00 00 a5 1c 00 00 a5 1c 00 00     ................
      20:	a5 1c 00 00 a5 1c 00 00 a5 1c 00 00 ed 1c 00 00     ................
      30:	ed 1c 00 00 a5 1c 00 00 19 38 00 00 1d 39 00 00     .........8...9..
      40:	ed 1c 00 00 ed 1c 00 00 ed 1c 00 00 ed 1c 00 00     ................
      50:	ed 1c 00 00 ed 1c 00 00 ed 1c 00 00 ed 1c 00 00     ................
      60:	ed 1c 00 00 ed 1c 00 00 ed 1c 00 00 ed 1c 00 00     ................
      70:	ed 1c 00 00 ed 1c 00 00 ed 1c 00 00 ed 1c 00 00     ................
      80:	ed 1c 00 00 ed 1c 00 00 ed 1c 00 00 ed 1c 00 00     ................
      90:	ed 1c 00 00 ed 1c 00 00 ed 1c 00 00 ed 1c 00 00     ................
      a0:	ed 1c 00 00 ed 1c 00 00 ed 1c 00 00 ed 1c 00 00     ................
      b0:	ed 1c 00 00 ed 1c 00 00 ed 1c 00 00 2d 3e 00 00     ............->..
      c0:	ed 1c 00 00 59 3f 00 00 ed 1c 00 00 85 40 00 00     ....Y?.......@..
      d0:	ed 1c 00 00 7d 41 00 00 ed 1c 00 00 ed 1c 00 00     ....}A..........
      e0:	ed 1c 00 00 ed 1c 00 00 ed 1c 00 00 55 15 00 00     ............U...
      f0:	45 16 00 00 ed 1c 00 00 ed 1c 00 00 ed 1c 00 00     E...............
     100:	09 3a 00 00 1d 3a 00 00 31 3a 00 00 45 3a 00 00     .:...:..1:..E:..
     110:	ed 1c 00 00 09 28 00 00 ed 1c 00 00 ed 1c 00 00     .....(..........
     120:	ed 1c 00 00 ed 1c 00 00 ed 1c 00 00 ed 1c 00 00     ................
     130:	ed 1c 00 00 ed 1c 00 00 ed 1c 00 00 ed 1c 00 00     ................
     140:	ed 1c 00 00 ed 1c 00 00 75 42 00 00 ed 1c 00 00     ........uB......
     150:	ed 1c 00 00 ed 1c 00 00 ed 1c 00 00 ed 1c 00 00     ................
     160:	ed 1c 00 00 ed 1c 00 00 ed 1c 00 00 ed 1c 00 00     ................
     170:	ed 1c 00 00 ed 1c 00 00 ed 1c 00 00 ed 1c 00 00     ................
     180:	ed 1c 00 00 ed 1c 00 00 ed 1c 00 00 ed 1c 00 00     ................
     190:	ed 1c 00 00 ed 1c 00 00 6d 43 00 00 ed 1c 00 00     ........mC......
     1a0:	ed 1c 00 00 ed 1c 00 00 ed 1c 00 00 ed 1c 00 00     ................
     1b0:	ed 1c 00 00 ed 1c 00 00 ed 1c 00 00 ed 1c 00 00     ................
     1c0:	ed 1c 00 00 ed 1c 00 00 ed 1c 00 00 ed 1c 00 00     ................

000001d0 <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d0:	4b5c      	ldr	r3, [pc, #368]	; (344 <ResetHandler+0x174>)
     1d2:	f24c 5220 	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
     1d6:	b510      	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d8:	801a      	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1da:	f64d 1228 	movw	r2, #55592	; 0xd928
     1de:	801a      	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
     1e0:	bf00      	nop
	__asm__ volatile ("nop");
     1e2:	bf00      	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1e4:	f001 fd86 	bl	1cf4 <startup_early_hook>
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1e8:	4b57      	ldr	r3, [pc, #348]	; (348 <ResetHandler+0x178>)
     1ea:	f04f 6230 	mov.w	r2, #184549376	; 0xb000000
     1ee:	601a      	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1f0:	4a56      	ldr	r2, [pc, #344]	; (34c <ResetHandler+0x17c>)
     1f2:	609a      	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1f4:	4a56      	ldr	r2, [pc, #344]	; (350 <ResetHandler+0x180>)
     1f6:	60da      	str	r2, [r3, #12]
	SIM_SCGC4 = SIM_SCGC4_USBOTG | 0xF0000030;
	SIM_SCGC5 = 0x00003F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_ADC0 | SIM_SCGC6_TPM0 | SIM_SCGC6_TPM1 | SIM_SCGC6_TPM2 | SIM_SCGC6_FTFL;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SCB_CPACR = 0x00F00000;
     1f8:	4b56      	ldr	r3, [pc, #344]	; (354 <ResetHandler+0x184>)
     1fa:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
     1fe:	601a      	str	r2, [r3, #0]
#endif
#if defined(__MK66FX1M0__)
	LMEM_PCCCR = 0x85000003;
     200:	4b55      	ldr	r3, [pc, #340]	; (358 <ResetHandler+0x188>)
     202:	4a56      	ldr	r2, [pc, #344]	; (35c <ResetHandler+0x18c>)
     204:	601a      	str	r2, [r3, #0]
		RTC_SR = 0;
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     206:	4b56      	ldr	r3, [pc, #344]	; (360 <ResetHandler+0x190>)
     208:	781a      	ldrb	r2, [r3, #0]
     20a:	0711      	lsls	r1, r2, #28
     20c:	d503      	bpl.n	216 <ResetHandler+0x46>
     20e:	781a      	ldrb	r2, [r3, #0]
     210:	f042 0208 	orr.w	r2, r2, #8
     214:	701a      	strb	r2, [r3, #0]

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     216:	4b53      	ldr	r3, [pc, #332]	; (364 <ResetHandler+0x194>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     218:	4953      	ldr	r1, [pc, #332]	; (368 <ResetHandler+0x198>)
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     21a:	22aa      	movs	r2, #170	; 0xaa
     21c:	701a      	strb	r2, [r3, #0]
     21e:	4a53      	ldr	r2, [pc, #332]	; (36c <ResetHandler+0x19c>)
     220:	4b53      	ldr	r3, [pc, #332]	; (370 <ResetHandler+0x1a0>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     222:	428b      	cmp	r3, r1
     224:	d204      	bcs.n	230 <ResetHandler+0x60>
     226:	f852 0f04 	ldr.w	r0, [r2, #4]!
     22a:	f843 0b04 	str.w	r0, [r3], #4
     22e:	e7f8      	b.n	222 <ResetHandler+0x52>
     230:	4b50      	ldr	r3, [pc, #320]	; (374 <ResetHandler+0x1a4>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     232:	4951      	ldr	r1, [pc, #324]	; (378 <ResetHandler+0x1a8>)
     234:	2200      	movs	r2, #0
     236:	428b      	cmp	r3, r1
     238:	d202      	bcs.n	240 <ResetHandler+0x70>
     23a:	f843 2b04 	str.w	r2, [r3], #4
     23e:	e7fa      	b.n	236 <ResetHandler+0x66>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     240:	494e      	ldr	r1, [pc, #312]	; (37c <ResetHandler+0x1ac>)
     242:	4a4f      	ldr	r2, [pc, #316]	; (380 <ResetHandler+0x1b0>)
     244:	2300      	movs	r3, #0
     246:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
     24a:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
     24e:	3301      	adds	r3, #1
     250:	2b74      	cmp	r3, #116	; 0x74
     252:	d1f8      	bne.n	246 <ResetHandler+0x76>
     254:	4b4b      	ldr	r3, [pc, #300]	; (384 <ResetHandler+0x1b4>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     256:	4a4c      	ldr	r2, [pc, #304]	; (388 <ResetHandler+0x1b8>)
     258:	2180      	movs	r1, #128	; 0x80
     25a:	f803 1b01 	strb.w	r1, [r3], #1
     25e:	4293      	cmp	r3, r2
     260:	d1fb      	bne.n	25a <ResetHandler+0x8a>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     262:	4b4a      	ldr	r3, [pc, #296]	; (38c <ResetHandler+0x1bc>)
     264:	4a45      	ldr	r2, [pc, #276]	; (37c <ResetHandler+0x1ac>)
     266:	601a      	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     268:	4b49      	ldr	r3, [pc, #292]	; (390 <ResetHandler+0x1c0>)
     26a:	228a      	movs	r2, #138	; 0x8a
     26c:	701a      	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     26e:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
     272:	2224      	movs	r2, #36	; 0x24
     274:	705a      	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     276:	22a0      	movs	r2, #160	; 0xa0
     278:	701a      	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     27a:	799a      	ldrb	r2, [r3, #6]
     27c:	0792      	lsls	r2, r2, #30
     27e:	d5fc      	bpl.n	27a <ResetHandler+0xaa>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     280:	799a      	ldrb	r2, [r3, #6]
     282:	06d4      	lsls	r4, r2, #27
     284:	d4fc      	bmi.n	280 <ResetHandler+0xb0>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     286:	4a43      	ldr	r2, [pc, #268]	; (394 <ResetHandler+0x1c4>)
     288:	7993      	ldrb	r3, [r2, #6]
     28a:	f003 030c 	and.w	r3, r3, #12
     28e:	2b08      	cmp	r3, #8
     290:	d1fa      	bne.n	288 <ResetHandler+0xb8>
	//   C2[LP] bit is written to 1
  #else
	// if we need faster than the crystal, turn on the PLL
   #if defined(__MK66FX1M0__)
    #if F_CPU > 120000000
	SMC_PMCTRL = SMC_PMCTRL_RUNM(3); // enter HSRUN mode
     292:	4b41      	ldr	r3, [pc, #260]	; (398 <ResetHandler+0x1c8>)
     294:	2260      	movs	r2, #96	; 0x60
     296:	701a      	strb	r2, [r3, #0]
	while (SMC_PMSTAT != SMC_PMSTAT_HSRUN) ; // wait for HSRUN
     298:	3302      	adds	r3, #2
     29a:	781a      	ldrb	r2, [r3, #0]
     29c:	2a80      	cmp	r2, #128	; 0x80
     29e:	d1fc      	bne.n	29a <ResetHandler+0xca>
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(11);
    #elif F_CPU == 192000000
	MCG_C5 = MCG_C5_PRDIV0(0);
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(8);
    #elif F_CPU == 180000000
	MCG_C5 = MCG_C5_PRDIV0(1);
     2a0:	4b3c      	ldr	r3, [pc, #240]	; (394 <ResetHandler+0x1c4>)
     2a2:	2201      	movs	r2, #1
     2a4:	711a      	strb	r2, [r3, #4]
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(29);
     2a6:	225d      	movs	r2, #93	; 0x5d
     2a8:	715a      	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     2aa:	799a      	ldrb	r2, [r3, #6]
     2ac:	0690      	lsls	r0, r2, #26
     2ae:	d5fc      	bpl.n	2aa <ResetHandler+0xda>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     2b0:	7999      	ldrb	r1, [r3, #6]
     2b2:	4a38      	ldr	r2, [pc, #224]	; (394 <ResetHandler+0x1c4>)
     2b4:	0649      	lsls	r1, r1, #25
     2b6:	d5fb      	bpl.n	2b0 <ResetHandler+0xe0>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(3);
#elif F_CPU == 180000000
	// config divisors: 180 MHz core, 60 MHz bus, 25.7 MHz flash, USB = IRC48M
	#if F_BUS == 60000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(2) | SIM_CLKDIV1_OUTDIV4(6);
     2b8:	4b38      	ldr	r3, [pc, #224]	; (39c <ResetHandler+0x1cc>)
     2ba:	4939      	ldr	r1, [pc, #228]	; (3a0 <ResetHandler+0x1d0>)
     2bc:	6019      	str	r1, [r3, #0]
	#elif F_BUS == 90000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(6);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(0);
     2be:	2100      	movs	r1, #0
     2c0:	6059      	str	r1, [r3, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     2c2:	2320      	movs	r3, #32
     2c4:	7013      	strb	r3, [r2, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     2c6:	7993      	ldrb	r3, [r2, #6]
     2c8:	f003 030c 	and.w	r3, r3, #12
     2cc:	2b0c      	cmp	r3, #12
     2ce:	d1fa      	bne.n	2c6 <ResetHandler+0xf6>
	// now we're in PEE mode
	// trace is CPU clock, CLKOUT=OSCERCLK0
	#if defined(KINETISK)
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2d0:	4b34      	ldr	r3, [pc, #208]	; (3a4 <ResetHandler+0x1d4>)
     2d2:	4a35      	ldr	r2, [pc, #212]	; (3a8 <ResetHandler+0x1d8>)
     2d4:	601a      	str	r2, [r3, #0]
#endif

#if defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started.  For Teensy 3.6
	// we don't do this early.  See comment above about slow rising power.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     2d6:	4a35      	ldr	r2, [pc, #212]	; (3ac <ResetHandler+0x1dc>)
     2d8:	4c35      	ldr	r4, [pc, #212]	; (3b0 <ResetHandler+0x1e0>)
     2da:	6813      	ldr	r3, [r2, #0]
     2dc:	f413 7380 	ands.w	r3, r3, #256	; 0x100
     2e0:	d103      	bne.n	2ea <ResetHandler+0x11a>
		RTC_SR = 0;
     2e2:	6023      	str	r3, [r4, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     2e4:	f44f 53a8 	mov.w	r3, #5376	; 0x1500
     2e8:	6013      	str	r3, [r2, #0]
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2ea:	4b32      	ldr	r3, [pc, #200]	; (3b4 <ResetHandler+0x1e4>)
     2ec:	4a32      	ldr	r2, [pc, #200]	; (3b8 <ResetHandler+0x1e8>)
     2ee:	601a      	str	r2, [r3, #0]
	SYST_CVR = 0;
     2f0:	2200      	movs	r2, #0
     2f2:	605a      	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2f4:	2207      	movs	r2, #7
     2f6:	f843 2c04 	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2fa:	4a30      	ldr	r2, [pc, #192]	; (3bc <ResetHandler+0x1ec>)
     2fc:	f8c3 2d0c 	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
     300:	b662      	cpsie	i

	_init_Teensyduino_internal_();
     302:	f002 f8f1 	bl	24e8 <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     306:	6823      	ldr	r3, [r4, #0]
     308:	07da      	lsls	r2, r3, #31
     30a:	d505      	bpl.n	318 <ResetHandler+0x148>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     30c:	482c      	ldr	r0, [pc, #176]	; (3c0 <ResetHandler+0x1f0>)
     30e:	f001 fe25 	bl	1f5c <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     312:	4b2c      	ldr	r3, [pc, #176]	; (3c4 <ResetHandler+0x1f4>)
     314:	4a2c      	ldr	r2, [pc, #176]	; (3c8 <ResetHandler+0x1f8>)
     316:	601a      	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     318:	4b2c      	ldr	r3, [pc, #176]	; (3cc <ResetHandler+0x1fc>)
     31a:	781b      	ldrb	r3, [r3, #0]
     31c:	065b      	lsls	r3, r3, #25
     31e:	d509      	bpl.n	334 <ResetHandler+0x164>
     320:	4c28      	ldr	r4, [pc, #160]	; (3c4 <ResetHandler+0x1f4>)
     322:	4b29      	ldr	r3, [pc, #164]	; (3c8 <ResetHandler+0x1f8>)
     324:	6822      	ldr	r2, [r4, #0]
     326:	429a      	cmp	r2, r3
     328:	d104      	bne.n	334 <ResetHandler+0x164>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     32a:	4825      	ldr	r0, [pc, #148]	; (3c0 <ResetHandler+0x1f0>)
     32c:	f001 fe16 	bl	1f5c <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     330:	2300      	movs	r3, #0
     332:	6023      	str	r3, [r4, #0]
	}
#endif

	__libc_init_array();
     334:	f005 fdd0 	bl	5ed8 <__libc_init_array>

	startup_late_hook();
     338:	f001 fce2 	bl	1d00 <startup_late_hook>
	main();
     33c:	f003 fb8c 	bl	3a58 <main>
     340:	e7fe      	b.n	340 <ResetHandler+0x170>
     342:	bf00      	nop
     344:	4005200e 	.word	0x4005200e
     348:	40048030 	.word	0x40048030
     34c:	00043f82 	.word	0x00043f82
     350:	2b000001 	.word	0x2b000001
     354:	e000ed88 	.word	0xe000ed88
     358:	e0082000 	.word	0xe0082000
     35c:	85000003 	.word	0x85000003
     360:	4007d002 	.word	0x4007d002
     364:	4007e000 	.word	0x4007e000
     368:	1fff12dc 	.word	0x1fff12dc
     36c:	00006ffc 	.word	0x00006ffc
     370:	1fff0730 	.word	0x1fff0730
     374:	1fff12e0 	.word	0x1fff12e0
     378:	1fff1a84 	.word	0x1fff1a84
     37c:	1fff0200 	.word	0x1fff0200
     380:	00000000 	.word	0x00000000
     384:	e000e400 	.word	0xe000e400
     388:	e000e464 	.word	0xe000e464
     38c:	e000ed08 	.word	0xe000ed08
     390:	40065000 	.word	0x40065000
     394:	40064000 	.word	0x40064000
     398:	4007e001 	.word	0x4007e001
     39c:	40048044 	.word	0x40048044
     3a0:	02060000 	.word	0x02060000
     3a4:	40048004 	.word	0x40048004
     3a8:	000710c0 	.word	0x000710c0
     3ac:	4003d010 	.word	0x4003d010
     3b0:	4003d014 	.word	0x4003d014
     3b4:	e000e014 	.word	0xe000e014
     3b8:	0002bf1f 	.word	0x0002bf1f
     3bc:	20200000 	.word	0x20200000
     3c0:	5e638e93 	.word	0x5e638e93
     3c4:	4003e01c 	.word	0x4003e01c
     3c8:	5a94c3a5 	.word	0x5a94c3a5
     3cc:	4007f000 	.word	0x4007f000
     3d0:	ffffffff 	.word	0xffffffff
     3d4:	ffffffff 	.word	0xffffffff
     3d8:	ffffffff 	.word	0xffffffff
     3dc:	ffffffff 	.word	0xffffffff
     3e0:	ffffffff 	.word	0xffffffff
     3e4:	ffffffff 	.word	0xffffffff
     3e8:	ffffffff 	.word	0xffffffff
     3ec:	ffffffff 	.word	0xffffffff
     3f0:	ffffffff 	.word	0xffffffff
     3f4:	ffffffff 	.word	0xffffffff
     3f8:	ffffffff 	.word	0xffffffff
     3fc:	ffffffff 	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	ffffffff ffffffff ffffffff fffff9de     ................

00000410 <__do_global_dtors_aux>:
     410:	b510      	push	{r4, lr}
     412:	4c05      	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	7823      	ldrb	r3, [r4, #0]
     416:	b933      	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	4b04      	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	b113      	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	4804      	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	f3af 8000 	nop.w
     422:	2301      	movs	r3, #1
     424:	7023      	strb	r3, [r4, #0]
     426:	bd10      	pop	{r4, pc}
     428:	1fff12e0 	.word	0x1fff12e0
     42c:	00000000 	.word	0x00000000
     430:	00007000 	.word	0x00007000

00000434 <frame_dummy>:
     434:	4b08      	ldr	r3, [pc, #32]	; (458 <frame_dummy+0x24>)
     436:	b510      	push	{r4, lr}
     438:	b11b      	cbz	r3, 442 <frame_dummy+0xe>
     43a:	4908      	ldr	r1, [pc, #32]	; (45c <frame_dummy+0x28>)
     43c:	4808      	ldr	r0, [pc, #32]	; (460 <frame_dummy+0x2c>)
     43e:	f3af 8000 	nop.w
     442:	4808      	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x30>)
     444:	6803      	ldr	r3, [r0, #0]
     446:	b903      	cbnz	r3, 44a <frame_dummy+0x16>
     448:	bd10      	pop	{r4, pc}
     44a:	4b07      	ldr	r3, [pc, #28]	; (468 <frame_dummy+0x34>)
     44c:	2b00      	cmp	r3, #0
     44e:	d0fb      	beq.n	448 <frame_dummy+0x14>
     450:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     454:	4718      	bx	r3
     456:	bf00      	nop
     458:	00000000 	.word	0x00000000
     45c:	1fff12e4 	.word	0x1fff12e4
     460:	00007000 	.word	0x00007000
     464:	1fff12dc 	.word	0x1fff12dc
     468:	00000000 	.word	0x00000000

0000046c <safetyStopISR()>:

	serialPrint();
	#endif // ENCODER_ONLY_MODE
}

void safetyStopISR() {
     46c:	b508      	push	{r3, lr}
	running = false;
     46e:	4b05      	ldr	r3, [pc, #20]	; (484 <safetyStopISR()+0x18>)
	motorPS.stopMotor();
     470:	4805      	ldr	r0, [pc, #20]	; (488 <safetyStopISR()+0x1c>)
	serialPrint();
	#endif // ENCODER_ONLY_MODE
}

void safetyStopISR() {
	running = false;
     472:	2200      	movs	r2, #0
     474:	701a      	strb	r2, [r3, #0]
	motorPS.stopMotor();
     476:	f000 fab7 	bl	9e8 <ControlledDcMotor::stopMotor()>
	motorFE.stopMotor();
     47a:	4804      	ldr	r0, [pc, #16]	; (48c <safetyStopISR()+0x20>)
}
     47c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
}

void safetyStopISR() {
	running = false;
	motorPS.stopMotor();
	motorFE.stopMotor();
     480:	f000 bab2 	b.w	9e8 <ControlledDcMotor::stopMotor()>
     484:	1fff1508 	.word	0x1fff1508
     488:	1fff13e8 	.word	0x1fff13e8
     48c:	1fff1300 	.word	0x1fff1300

00000490 <IntervalTimer::~IntervalTimer()>:
public:
	IntervalTimer() {
		channel = NULL;
		nvic_priority = 128;
	}
	~IntervalTimer() {
     490:	b510      	push	{r4, lr}
     492:	4604      	mov	r4, r0
		end();
     494:	f003 fa96 	bl	39c4 <IntervalTimer::end()>
	}
     498:	4620      	mov	r0, r4
     49a:	bd10      	pop	{r4, pc}

0000049c <setupPins()>:

//=================DEBUGGING=================
volatile uint8_t toggleValue = 0;
volatile char incomingData = 0;

void setupPins(){
     49c:	b508      	push	{r3, lr}
	pinMode(DEBUG_PIN, OUTPUT);
     49e:	2101      	movs	r1, #1
     4a0:	2015      	movs	r0, #21
     4a2:	f001 ffc9 	bl	2438 <pinMode>

	pinMode(SAFETY_SWITCH, INPUT);
     4a6:	2100      	movs	r1, #0
     4a8:	201c      	movs	r0, #28
     4aa:	f001 ffc5 	bl	2438 <pinMode>
	attachInterrupt(SAFETY_SWITCH, safetyStopISR, FALLING);
     4ae:	2202      	movs	r2, #2
     4b0:	490e      	ldr	r1, [pc, #56]	; (4ec <setupPins()+0x50>)
     4b2:	201c      	movs	r0, #28
     4b4:	f001 fcd6 	bl	1e64 <attachInterrupt>
	
	pinMode(PS_ENC_I, INPUT);
     4b8:	2100      	movs	r1, #0
     4ba:	200c      	movs	r0, #12
     4bc:	f001 ffbc 	bl	2438 <pinMode>
	pinMode(FE_ENC_I, INPUT);
     4c0:	2100      	movs	r1, #0
     4c2:	200b      	movs	r0, #11
     4c4:	f001 ffb8 	bl	2438 <pinMode>

	pinMode(PS_LIMIT_1, INPUT);
     4c8:	2100      	movs	r1, #0
     4ca:	2018      	movs	r0, #24
     4cc:	f001 ffb4 	bl	2438 <pinMode>
	pinMode(PS_LIMIT_2, INPUT);
     4d0:	2100      	movs	r1, #0
     4d2:	2019      	movs	r0, #25
     4d4:	f001 ffb0 	bl	2438 <pinMode>
	pinMode(FE_LIMIT_1, INPUT);
     4d8:	2100      	movs	r1, #0
     4da:	201a      	movs	r0, #26
     4dc:	f001 ffac 	bl	2438 <pinMode>
	pinMode(FE_LIMIT_2, INPUT);
     4e0:	2100      	movs	r1, #0
     4e2:	201b      	movs	r0, #27
}
     4e4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	pinMode(FE_ENC_I, INPUT);

	pinMode(PS_LIMIT_1, INPUT);
	pinMode(PS_LIMIT_2, INPUT);
	pinMode(FE_LIMIT_1, INPUT);
	pinMode(FE_LIMIT_2, INPUT);
     4e8:	f001 bfa6 	b.w	2438 <pinMode>
     4ec:	0000046d 	.word	0x0000046d

000004f0 <setupPWM()>:
}

void setupPWM(){
     4f0:	b508      	push	{r3, lr}
     4f2:	ed2d 8b02 	vpush	{d8}
	analogWriteFrequency(FE_PWM, PWM_FREQUENCY);
     4f6:	ed9f 8a09 	vldr	s16, [pc, #36]	; 51c <setupPWM()+0x2c>
     4fa:	2006      	movs	r0, #6
     4fc:	eeb0 0a48 	vmov.f32	s0, s16
     500:	f001 feee 	bl	22e0 <analogWriteFrequency>
	analogWriteFrequency(PS_PWM, PWM_FREQUENCY);
     504:	eeb0 0a48 	vmov.f32	s0, s16
     508:	2008      	movs	r0, #8
     50a:	f001 fee9 	bl	22e0 <analogWriteFrequency>
	analogWriteResolution(PWM_RESOLUTION);
}
     50e:	ecbd 8b02 	vpop	{d8}

void pinMode(uint8_t pin, uint8_t mode);
void init_pins(void);
void analogWrite(uint8_t pin, int val);
uint32_t analogWriteRes(uint32_t bits);
static inline uint32_t analogWriteResolution(uint32_t bits) { return analogWriteRes(bits); }
     512:	200c      	movs	r0, #12
     514:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     518:	f001 bed2 	b.w	22c0 <analogWriteRes>
     51c:	469c4000 	.word	0x469c4000

00000520 <loop>:
	motorPS.stopMotor();
	motorFE.stopMotor();
	#endif // ENCODER_ONLY_MODE
}

void loop(){
     520:	b510      	push	{r4, lr}
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
     522:	f002 ffdb 	bl	34dc <usb_serial_available>

	//should probably be improved --> FSM would maybe be nice
	#if !ENCODER_ONLY_MODE
	if (Serial.available() > 0) {
     526:	2800      	cmp	r0, #0
     528:	dd11      	ble.n	54e <loop+0x2e>
        virtual int read() { return usb_serial_getchar(); }
     52a:	f002 ff9b 	bl	3464 <usb_serial_getchar>
		incomingData = Serial.read();
     52e:	4b12      	ldr	r3, [pc, #72]	; (578 <loop+0x58>)
		if (incomingData == 's' && !running) {
     530:	4c12      	ldr	r4, [pc, #72]	; (57c <loop+0x5c>)
void loop(){

	//should probably be improved --> FSM would maybe be nice
	#if !ENCODER_ONLY_MODE
	if (Serial.available() > 0) {
		incomingData = Serial.read();
     532:	b2c0      	uxtb	r0, r0
     534:	7018      	strb	r0, [r3, #0]
		if (incomingData == 's' && !running) {
     536:	781b      	ldrb	r3, [r3, #0]
     538:	2b73      	cmp	r3, #115	; 0x73
     53a:	d009      	beq.n	550 <loop+0x30>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     53c:	2109      	movs	r1, #9
     53e:	4810      	ldr	r0, [pc, #64]	; (580 <loop+0x60>)
     540:	f002 fff6 	bl	3530 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     544:	480f      	ldr	r0, [pc, #60]	; (584 <loop+0x64>)
     546:	f003 fa8f 	bl	3a68 <Print::println()>
			//restarted after having stopped --> restart controlelr
			if (hasRun) restartController = true;
		}
		else {
			Serial.println("Stopping!");
			running = false;
     54a:	2300      	movs	r3, #0
     54c:	7023      	strb	r3, [r4, #0]
     54e:	bd10      	pop	{r4, pc}

	//should probably be improved --> FSM would maybe be nice
	#if !ENCODER_ONLY_MODE
	if (Serial.available() > 0) {
		incomingData = Serial.read();
		if (incomingData == 's' && !running) {
     550:	7823      	ldrb	r3, [r4, #0]
     552:	2b00      	cmp	r3, #0
     554:	d1f2      	bne.n	53c <loop+0x1c>
     556:	2109      	movs	r1, #9
     558:	480b      	ldr	r0, [pc, #44]	; (588 <loop+0x68>)
     55a:	f002 ffe9 	bl	3530 <usb_serial_write>
     55e:	4809      	ldr	r0, [pc, #36]	; (584 <loop+0x64>)
     560:	f003 fa82 	bl	3a68 <Print::println()>
			Serial.println("Starting!");
			running = true;
     564:	2301      	movs	r3, #1

			//restarted after having stopped --> restart controlelr
			if (hasRun) restartController = true;
     566:	4a09      	ldr	r2, [pc, #36]	; (58c <loop+0x6c>)
	#if !ENCODER_ONLY_MODE
	if (Serial.available() > 0) {
		incomingData = Serial.read();
		if (incomingData == 's' && !running) {
			Serial.println("Starting!");
			running = true;
     568:	7023      	strb	r3, [r4, #0]

			//restarted after having stopped --> restart controlelr
			if (hasRun) restartController = true;
     56a:	7812      	ldrb	r2, [r2, #0]
     56c:	b902      	cbnz	r2, 570 <loop+0x50>
     56e:	bd10      	pop	{r4, pc}
     570:	4a07      	ldr	r2, [pc, #28]	; (590 <loop+0x70>)
     572:	7013      	strb	r3, [r2, #0]
			Serial.println("Stopping!");
			running = false;
		}
	}
	#endif // !ENCODER_ONLY_MODE
}
     574:	bd10      	pop	{r4, pc}
     576:	bf00      	nop
     578:	1fff1540 	.word	0x1fff1540
     57c:	1fff1508 	.word	0x1fff1508
     580:	000068d4 	.word	0x000068d4
     584:	1fff09ec 	.word	0x1fff09ec
     588:	000068c8 	.word	0x000068c8
     58c:	1fff154c 	.word	0x1fff154c
     590:	1fff14f0 	.word	0x1fff14f0

00000594 <_GLOBAL__sub_I_timer>:

//used for testing purposes only
void toggleTestPin() {
	toggleValue ^= 1;
	digitalWriteFast(DEBUG_PIN, toggleValue);
     594:	b530      	push	{r4, r5, lr}
     596:	ed2d 8b04 	vpush	{d8-d9}
class IntervalTimer {
private:
	static const uint32_t MAX_PERIOD = UINT32_MAX / (F_BUS / 1000000.0);
public:
	IntervalTimer() {
		channel = NULL;
     59a:	4b31      	ldr	r3, [pc, #196]	; (660 <_GLOBAL__sub_I_timer+0xcc>)
//============PRONATION-SUPINATION============
double encoderPosPS = 0;	//input
double commandPS = 0;		//output
double setPointPS = 0;		//setPoint in encoder steps

PS_ControlledDcMotor motorPS(PS_DIR, PS_PWM, &encoderPosPS, &commandPS, &setPointPS, Kp, Ki, Kd, LOOP_SAMPLE_TIME);
     59c:	ed9f 9a31 	vldr	s18, [pc, #196]	; 664 <_GLOBAL__sub_I_timer+0xd0>
     5a0:	eddf 8a31 	vldr	s17, [pc, #196]	; 668 <_GLOBAL__sub_I_timer+0xd4>
     5a4:	ed9f 8a31 	vldr	s16, [pc, #196]	; 66c <_GLOBAL__sub_I_timer+0xd8>
#include "PS_ControlledDcMotor.h"
#include "FE_ControlledDcMotor.h"

#include <IntervalTimer.h>

IntervalTimer timer;	//handles main control loop at fixed frequency
     5a8:	4a31      	ldr	r2, [pc, #196]	; (670 <_GLOBAL__sub_I_timer+0xdc>)
     5aa:	4932      	ldr	r1, [pc, #200]	; (674 <_GLOBAL__sub_I_timer+0xe0>)

//used for testing purposes only
void toggleTestPin() {
	toggleValue ^= 1;
	digitalWriteFast(DEBUG_PIN, toggleValue);
     5ac:	b085      	sub	sp, #20
     5ae:	2500      	movs	r5, #0
		nvic_priority = 128;
     5b0:	2480      	movs	r4, #128	; 0x80
#include "PS_ControlledDcMotor.h"
#include "FE_ControlledDcMotor.h"

#include <IntervalTimer.h>

IntervalTimer timer;	//handles main control loop at fixed frequency
     5b2:	4618      	mov	r0, r3
class IntervalTimer {
private:
	static const uint32_t MAX_PERIOD = UINT32_MAX / (F_BUS / 1000000.0);
public:
	IntervalTimer() {
		channel = NULL;
     5b4:	601d      	str	r5, [r3, #0]
		nvic_priority = 128;
     5b6:	711c      	strb	r4, [r3, #4]
     5b8:	f005 fc7c 	bl	5eb4 <__aeabi_atexit>
//============PRONATION-SUPINATION============
double encoderPosPS = 0;	//input
double commandPS = 0;		//output
double setPointPS = 0;		//setPoint in encoder steps

PS_ControlledDcMotor motorPS(PS_DIR, PS_PWM, &encoderPosPS, &commandPS, &setPointPS, Kp, Ki, Kd, LOOP_SAMPLE_TIME);
     5bc:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
     5c0:	4a2d      	ldr	r2, [pc, #180]	; (678 <_GLOBAL__sub_I_timer+0xe4>)
     5c2:	4b2e      	ldr	r3, [pc, #184]	; (67c <_GLOBAL__sub_I_timer+0xe8>)
     5c4:	9201      	str	r2, [sp, #4]
     5c6:	eeb0 1a49 	vmov.f32	s2, s18
     5ca:	eef0 0a68 	vmov.f32	s1, s17
     5ce:	eeb0 0a48 	vmov.f32	s0, s16
     5d2:	9300      	str	r3, [sp, #0]
     5d4:	9402      	str	r4, [sp, #8]
     5d6:	4b2a      	ldr	r3, [pc, #168]	; (680 <_GLOBAL__sub_I_timer+0xec>)
     5d8:	482a      	ldr	r0, [pc, #168]	; (684 <_GLOBAL__sub_I_timer+0xf0>)
     5da:	2208      	movs	r2, #8
     5dc:	2107      	movs	r1, #7
     5de:	f000 fe97 	bl	1310 <PS_ControlledDcMotor::PS_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)>
CurrentSensor currentSensorPS(PS_CURRENT, ADC_RESOLUTION, PS_FAULT_CURRENT);
     5e2:	230a      	movs	r3, #10
     5e4:	220c      	movs	r2, #12
     5e6:	2116      	movs	r1, #22
     5e8:	4827      	ldr	r0, [pc, #156]	; (688 <_GLOBAL__sub_I_timer+0xf4>)
     5ea:	f000 fa0d 	bl	a08 <CurrentSensor::CurrentSensor(unsigned char, unsigned char, unsigned char)>

uint32_t waveformAmplitudePS = lroundf(20 * DEGREES_TO_STEPS * PS_GEAR_RATIO);
Waveform setPointWaveformPS(Waveform::TRIANGLE, secToMicroSec(4.0f), waveformAmplitudePS);
     5ee:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
     5f2:	f000 fc87 	bl	f04 <secToMicroSec(float)>
     5f6:	4b25      	ldr	r3, [pc, #148]	; (68c <_GLOBAL__sub_I_timer+0xf8>)
     5f8:	ed93 0a00 	vldr	s0, [r3]
     5fc:	4602      	mov	r2, r0
     5fe:	eeb8 0a40 	vcvt.f32.u32	s0, s0
     602:	2101      	movs	r1, #1
     604:	4822      	ldr	r0, [pc, #136]	; (690 <_GLOBAL__sub_I_timer+0xfc>)
     606:	f001 f895 	bl	1734 <Waveform::Waveform(Waveform::Type, unsigned long, float)>
//============FLEXION-EXTENSION============
double encoderPosFE = 0;	//input
double commandFE = 0;		//output
double setPointFE = 0;		//setPoint in encoder steps

FE_ControlledDcMotor motorFE(FE_DIR, FE_PWM, &encoderPosFE, &commandFE, &setPointFE, Kp, Ki, Kd, LOOP_SAMPLE_TIME);
     60a:	4a22      	ldr	r2, [pc, #136]	; (694 <_GLOBAL__sub_I_timer+0x100>)
     60c:	4b22      	ldr	r3, [pc, #136]	; (698 <_GLOBAL__sub_I_timer+0x104>)
     60e:	9201      	str	r2, [sp, #4]
     610:	eeb0 1a49 	vmov.f32	s2, s18
     614:	eef0 0a68 	vmov.f32	s1, s17
     618:	eeb0 0a48 	vmov.f32	s0, s16
     61c:	9300      	str	r3, [sp, #0]
     61e:	9402      	str	r4, [sp, #8]
     620:	4b1e      	ldr	r3, [pc, #120]	; (69c <_GLOBAL__sub_I_timer+0x108>)
     622:	481f      	ldr	r0, [pc, #124]	; (6a0 <_GLOBAL__sub_I_timer+0x10c>)
     624:	2206      	movs	r2, #6
     626:	2105      	movs	r1, #5
     628:	f000 fae2 	bl	bf0 <FE_ControlledDcMotor::FE_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)>
CurrentSensor currentSensorFE(FE_CURRENT, ADC_RESOLUTION, FE_FAULT_CURRENT);
     62c:	2309      	movs	r3, #9
     62e:	220c      	movs	r2, #12
     630:	2117      	movs	r1, #23
     632:	481c      	ldr	r0, [pc, #112]	; (6a4 <_GLOBAL__sub_I_timer+0x110>)
     634:	f000 f9e8 	bl	a08 <CurrentSensor::CurrentSensor(unsigned char, unsigned char, unsigned char)>

uint32_t waveformAmplitudeFE = lroundf(20 * DEGREES_TO_STEPS * FE_GEAR_RATIO);
Waveform setPointWaveformFE(Waveform::TRIANGLE, secToMicroSec(4.0f), waveformAmplitudeFE);
     638:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
     63c:	f000 fc62 	bl	f04 <secToMicroSec(float)>
     640:	4b19      	ldr	r3, [pc, #100]	; (6a8 <_GLOBAL__sub_I_timer+0x114>)
     642:	ed93 0a00 	vldr	s0, [r3]
     646:	4602      	mov	r2, r0
     648:	eeb8 0a40 	vcvt.f32.u32	s0, s0
     64c:	4817      	ldr	r0, [pc, #92]	; (6ac <_GLOBAL__sub_I_timer+0x118>)
     64e:	2101      	movs	r1, #1

//used for testing purposes only
void toggleTestPin() {
	toggleValue ^= 1;
	digitalWriteFast(DEBUG_PIN, toggleValue);
     650:	b005      	add	sp, #20
     652:	ecbd 8b04 	vpop	{d8-d9}
     656:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}

FE_ControlledDcMotor motorFE(FE_DIR, FE_PWM, &encoderPosFE, &commandFE, &setPointFE, Kp, Ki, Kd, LOOP_SAMPLE_TIME);
CurrentSensor currentSensorFE(FE_CURRENT, ADC_RESOLUTION, FE_FAULT_CURRENT);

uint32_t waveformAmplitudeFE = lroundf(20 * DEGREES_TO_STEPS * FE_GEAR_RATIO);
Waveform setPointWaveformFE(Waveform::TRIANGLE, secToMicroSec(4.0f), waveformAmplitudeFE);
     65a:	f001 b86b 	b.w	1734 <Waveform::Waveform(Waveform::Type, unsigned long, float)>
     65e:	bf00      	nop
     660:	1fff1544 	.word	0x1fff1544
     664:	3d03126f 	.word	0x3d03126f
     668:	3f1374bc 	.word	0x3f1374bc
     66c:	3f9fbe77 	.word	0x3f9fbe77
     670:	1fff080c 	.word	0x1fff080c
     674:	00000491 	.word	0x00000491
     678:	1fff14f8 	.word	0x1fff14f8
     67c:	1fff1538 	.word	0x1fff1538
     680:	1fff1530 	.word	0x1fff1530
     684:	1fff13e8 	.word	0x1fff13e8
     688:	1fff15a8 	.word	0x1fff15a8
     68c:	1fff0814 	.word	0x1fff0814
     690:	1fff14d0 	.word	0x1fff14d0
     694:	1fff1500 	.word	0x1fff1500
     698:	1fff14e8 	.word	0x1fff14e8
     69c:	1fff1510 	.word	0x1fff1510
     6a0:	1fff1300 	.word	0x1fff1300
     6a4:	1fff1550 	.word	0x1fff1550
     6a8:	1fff0810 	.word	0x1fff0810
     6ac:	1fff1518 	.word	0x1fff1518

000006b0 <setup>:
	analogWriteFrequency(FE_PWM, PWM_FREQUENCY);
	analogWriteFrequency(PS_PWM, PWM_FREQUENCY);
	analogWriteResolution(PWM_RESOLUTION);
}

void setup(){
     6b0:	b508      	push	{r3, lr}
void _init_Teensyduino_internal_(void);

int analogRead(uint8_t pin);
void analogReference(uint8_t type);
void analogReadRes(unsigned int bits);
static inline void analogReadResolution(unsigned int bits) { analogReadRes(bits); }
     6b2:	200c      	movs	r0, #12
     6b4:	f001 f9ca 	bl	1a4c <analogReadRes>
	Serial.begin(115200); // USB is always 12 Mbit/sec, but a Baud rate has to be specified --> 115200 matches the one used in the Unity program

	analogReadResolution(ADC_RESOLUTION);
	setupPins();
     6b8:	f7ff fef0 	bl	49c <setupPins()>
	setupPWM();
     6bc:	f7ff ff18 	bl	4f0 <setupPWM()>

	//homing has to be done before starting the timer loop
	//homeDevice();

	motorPS.zeroEncoder();
     6c0:	4808      	ldr	r0, [pc, #32]	; (6e4 <setup+0x34>)
     6c2:	f000 fe1f 	bl	1304 <PS_ControlledDcMotor::zeroEncoder()>
	motorFE.zeroEncoder();
     6c6:	4808      	ldr	r0, [pc, #32]	; (6e8 <setup+0x38>)
     6c8:	f000 fa8c 	bl	be4 <FE_ControlledDcMotor::zeroEncoder()>
	}
	bool begin(void (*funct)(), unsigned int microseconds) {
		if (microseconds == 0 || microseconds > MAX_PERIOD) return false;
		uint32_t cycles = (F_BUS / 1000000) * microseconds - 1;
		if (cycles < 36) return false;
		return beginCycles(funct, cycles);
     6cc:	4907      	ldr	r1, [pc, #28]	; (6ec <setup+0x3c>)
     6ce:	4808      	ldr	r0, [pc, #32]	; (6f0 <setup+0x40>)
     6d0:	f64e 225f 	movw	r2, #59999	; 0xea5f
     6d4:	f003 f92c 	bl	3930 <IntervalTimer::beginCycles(void (*)(), unsigned long)>

	timer.begin(timerLoopISR, LOOP_SAMPLE_TIME);
	timeCounter = 0;
     6d8:	4b06      	ldr	r3, [pc, #24]	; (6f4 <setup+0x44>)
     6da:	2000      	movs	r0, #0
     6dc:	2100      	movs	r1, #0
     6de:	e9c3 0100 	strd	r0, r1, [r3]
     6e2:	bd08      	pop	{r3, pc}
     6e4:	1fff13e8 	.word	0x1fff13e8
     6e8:	1fff1300 	.word	0x1fff1300
     6ec:	000007bd 	.word	0x000007bd
     6f0:	1fff1544 	.word	0x1fff1544
     6f4:	1fff1600 	.word	0x1fff1600

000006f8 <serialPrint()>:
	motorPS.zeroEncoder();
}

//should later be optimized to send raw byte data instead of strings --> would transmit significantly less data --> faster
//should also include a start & end byte to allow verification of a correct data transmission
void serialPrint() {
     6f8:	b538      	push	{r3, r4, r5, lr}
	Serial.print(setPointPS);
     6fa:	4b28      	ldr	r3, [pc, #160]	; (79c <serialPrint()+0xa4>)
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
     6fc:	4c28      	ldr	r4, [pc, #160]	; (7a0 <serialPrint()+0xa8>)
     6fe:	4d29      	ldr	r5, [pc, #164]	; (7a4 <serialPrint()+0xac>)
     700:	ed93 0b00 	vldr	d0, [r3]
     704:	4620      	mov	r0, r4
     706:	2102      	movs	r1, #2
     708:	f003 fa06 	bl	3b18 <Print::printFloat(double, unsigned char)>
     70c:	2101      	movs	r1, #1
     70e:	4628      	mov	r0, r5
     710:	f002 ff0e 	bl	3530 <usb_serial_write>
	Serial.print(" ");
	Serial.print(motorPS.getEncoderValue());
     714:	4824      	ldr	r0, [pc, #144]	; (7a8 <serialPrint()+0xb0>)
     716:	f000 ff17 	bl	1548 <PS_ControlledDcMotor::getEncoderValue()>
     71a:	4601      	mov	r1, r0
     71c:	4620      	mov	r0, r4
     71e:	f003 f9f3 	bl	3b08 <Print::print(long)>
     722:	2101      	movs	r1, #1
     724:	4628      	mov	r0, r5
     726:	f002 ff03 	bl	3530 <usb_serial_write>
	Serial.print(" ");
	Serial.println(currentSensorPS.getAverageCurrent());
     72a:	4820      	ldr	r0, [pc, #128]	; (7ac <serialPrint()+0xb4>)
     72c:	f000 f9d8 	bl	ae0 <CurrentSensor::getAverageCurrent()>
     730:	ee10 0a10 	vmov	r0, s0
     734:	f005 f822 	bl	577c <__aeabi_f2d>
     738:	ec41 0b10 	vmov	d0, r0, r1
     73c:	2102      	movs	r1, #2
     73e:	4620      	mov	r0, r4
     740:	f003 f9ea 	bl	3b18 <Print::printFloat(double, unsigned char)>
	size_t println(int n, int base)			{ return print(n, base) + println(); }
	size_t println(unsigned int n, int base)	{ return print(n, base) + println(); }
	size_t println(long n, int base)		{ return print(n, base) + println(); }
	size_t println(unsigned long n, int base)	{ return print(n, base) + println(); }

	size_t println(double n, int digits = 2)	{ return print(n, digits) + println(); }
     744:	4620      	mov	r0, r4
     746:	f003 f98f 	bl	3a68 <Print::println()>
	
	Serial.print(setPointFE);
     74a:	4b19      	ldr	r3, [pc, #100]	; (7b0 <serialPrint()+0xb8>)
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }

	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
     74c:	4620      	mov	r0, r4
     74e:	ed93 0b00 	vldr	d0, [r3]
     752:	2102      	movs	r1, #2
     754:	f003 f9e0 	bl	3b18 <Print::printFloat(double, unsigned char)>
     758:	2101      	movs	r1, #1
     75a:	4628      	mov	r0, r5
     75c:	f002 fee8 	bl	3530 <usb_serial_write>
	Serial.print(" ");
	Serial.print(motorFE.getEncoderValue());
     760:	4814      	ldr	r0, [pc, #80]	; (7b4 <serialPrint()+0xbc>)
     762:	f000 fb61 	bl	e28 <FE_ControlledDcMotor::getEncoderValue()>
     766:	4601      	mov	r1, r0
     768:	4620      	mov	r0, r4
     76a:	f003 f9cd 	bl	3b08 <Print::print(long)>
     76e:	2101      	movs	r1, #1
     770:	4628      	mov	r0, r5
     772:	f002 fedd 	bl	3530 <usb_serial_write>
	Serial.print(" ");
	Serial.println(currentSensorFE.getAverageCurrent());
     776:	4810      	ldr	r0, [pc, #64]	; (7b8 <serialPrint()+0xc0>)
     778:	f000 f9b2 	bl	ae0 <CurrentSensor::getAverageCurrent()>
     77c:	ee10 0a10 	vmov	r0, s0
     780:	f004 fffc 	bl	577c <__aeabi_f2d>
     784:	ec41 0b10 	vmov	d0, r0, r1
     788:	4620      	mov	r0, r4
     78a:	2102      	movs	r1, #2
     78c:	f003 f9c4 	bl	3b18 <Print::printFloat(double, unsigned char)>
	size_t println(int n, int base)			{ return print(n, base) + println(); }
	size_t println(unsigned int n, int base)	{ return print(n, base) + println(); }
	size_t println(long n, int base)		{ return print(n, base) + println(); }
	size_t println(unsigned long n, int base)	{ return print(n, base) + println(); }

	size_t println(double n, int digits = 2)	{ return print(n, digits) + println(); }
     790:	4620      	mov	r0, r4
}
     792:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     796:	f003 b967 	b.w	3a68 <Print::println()>
     79a:	bf00      	nop
     79c:	1fff14f8 	.word	0x1fff14f8
     7a0:	1fff09ec 	.word	0x1fff09ec
     7a4:	000068e0 	.word	0x000068e0
     7a8:	1fff13e8 	.word	0x1fff13e8
     7ac:	1fff15a8 	.word	0x1fff15a8
     7b0:	1fff1500 	.word	0x1fff1500
     7b4:	1fff1300 	.word	0x1fff1300
     7b8:	1fff1550 	.word	0x1fff1550

000007bc <timerLoopISR()>:
		serialPosition();
		sendCounter = 0;
	}else
		sendCounter++;
	#else
	if (!running && hasRun) {
     7bc:	4b26      	ldr	r3, [pc, #152]	; (858 <timerLoopISR()+0x9c>)
     7be:	781a      	ldrb	r2, [r3, #0]
	}
	#endif // !ENCODER_ONLY_MODE
}

//runs with a frequency of 1.0f/LOOP_SAMPLE_TIME
void timerLoopISR(void) {
     7c0:	b510      	push	{r4, lr}
		serialPosition();
		sendCounter = 0;
	}else
		sendCounter++;
	#else
	if (!running && hasRun) {
     7c2:	b952      	cbnz	r2, 7da <timerLoopISR()+0x1e>
     7c4:	4a25      	ldr	r2, [pc, #148]	; (85c <timerLoopISR()+0xa0>)
     7c6:	7812      	ldrb	r2, [r2, #0]
     7c8:	b13a      	cbz	r2, 7da <timerLoopISR()+0x1e>
		motorPS.stopMotor();
     7ca:	4825      	ldr	r0, [pc, #148]	; (860 <timerLoopISR()+0xa4>)
     7cc:	f000 f90c 	bl	9e8 <ControlledDcMotor::stopMotor()>
		motorFE.stopMotor();
     7d0:	4824      	ldr	r0, [pc, #144]	; (864 <timerLoopISR()+0xa8>)
	motorPS.handleMotorControl();
	motorFE.handleMotorControl();

	serialPrint();
	#endif // ENCODER_ONLY_MODE
}
     7d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	}else
		sendCounter++;
	#else
	if (!running && hasRun) {
		motorPS.stopMotor();
		motorFE.stopMotor();
     7d6:	f000 b907 	b.w	9e8 <ControlledDcMotor::stopMotor()>
		return;
	}

	if (!running) return;
     7da:	781b      	ldrb	r3, [r3, #0]
     7dc:	2b00      	cmp	r3, #0
     7de:	d031      	beq.n	844 <timerLoopISR()+0x88>

	if (restartController) {
     7e0:	4b21      	ldr	r3, [pc, #132]	; (868 <timerLoopISR()+0xac>)
     7e2:	781b      	ldrb	r3, [r3, #0]
     7e4:	2b00      	cmp	r3, #0
     7e6:	d12e      	bne.n	846 <timerLoopISR()+0x8a>
		motorPS.setControllerMode(AUTOMATIC);
		motorFE.setControllerMode(AUTOMATIC);
	}

	hasRun = true;
     7e8:	4b1c      	ldr	r3, [pc, #112]	; (85c <timerLoopISR()+0xa0>)
	timeCounter += LOOP_SAMPLE_TIME;
     7ea:	4c20      	ldr	r4, [pc, #128]	; (86c <timerLoopISR()+0xb0>)

	//setpoint calculation should/could probably be moved from isr to loop, because timeCounter would be correct anyway
	setPointPS = setPointWaveformPS.getValue(timeCounter);
     7ec:	4820      	ldr	r0, [pc, #128]	; (870 <timerLoopISR()+0xb4>)
	if (restartController) {
		motorPS.setControllerMode(AUTOMATIC);
		motorFE.setControllerMode(AUTOMATIC);
	}

	hasRun = true;
     7ee:	2201      	movs	r2, #1
     7f0:	701a      	strb	r2, [r3, #0]
	timeCounter += LOOP_SAMPLE_TIME;
     7f2:	e9d4 2300 	ldrd	r2, r3, [r4]
     7f6:	f512 727a 	adds.w	r2, r2, #1000	; 0x3e8
     7fa:	f143 0300 	adc.w	r3, r3, #0
     7fe:	e9c4 2300 	strd	r2, r3, [r4]

	//setpoint calculation should/could probably be moved from isr to loop, because timeCounter would be correct anyway
	setPointPS = setPointWaveformPS.getValue(timeCounter);
     802:	e9d4 2300 	ldrd	r2, r3, [r4]
     806:	4611      	mov	r1, r2
     808:	f000 ffaa 	bl	1760 <Waveform::getValue(unsigned long)>
	setPointFE = setPointWaveformFE.getValue(timeCounter);
     80c:	e9d4 2300 	ldrd	r2, r3, [r4]

	hasRun = true;
	timeCounter += LOOP_SAMPLE_TIME;

	//setpoint calculation should/could probably be moved from isr to loop, because timeCounter would be correct anyway
	setPointPS = setPointWaveformPS.getValue(timeCounter);
     810:	4b18      	ldr	r3, [pc, #96]	; (874 <timerLoopISR()+0xb8>)
	setPointFE = setPointWaveformFE.getValue(timeCounter);
     812:	4819      	ldr	r0, [pc, #100]	; (878 <timerLoopISR()+0xbc>)
     814:	4611      	mov	r1, r2

	hasRun = true;
	timeCounter += LOOP_SAMPLE_TIME;

	//setpoint calculation should/could probably be moved from isr to loop, because timeCounter would be correct anyway
	setPointPS = setPointWaveformPS.getValue(timeCounter);
     816:	ed83 0b00 	vstr	d0, [r3]
	setPointFE = setPointWaveformFE.getValue(timeCounter);
     81a:	f000 ffa1 	bl	1760 <Waveform::getValue(unsigned long)>
     81e:	4b17      	ldr	r3, [pc, #92]	; (87c <timerLoopISR()+0xc0>)

	currentSensorPS.sampleSensor();
     820:	4817      	ldr	r0, [pc, #92]	; (880 <timerLoopISR()+0xc4>)
	hasRun = true;
	timeCounter += LOOP_SAMPLE_TIME;

	//setpoint calculation should/could probably be moved from isr to loop, because timeCounter would be correct anyway
	setPointPS = setPointWaveformPS.getValue(timeCounter);
	setPointFE = setPointWaveformFE.getValue(timeCounter);
     822:	ed83 0b00 	vstr	d0, [r3]

	currentSensorPS.sampleSensor();
     826:	f000 f92d 	bl	a84 <CurrentSensor::sampleSensor()>
	currentSensorFE.sampleSensor();
     82a:	4816      	ldr	r0, [pc, #88]	; (884 <timerLoopISR()+0xc8>)
     82c:	f000 f92a 	bl	a84 <CurrentSensor::sampleSensor()>

	motorPS.handleMotorControl();
     830:	480b      	ldr	r0, [pc, #44]	; (860 <timerLoopISR()+0xa4>)
     832:	f000 fe55 	bl	14e0 <PS_ControlledDcMotor::handleMotorControl()>
	motorFE.handleMotorControl();
     836:	480b      	ldr	r0, [pc, #44]	; (864 <timerLoopISR()+0xa8>)
     838:	f000 fac2 	bl	dc0 <FE_ControlledDcMotor::handleMotorControl()>

	serialPrint();
	#endif // ENCODER_ONLY_MODE
}
     83c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	currentSensorFE.sampleSensor();

	motorPS.handleMotorControl();
	motorFE.handleMotorControl();

	serialPrint();
     840:	f7ff bf5a 	b.w	6f8 <serialPrint()>
     844:	bd10      	pop	{r4, pc}
	}

	if (!running) return;

	if (restartController) {
		motorPS.setControllerMode(AUTOMATIC);
     846:	2101      	movs	r1, #1
     848:	4805      	ldr	r0, [pc, #20]	; (860 <timerLoopISR()+0xa4>)
     84a:	f000 f8d9 	bl	a00 <ControlledDcMotor::setControllerMode(bool)>
		motorFE.setControllerMode(AUTOMATIC);
     84e:	2101      	movs	r1, #1
     850:	4804      	ldr	r0, [pc, #16]	; (864 <timerLoopISR()+0xa8>)
     852:	f000 f8d5 	bl	a00 <ControlledDcMotor::setControllerMode(bool)>
     856:	e7c7      	b.n	7e8 <timerLoopISR()+0x2c>
     858:	1fff1508 	.word	0x1fff1508
     85c:	1fff154c 	.word	0x1fff154c
     860:	1fff13e8 	.word	0x1fff13e8
     864:	1fff1300 	.word	0x1fff1300
     868:	1fff14f0 	.word	0x1fff14f0
     86c:	1fff1600 	.word	0x1fff1600
     870:	1fff14d0 	.word	0x1fff14d0
     874:	1fff14f8 	.word	0x1fff14f8
     878:	1fff1518 	.word	0x1fff1518
     87c:	1fff1500 	.word	0x1fff1500
     880:	1fff15a8 	.word	0x1fff15a8
     884:	1fff1550 	.word	0x1fff1550

00000888 <ControlledDcMotor::ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)>:
#include "ControlledDcMotor.h"

ControlledDcMotor::ControlledDcMotor(uint8_t motorDirPin, uint8_t motorPwmPin, double* input, double* output, double* setPoint, float Kp, float Ki, float Kd, const uint16_t intervall)
     888:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	: _motor(motorDirPin, motorPwmPin), _controller(input, output, setPoint, Kp, Ki, Kd, DIRECT, intervall){
     88c:	4d2c      	ldr	r5, [pc, #176]	; (940 <ControlledDcMotor::ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0xb8>)
#include "ControlledDcMotor.h"

ControlledDcMotor::ControlledDcMotor(uint8_t motorDirPin, uint8_t motorPwmPin, double* input, double* output, double* setPoint, float Kp, float Ki, float Kd, const uint16_t intervall)
     88e:	b089      	sub	sp, #36	; 0x24
     890:	4604      	mov	r4, r0
	: _motor(motorDirPin, motorPwmPin), _controller(input, output, setPoint, Kp, Ki, Kd, DIRECT, intervall){
     892:	f840 5b18 	str.w	r5, [r0], #24
#include "ControlledDcMotor.h"

ControlledDcMotor::ControlledDcMotor(uint8_t motorDirPin, uint8_t motorPwmPin, double* input, double* output, double* setPoint, float Kp, float Ki, float Kd, const uint16_t intervall)
     896:	4698      	mov	r8, r3
     898:	ed8d 0a07 	vstr	s0, [sp, #28]
     89c:	9f10      	ldr	r7, [sp, #64]	; 0x40
     89e:	9e11      	ldr	r6, [sp, #68]	; 0x44
     8a0:	f8bd 9048 	ldrh.w	r9, [sp, #72]	; 0x48
     8a4:	edcd 0a02 	vstr	s1, [sp, #8]
     8a8:	ed8d 1a04 	vstr	s2, [sp, #16]
	: _motor(motorDirPin, motorPwmPin), _controller(input, output, setPoint, Kp, Ki, Kd, DIRECT, intervall){
     8ac:	f000 f948 	bl	b40 <DC_Motor::DC_Motor(unsigned char, unsigned char)>
     8b0:	ed9d 1a04 	vldr	s2, [sp, #16]
     8b4:	ee11 0a10 	vmov	r0, s2
     8b8:	f004 ff60 	bl	577c <__aeabi_f2d>
     8bc:	eddd 0a02 	vldr	s1, [sp, #8]
     8c0:	e9cd 0104 	strd	r0, r1, [sp, #16]
     8c4:	ee10 0a90 	vmov	r0, s1
     8c8:	f004 ff58 	bl	577c <__aeabi_f2d>
     8cc:	ed9d 0a07 	vldr	s0, [sp, #28]
     8d0:	e9cd 0102 	strd	r0, r1, [sp, #8]
     8d4:	ee10 0a10 	vmov	r0, s0
     8d8:	f004 ff50 	bl	577c <__aeabi_f2d>
     8dc:	f104 0520 	add.w	r5, r4, #32
     8e0:	f04f 0e00 	mov.w	lr, #0
     8e4:	ec41 0b10 	vmov	d0, r0, r1
     8e8:	ed9d 2b04 	vldr	d2, [sp, #16]
     8ec:	4633      	mov	r3, r6
     8ee:	463a      	mov	r2, r7
     8f0:	4641      	mov	r1, r8
     8f2:	f8cd e000 	str.w	lr, [sp]
     8f6:	ed9d 1b02 	vldr	d1, [sp, #8]
     8fa:	f8cd 9004 	str.w	r9, [sp, #4]
     8fe:	4628      	mov	r0, r5
     900:	f000 fb5a 	bl	fb8 <PID::PID(double*, double*, double*, double, double, double, int, unsigned short)>
	
	_sampleTime = intervall;
	_controller.SetOutputLimits(-PWM_MAX_VALUE, PWM_MAX_VALUE);	//-255 to 255 so both directions work
     904:	4628      	mov	r0, r5
     906:	ed9f 1b0a 	vldr	d1, [pc, #40]	; 930 <ControlledDcMotor::ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0xa8>
     90a:	ed9f 0b0b 	vldr	d0, [pc, #44]	; 938 <ControlledDcMotor::ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0xb0>
#include "ControlledDcMotor.h"

ControlledDcMotor::ControlledDcMotor(uint8_t motorDirPin, uint8_t motorPwmPin, double* input, double* output, double* setPoint, float Kp, float Ki, float Kd, const uint16_t intervall)
	: _motor(motorDirPin, motorPwmPin), _controller(input, output, setPoint, Kp, Ki, Kd, DIRECT, intervall){
	
	_sampleTime = intervall;
     90e:	f884 9010 	strb.w	r9, [r4, #16]
	_controller.SetOutputLimits(-PWM_MAX_VALUE, PWM_MAX_VALUE);	//-255 to 255 so both directions work
     912:	f000 fc4d 	bl	11b0 <PID::SetOutputLimits(double, double)>
	_controller.SetMode(AUTOMATIC);
     916:	4628      	mov	r0, r5
     918:	2101      	movs	r1, #1
     91a:	f000 fc93 	bl	1244 <PID::SetMode(int)>
	_input = input;
	_output = output;
	_setPoint = setPoint;

	//zeroEncoder(); //handled in derived class
}
     91e:	4620      	mov	r0, r4
	
	_sampleTime = intervall;
	_controller.SetOutputLimits(-PWM_MAX_VALUE, PWM_MAX_VALUE);	//-255 to 255 so both directions work
	_controller.SetMode(AUTOMATIC);

	_input = input;
     920:	f8c4 8004 	str.w	r8, [r4, #4]
	_output = output;
     924:	60a7      	str	r7, [r4, #8]
	_setPoint = setPoint;
     926:	60e6      	str	r6, [r4, #12]

	//zeroEncoder(); //handled in derived class
}
     928:	b009      	add	sp, #36	; 0x24
     92a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     92e:	bf00      	nop
     930:	00000000 	.word	0x00000000
     934:	40affe00 	.word	0x40affe00
     938:	00000000 	.word	0x00000000
     93c:	c0affe00 	.word	0xc0affe00
     940:	000068ec 	.word	0x000068ec
     944:	ffffffff 	.word	0xffffffff

00000948 <ControlledDcMotor::calculate()>:

//virtual function that has been replaced in derived class
//void ControlledDcMotor::handleMotorDriving(){}

//this function is called in handleMotorDriving of each derived class
void ControlledDcMotor::calculate() {
     948:	b570      	push	{r4, r5, r6, lr}
     94a:	4604      	mov	r4, r0
	//Encoder is being read in each instance of the derived classes --> see virtual func. handleEncoder

	_controller.Compute();
     94c:	3020      	adds	r0, #32
     94e:	f000 fb83 	bl	1058 <PID::Compute()>

	if (*(_output) < 0) _motor.setDir(0);
     952:	68a1      	ldr	r1, [r4, #8]
     954:	2200      	movs	r2, #0
     956:	2300      	movs	r3, #0
     958:	e9d1 0100 	ldrd	r0, r1, [r1]
     95c:	f005 f9d4 	bl	5d08 <__aeabi_dcmplt>
     960:	f104 0618 	add.w	r6, r4, #24
     964:	bb88      	cbnz	r0, 9ca <ControlledDcMotor::calculate()+0x82>
	else _motor.setDir(1);
     966:	4630      	mov	r0, r6
     968:	2101      	movs	r1, #1
     96a:	f000 f909 	bl	b80 <DC_Motor::setDir(bool)>
	uint16_t pwm = constrain(abs(*(_output)), 0, PWM_MAX_VALUE);
     96e:	68a3      	ldr	r3, [r4, #8]
     970:	e9d3 4500 	ldrd	r4, r5, [r3]
     974:	2200      	movs	r2, #0
     976:	2300      	movs	r3, #0
     978:	4620      	mov	r0, r4
     97a:	4629      	mov	r1, r5
     97c:	f005 f9e2 	bl	5d44 <__aeabi_dcmpgt>
     980:	b1f8      	cbz	r0, 9c2 <ControlledDcMotor::calculate()+0x7a>
     982:	2200      	movs	r2, #0
     984:	2300      	movs	r3, #0
     986:	4620      	mov	r0, r4
     988:	4629      	mov	r1, r5
     98a:	f005 f9bd 	bl	5d08 <__aeabi_dcmplt>
     98e:	bb08      	cbnz	r0, 9d4 <ControlledDcMotor::calculate()+0x8c>
     990:	a313      	add	r3, pc, #76	; (adr r3, 9e0 <ControlledDcMotor::calculate()+0x98>)
     992:	e9d3 2300 	ldrd	r2, r3, [r3]
     996:	4620      	mov	r0, r4
     998:	4629      	mov	r1, r5
     99a:	f005 f9d3 	bl	5d44 <__aeabi_dcmpgt>
     99e:	b948      	cbnz	r0, 9b4 <ControlledDcMotor::calculate()+0x6c>
     9a0:	4629      	mov	r1, r5
     9a2:	4620      	mov	r0, r4
     9a4:	f005 fa16 	bl	5dd4 <__aeabi_d2uiz>
     9a8:	b281      	uxth	r1, r0

	#if SPEED_LIMIT_MODE
	pwm = constrain(pwm, 0, 50);
	#endif // SPEED_LIMIT_MODE

	_motor.turn(pwm);
     9aa:	4630      	mov	r0, r6
}
     9ac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

	#if SPEED_LIMIT_MODE
	pwm = constrain(pwm, 0, 50);
	#endif // SPEED_LIMIT_MODE

	_motor.turn(pwm);
     9b0:	f000 b8d4 	b.w	b5c <DC_Motor::turn(unsigned short)>
     9b4:	4630      	mov	r0, r6
     9b6:	f640 71ff 	movw	r1, #4095	; 0xfff
}
     9ba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

	#if SPEED_LIMIT_MODE
	pwm = constrain(pwm, 0, 50);
	#endif // SPEED_LIMIT_MODE

	_motor.turn(pwm);
     9be:	f000 b8cd 	b.w	b5c <DC_Motor::turn(unsigned short)>

	_controller.Compute();

	if (*(_output) < 0) _motor.setDir(0);
	else _motor.setDir(1);
	uint16_t pwm = constrain(abs(*(_output)), 0, PWM_MAX_VALUE);
     9c2:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
     9c6:	461d      	mov	r5, r3
     9c8:	e7db      	b.n	982 <ControlledDcMotor::calculate()+0x3a>
void ControlledDcMotor::calculate() {
	//Encoder is being read in each instance of the derived classes --> see virtual func. handleEncoder

	_controller.Compute();

	if (*(_output) < 0) _motor.setDir(0);
     9ca:	4630      	mov	r0, r6
     9cc:	2100      	movs	r1, #0
     9ce:	f000 f8d7 	bl	b80 <DC_Motor::setDir(bool)>
     9d2:	e7cc      	b.n	96e <ControlledDcMotor::calculate()+0x26>

	#if SPEED_LIMIT_MODE
	pwm = constrain(pwm, 0, 50);
	#endif // SPEED_LIMIT_MODE

	_motor.turn(pwm);
     9d4:	4630      	mov	r0, r6
     9d6:	2100      	movs	r1, #0
}
     9d8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

	#if SPEED_LIMIT_MODE
	pwm = constrain(pwm, 0, 50);
	#endif // SPEED_LIMIT_MODE

	_motor.turn(pwm);
     9dc:	f000 b8be 	b.w	b5c <DC_Motor::turn(unsigned short)>
     9e0:	00000000 	.word	0x00000000
     9e4:	40affe00 	.word	0x40affe00

000009e8 <ControlledDcMotor::stopMotor()>:
void ControlledDcMotor::rotateMotor(uint8_t dir, uint16_t pwm){
	setControllerMode(MANUAL);
	_motor.turn(dir, pwm);
}

void ControlledDcMotor::stopMotor(){
     9e8:	b510      	push	{r4, lr}
     9ea:	4604      	mov	r4, r0
	_motor.stop();
     9ec:	3018      	adds	r0, #24
     9ee:	f000 f8c3 	bl	b78 <DC_Motor::stop()>
	setControllerMode(MANUAL);
}

void ControlledDcMotor::setControllerMode(bool mode){
	_controller.SetMode(mode);
     9f2:	f104 0020 	add.w	r0, r4, #32
     9f6:	2100      	movs	r1, #0
}

void ControlledDcMotor::stopMotor(){
	_motor.stop();
	setControllerMode(MANUAL);
}
     9f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void ControlledDcMotor::setControllerMode(bool mode){
	_controller.SetMode(mode);
     9fc:	f000 bc22 	b.w	1244 <PID::SetMode(int)>

00000a00 <ControlledDcMotor::setControllerMode(bool)>:
     a00:	3020      	adds	r0, #32
     a02:	f000 bc1f 	b.w	1244 <PID::SetMode(int)>
     a06:	bf00      	nop

00000a08 <CurrentSensor::CurrentSensor(unsigned char, unsigned char, unsigned char)>:
#include "CurrentSensor.h"
#include "Helper.h"

CurrentSensor::CurrentSensor(uint8_t analogPin, uint8_t analogResolution, uint8_t faultPin){
     a08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     a0c:	4604      	mov	r4, r0
     a0e:	460f      	mov	r7, r1
     a10:	2100      	movs	r1, #0
     a12:	4698      	mov	r8, r3
     a14:	460d      	mov	r5, r1
     a16:	4616      	mov	r6, r2
     a18:	300c      	adds	r0, #12
     a1a:	2240      	movs	r2, #64	; 0x40
     a1c:	f005 fd44 	bl	64a8 <memset>
	_analogPin = analogPin;
	_faultPin = faultPin;

	pinMode(_analogPin, INPUT);
     a20:	4638      	mov	r0, r7
     a22:	4629      	mov	r1, r5
#include "CurrentSensor.h"
#include "Helper.h"

CurrentSensor::CurrentSensor(uint8_t analogPin, uint8_t analogResolution, uint8_t faultPin){
	_analogPin = analogPin;
	_faultPin = faultPin;
     a24:	f884 8002 	strb.w	r8, [r4, #2]
#include "CurrentSensor.h"
#include "Helper.h"

CurrentSensor::CurrentSensor(uint8_t analogPin, uint8_t analogResolution, uint8_t faultPin){
	_analogPin = analogPin;
     a28:	7027      	strb	r7, [r4, #0]
#include "CurrentSensor.h"
#include "Helper.h"

CurrentSensor::CurrentSensor(uint8_t analogPin, uint8_t analogResolution, uint8_t faultPin){
     a2a:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
     a2e:	f884 504d 	strb.w	r5, [r4, #77]	; 0x4d
	_analogPin = analogPin;
	_faultPin = faultPin;

	pinMode(_analogPin, INPUT);
     a32:	f001 fd01 	bl	2438 <pinMode>
	pinMode(_faultPin, INPUT);
     a36:	4629      	mov	r1, r5
     a38:	78a0      	ldrb	r0, [r4, #2]
     a3a:	f001 fcfd 	bl	2438 <pinMode>

	analogReadAveraging(AVG_SAMPLES);
     a3e:	2010      	movs	r0, #16
     a40:	f001 f838 	bl	1ab4 <analogReadAveraging>
     a44:	4630      	mov	r0, r6
	changeResolution(analogResolution);
}

void CurrentSensor::changeResolution(uint8_t analogResolution) {
	_analogResolution = analogResolution;
     a46:	7066      	strb	r6, [r4, #1]
     a48:	f001 f800 	bl	1a4c <analogReadRes>
	analogReadResolution(analogResolution);

	uint16_t maxAdcValue = (1 << _analogResolution) - 1;
	_maxMesValue = (VOLTAGE_REFERENCE / 2 + SENSITIVITY * MAX_CURRENT) / VOLTAGE_REFERENCE * (float)maxAdcValue;
     a4c:	7862      	ldrb	r2, [r4, #1]
	_minMesValue = (VOLTAGE_REFERENCE / 2 - SENSITIVITY * MAX_CURRENT) / VOLTAGE_REFERENCE * (float)maxAdcValue;
     a4e:	eddf 6a0b 	vldr	s13, [pc, #44]	; a7c <CurrentSensor::CurrentSensor(unsigned char, unsigned char, unsigned char)+0x74>
void CurrentSensor::changeResolution(uint8_t analogResolution) {
	_analogResolution = analogResolution;
	analogReadResolution(analogResolution);

	uint16_t maxAdcValue = (1 << _analogResolution) - 1;
	_maxMesValue = (VOLTAGE_REFERENCE / 2 + SENSITIVITY * MAX_CURRENT) / VOLTAGE_REFERENCE * (float)maxAdcValue;
     a52:	ed9f 7a0b 	vldr	s14, [pc, #44]	; a80 <CurrentSensor::CurrentSensor(unsigned char, unsigned char, unsigned char)+0x78>
     a56:	2301      	movs	r3, #1
     a58:	4093      	lsls	r3, r2
     a5a:	3b01      	subs	r3, #1
     a5c:	b29b      	uxth	r3, r3
     a5e:	ee07 3a90 	vmov	s15, r3
     a62:	eef8 7a67 	vcvt.f32.u32	s15, s15
	pinMode(_analogPin, INPUT);
	pinMode(_faultPin, INPUT);

	analogReadAveraging(AVG_SAMPLES);
	changeResolution(analogResolution);
}
     a66:	4620      	mov	r0, r4
void CurrentSensor::changeResolution(uint8_t analogResolution) {
	_analogResolution = analogResolution;
	analogReadResolution(analogResolution);

	uint16_t maxAdcValue = (1 << _analogResolution) - 1;
	_maxMesValue = (VOLTAGE_REFERENCE / 2 + SENSITIVITY * MAX_CURRENT) / VOLTAGE_REFERENCE * (float)maxAdcValue;
     a68:	ee27 7a87 	vmul.f32	s14, s15, s14
	_minMesValue = (VOLTAGE_REFERENCE / 2 - SENSITIVITY * MAX_CURRENT) / VOLTAGE_REFERENCE * (float)maxAdcValue;
     a6c:	ee67 7aa6 	vmul.f32	s15, s15, s13
void CurrentSensor::changeResolution(uint8_t analogResolution) {
	_analogResolution = analogResolution;
	analogReadResolution(analogResolution);

	uint16_t maxAdcValue = (1 << _analogResolution) - 1;
	_maxMesValue = (VOLTAGE_REFERENCE / 2 + SENSITIVITY * MAX_CURRENT) / VOLTAGE_REFERENCE * (float)maxAdcValue;
     a70:	ed84 7a01 	vstr	s14, [r4, #4]
	_minMesValue = (VOLTAGE_REFERENCE / 2 - SENSITIVITY * MAX_CURRENT) / VOLTAGE_REFERENCE * (float)maxAdcValue;
     a74:	edc4 7a02 	vstr	s15, [r4, #8]
	pinMode(_analogPin, INPUT);
	pinMode(_faultPin, INPUT);

	analogReadAveraging(AVG_SAMPLES);
	changeResolution(analogResolution);
}
     a78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     a7c:	3dcccccf 	.word	0x3dcccccf
     a80:	3f666666 	.word	0x3f666666

00000a84 <CurrentSensor::sampleSensor()>:
	_rawCurrent = analogRead(_analogPin);
	return _rawCurrent;
}

//samples and filters the signal with running average filter
void CurrentSensor::sampleSensor(){
     a84:	b538      	push	{r3, r4, r5, lr}
     a86:	4604      	mov	r4, r0
	_minMesValue = (VOLTAGE_REFERENCE / 2 - SENSITIVITY * MAX_CURRENT) / VOLTAGE_REFERENCE * (float)maxAdcValue;
}

//update reads the raw current ADC value
uint16_t CurrentSensor::update(){
	_rawCurrent = analogRead(_analogPin);
     a88:	7800      	ldrb	r0, [r0, #0]
     a8a:	f001 f851 	bl	1b30 <analogRead>
//samples and filters the signal with running average filter
void CurrentSensor::sampleSensor(){
	//initial averaging is done in the ADC
	uint16_t rawCurrent = update();

	averageSum -= runningAvgBuffer[index];
     a8e:	f894 204d 	ldrb.w	r2, [r4, #77]	; 0x4d
     a92:	6d23      	ldr	r3, [r4, #80]	; 0x50
	_minMesValue = (VOLTAGE_REFERENCE / 2 - SENSITIVITY * MAX_CURRENT) / VOLTAGE_REFERENCE * (float)maxAdcValue;
}

//update reads the raw current ADC value
uint16_t CurrentSensor::update(){
	_rawCurrent = analogRead(_analogPin);
     a94:	b280      	uxth	r0, r0
     a96:	eb04 0142 	add.w	r1, r4, r2, lsl #1
     a9a:	f8a4 0054 	strh.w	r0, [r4, #84]	; 0x54
//samples and filters the signal with running average filter
void CurrentSensor::sampleSensor(){
	//initial averaging is done in the ADC
	uint16_t rawCurrent = update();

	averageSum -= runningAvgBuffer[index];
     a9e:	898d      	ldrh	r5, [r1, #12]
	runningAvgBuffer[index] = rawCurrent;
     aa0:	8188      	strh	r0, [r1, #12]
	averageSum += runningAvgBuffer[index];
	index++;
     aa2:	3201      	adds	r2, #1
     aa4:	b2d2      	uxtb	r2, r2
//samples and filters the signal with running average filter
void CurrentSensor::sampleSensor(){
	//initial averaging is done in the ADC
	uint16_t rawCurrent = update();

	averageSum -= runningAvgBuffer[index];
     aa6:	1b5b      	subs	r3, r3, r5
	runningAvgBuffer[index] = rawCurrent;
	averageSum += runningAvgBuffer[index];
     aa8:	4418      	add	r0, r3
	index++;
	if (index >= RUNNING_AVG_VALUES){
     aaa:	2a1f      	cmp	r2, #31
	//initial averaging is done in the ADC
	uint16_t rawCurrent = update();

	averageSum -= runningAvgBuffer[index];
	runningAvgBuffer[index] = rawCurrent;
	averageSum += runningAvgBuffer[index];
     aac:	6520      	str	r0, [r4, #80]	; 0x50
	index++;
     aae:	f884 204d 	strb.w	r2, [r4, #77]	; 0x4d
	if (index >= RUNNING_AVG_VALUES){
     ab2:	d909      	bls.n	ac8 <CurrentSensor::sampleSensor()+0x44>
		index = 0;
     ab4:	2200      	movs	r2, #0
		hasFilledUp = true;
     ab6:	2301      	movs	r3, #1
	averageSum -= runningAvgBuffer[index];
	runningAvgBuffer[index] = rawCurrent;
	averageSum += runningAvgBuffer[index];
	index++;
	if (index >= RUNNING_AVG_VALUES){
		index = 0;
     ab8:	f884 204d 	strb.w	r2, [r4, #77]	; 0x4d
		hasFilledUp = true;
     abc:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
	}

	//only uses the amount of values from the array that are already filled to compute the average, otherwise the result will be too low
	if (!hasFilledUp) _currentAverage = (uint16_t)(averageSum / index);
	else _currentAverage = (uint16_t)(averageSum / RUNNING_AVG_VALUES);
     ac0:	0940      	lsrs	r0, r0, #5
     ac2:	f8a4 0056 	strh.w	r0, [r4, #86]	; 0x56
     ac6:	bd38      	pop	{r3, r4, r5, pc}
		index = 0;
		hasFilledUp = true;
	}

	//only uses the amount of values from the array that are already filled to compute the average, otherwise the result will be too low
	if (!hasFilledUp) _currentAverage = (uint16_t)(averageSum / index);
     ac8:	f894 304c 	ldrb.w	r3, [r4, #76]	; 0x4c
     acc:	2b00      	cmp	r3, #0
     ace:	d1f7      	bne.n	ac0 <CurrentSensor::sampleSensor()+0x3c>
     ad0:	fbb0 f0f2 	udiv	r0, r0, r2
     ad4:	f8a4 0056 	strh.w	r0, [r4, #86]	; 0x56
     ad8:	bd38      	pop	{r3, r4, r5, pc}
     ada:	bf00      	nop
     adc:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

00000ae0 <CurrentSensor::getAverageCurrent()>:
//converts the raw current value from the ADC to a real current in A  --> ensures that the conversion is only ever done when really requested
float CurrentSensor::getCurrent(){
	return mapf(_rawCurrent, _minMesValue, _maxMesValue, -MAX_CURRENT, +MAX_CURRENT);
}

float CurrentSensor::getAverageCurrent(){
     ae0:	b510      	push	{r4, lr}
     ae2:	4604      	mov	r4, r0
     ae4:	b084      	sub	sp, #16
	return mapf(_currentAverage, _minMesValue, _maxMesValue, -MAX_CURRENT, +MAX_CURRENT);
     ae6:	6840      	ldr	r0, [r0, #4]
     ae8:	f004 fe48 	bl	577c <__aeabi_f2d>
     aec:	e9cd 0102 	strd	r0, r1, [sp, #8]
     af0:	68a0      	ldr	r0, [r4, #8]
     af2:	f004 fe43 	bl	577c <__aeabi_f2d>
     af6:	e9cd 0100 	strd	r0, r1, [sp]
     afa:	f8b4 0056 	ldrh.w	r0, [r4, #86]	; 0x56
     afe:	f004 fe1b 	bl	5738 <__aeabi_ui2d>
     b02:	ed9d 2b02 	vldr	d2, [sp, #8]
     b06:	ed9d 1b00 	vldr	d1, [sp]
     b0a:	ed9f 4b09 	vldr	d4, [pc, #36]	; b30 <CurrentSensor::getAverageCurrent()+0x50>
     b0e:	ed9f 3b0a 	vldr	d3, [pc, #40]	; b38 <CurrentSensor::getAverageCurrent()+0x58>
     b12:	ec41 0b10 	vmov	d0, r0, r1
     b16:	f000 f98d 	bl	e34 <mapf(double, double, double, double, double)>
     b1a:	ec51 0b10 	vmov	r0, r1, d0
     b1e:	f005 f979 	bl	5e14 <__aeabi_d2f>
}
     b22:	ee00 0a10 	vmov	s0, r0
     b26:	b004      	add	sp, #16
     b28:	bd10      	pop	{r4, pc}
     b2a:	bf00      	nop
     b2c:	f3af 8000 	nop.w
     b30:	00000000 	.word	0x00000000
     b34:	403e0000 	.word	0x403e0000
     b38:	00000000 	.word	0x00000000
     b3c:	c03e0000 	.word	0xc03e0000

00000b40 <DC_Motor::DC_Motor(unsigned char, unsigned char)>:
#include "DC_Motor.h"

DC_Motor::DC_Motor(uint8_t dirPin, uint8_t pwmPin){
     b40:	b510      	push	{r4, lr}
     b42:	4604      	mov	r4, r0
	_dirPin = dirPin;
	_pwmPin = pwmPin;
     b44:	7042      	strb	r2, [r0, #1]
#include "DC_Motor.h"

DC_Motor::DC_Motor(uint8_t dirPin, uint8_t pwmPin){
	_dirPin = dirPin;
     b46:	7001      	strb	r1, [r0, #0]
	_pwmPin = pwmPin;

	pinMode(_dirPin, OUTPUT);
     b48:	4608      	mov	r0, r1
     b4a:	2101      	movs	r1, #1
     b4c:	f001 fc74 	bl	2438 <pinMode>
	pinMode(_pwmPin, OUTPUT);
     b50:	7860      	ldrb	r0, [r4, #1]
     b52:	2101      	movs	r1, #1
     b54:	f001 fc70 	bl	2438 <pinMode>
}
     b58:	4620      	mov	r0, r4
     b5a:	bd10      	pop	{r4, pc}

00000b5c <DC_Motor::turn(unsigned short)>:
	_dir = dir;
	digitalWrite(_dirPin, _dir);
	analogWrite(_pwmPin, pwm);
}

void DC_Motor::turn(uint16_t pwm){
     b5c:	b538      	push	{r3, r4, r5, lr}
     b5e:	4604      	mov	r4, r0
     b60:	460d      	mov	r5, r1
	pinMode(_pwmPin, OUTPUT);
}

void DC_Motor::turn(bool dir, uint16_t pwm){
	_dir = dir;
	digitalWrite(_dirPin, _dir);
     b62:	7800      	ldrb	r0, [r0, #0]
     b64:	78a1      	ldrb	r1, [r4, #2]
     b66:	f001 fc61 	bl	242c <digitalWrite>
	analogWrite(_pwmPin, pwm);
     b6a:	4629      	mov	r1, r5
     b6c:	7860      	ldrb	r0, [r4, #1]
}

void DC_Motor::turn(uint16_t pwm){
	turn(_dir, pwm);
}
     b6e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
}

void DC_Motor::turn(bool dir, uint16_t pwm){
	_dir = dir;
	digitalWrite(_dirPin, _dir);
	analogWrite(_pwmPin, pwm);
     b72:	f001 ba05 	b.w	1f80 <analogWrite>
     b76:	bf00      	nop

00000b78 <DC_Motor::stop()>:
void DC_Motor::turn(uint16_t pwm){
	turn(_dir, pwm);
}

void DC_Motor::stop(){
	turn(0);
     b78:	2100      	movs	r1, #0
     b7a:	f7ff bfef 	b.w	b5c <DC_Motor::turn(unsigned short)>
     b7e:	bf00      	nop

00000b80 <DC_Motor::setDir(bool)>:
}

void DC_Motor::setDir(bool dir){
	_dir = dir;
     b80:	7081      	strb	r1, [r0, #2]
     b82:	4770      	bx	lr

00000b84 <QuadDecode<1>::zeroFTM()>:
void QuadDecode<N>::zeroFTM(void){

    // Turn off counter to disable interrupts and clear any 
    //   overflow and compare bits

    v_read=FTM_FMS;	// Requires reading before WPDIS can be set
     b84:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
     b86:	681b      	ldr	r3, [r3, #0]

// Initializies FTM for initialization or zero
//   Turn off counting, then no interrupts should be generated
//     and no Overflow bits set
template <int N>
void QuadDecode<N>::zeroFTM(void){
     b88:	b430      	push	{r4, r5}

    // Turn off counter to disable interrupts and clear any 
    //   overflow and compare bits

    v_read=FTM_FMS;	// Requires reading before WPDIS can be set
     b8a:	6603      	str	r3, [r0, #96]	; 0x60

    noInterrupts();
     b8c:	b672      	cpsid	i
    FTM_MODE=0x05;	// Write Protect Disable with FTMEN set
     b8e:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
    FTM_QDCTRL=0xC0;	// Disable QUADEN, filter still enabled
     b90:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    //   overflow and compare bits

    v_read=FTM_FMS;	// Requires reading before WPDIS can be set

    noInterrupts();
    FTM_MODE=0x05;	// Write Protect Disable with FTMEN set
     b92:	2405      	movs	r4, #5
    FTM_QDCTRL=0xC0;	// Disable QUADEN, filter still enabled
     b94:	22c0      	movs	r2, #192	; 0xc0
    //   overflow and compare bits

    v_read=FTM_FMS;	// Requires reading before WPDIS can be set

    noInterrupts();
    FTM_MODE=0x05;	// Write Protect Disable with FTMEN set
     b96:	600c      	str	r4, [r1, #0]
    FTM_QDCTRL=0xC0;	// Disable QUADEN, filter still enabled
     b98:	601a      	str	r2, [r3, #0]
                        //   Turns off counter so no interrupts
    interrupts();
     b9a:	b662      	cpsie	i

    FTM_CNT=0;
     b9c:	68c5      	ldr	r5, [r0, #12]
    v_read=FTM_SC;	// Need to read Overflow before it can be set
     b9e:	6844      	ldr	r4, [r0, #4]
    FTM_SC=0;		// Disable TOF interrupt, clear Overflow bit
    v_read=FTM_C0SC;	// Need to read Overflow before it can be set
     ba0:	69c3      	ldr	r3, [r0, #28]
   
    v_basePosn=0;
    v_initZeroTOF=true;	// Special case to determine direction 

    //v_prevInt=prevIntTOF;   // Value not used, remove code
    if (FTM_QDCTRL & QUADDIR){	//QuadDir says counting up
     ba2:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
    FTM_MODE=0x05;	// Write Protect Disable with FTMEN set
    FTM_QDCTRL=0xC0;	// Disable QUADEN, filter still enabled
                        //   Turns off counter so no interrupts
    interrupts();

    FTM_CNT=0;
     ba4:	2200      	movs	r2, #0
     ba6:	602a      	str	r2, [r5, #0]
    v_read=FTM_SC;	// Need to read Overflow before it can be set
     ba8:	6825      	ldr	r5, [r4, #0]
     baa:	6605      	str	r5, [r0, #96]	; 0x60
    FTM_SC=0;		// Disable TOF interrupt, clear Overflow bit
     bac:	6022      	str	r2, [r4, #0]
    v_read=FTM_C0SC;	// Need to read Overflow before it can be set
     bae:	681c      	ldr	r4, [r3, #0]
     bb0:	6604      	str	r4, [r0, #96]	; 0x60
    FTM_C0SC=0x10;	// Disable Channel compare int, clear compare bit
     bb2:	2510      	movs	r5, #16
			//   Leaves Mode bit for compare set

   
    v_basePosn=0;
    v_initZeroTOF=true;	// Special case to determine direction 
     bb4:	2401      	movs	r4, #1

    FTM_CNT=0;
    v_read=FTM_SC;	// Need to read Overflow before it can be set
    FTM_SC=0;		// Disable TOF interrupt, clear Overflow bit
    v_read=FTM_C0SC;	// Need to read Overflow before it can be set
    FTM_C0SC=0x10;	// Disable Channel compare int, clear compare bit
     bb6:	601d      	str	r5, [r3, #0]
			//   Leaves Mode bit for compare set

   
    v_basePosn=0;
     bb8:	6642      	str	r2, [r0, #100]	; 0x64
    v_initZeroTOF=true;	// Special case to determine direction 
     bba:	f880 4068 	strb.w	r4, [r0, #104]	; 0x68

    //v_prevInt=prevIntTOF;   // Value not used, remove code
    if (FTM_QDCTRL & QUADDIR){	//QuadDir says counting up
     bbe:	680a      	ldr	r2, [r1, #0]
     bc0:	f012 0f01 	tst.w	r2, #1
	FTM_C0V=COMP_LOW;	// Compare Interrupt Value
     bc4:	6a42      	ldr	r2, [r0, #36]	; 0x24
	FTM_C0V=COMP_HIGH;
    }

    // Enable counter again
    FTM_QDCTRL=0xC1;	// QUADEN
    FTM_FMS=0x40;  	// Write Protect, WPDIS=1
     bc6:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
    v_basePosn=0;
    v_initZeroTOF=true;	// Special case to determine direction 

    //v_prevInt=prevIntTOF;   // Value not used, remove code
    if (FTM_QDCTRL & QUADDIR){	//QuadDir says counting up
	FTM_C0V=COMP_LOW;	// Compare Interrupt Value
     bc8:	bf14      	ite	ne
     bca:	f44f 44c0 	movne.w	r4, #24576	; 0x6000
    } else {			//   according to last counting value
	FTM_C0V=COMP_HIGH;
     bce:	f44f 4420 	moveq.w	r4, #40960	; 0xa000
     bd2:	6014      	str	r4, [r2, #0]
    }

    // Enable counter again
    FTM_QDCTRL=0xC1;	// QUADEN
     bd4:	25c1      	movs	r5, #193	; 0xc1
    FTM_FMS=0x40;  	// Write Protect, WPDIS=1
     bd6:	2440      	movs	r4, #64	; 0x40
   
    //  Set channel interrupt
    FTM_C0SC=0x50;     // Enable Channel interrupt and Mode 
     bd8:	2250      	movs	r2, #80	; 0x50
    } else {			//   according to last counting value
	FTM_C0V=COMP_HIGH;
    }

    // Enable counter again
    FTM_QDCTRL=0xC1;	// QUADEN
     bda:	600d      	str	r5, [r1, #0]
    FTM_FMS=0x40;  	// Write Protect, WPDIS=1
     bdc:	6004      	str	r4, [r0, #0]
   
    //  Set channel interrupt
    FTM_C0SC=0x50;     // Enable Channel interrupt and Mode 
     bde:	601a      	str	r2, [r3, #0]

}
     be0:	bc30      	pop	{r4, r5}
     be2:	4770      	bx	lr

00000be4 <FE_ControlledDcMotor::zeroEncoder()>:
	_encoderSpeed = (int32_t)((float)(*(_input)-lastEncoderPos) / (float)(_sampleTime) * 1000000.0f);

	calculate();
}

void FE_ControlledDcMotor::zeroEncoder(){
     be4:	b508      	push	{r3, lr}
	_encoder.zeroFTM();
     be6:	3078      	adds	r0, #120	; 0x78
     be8:	f7ff ffcc 	bl	b84 <QuadDecode<1>::zeroFTM()>
     bec:	bd08      	pop	{r3, pc}
     bee:	bf00      	nop

00000bf0 <FE_ControlledDcMotor::FE_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)>:
#include "FE_ControlledDcMotor.h"

FE_ControlledDcMotor::FE_ControlledDcMotor(uint8_t motorDirPin, uint8_t motorPwmPin, double * input, double * output, double * setPoint, float Kp, float Ki, float Kd, const uint16_t intervall)
     bf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     bf4:	b085      	sub	sp, #20
void QuadDecode<N>::setup(){
    // Set up input pins
    if (N<2){	//FTM1
	// K20 pin 28,29
	// Bit 8-10 is Alt Assignment
	PORTA_PCR12 = 0x00000712;   //Alt7-QD_FTM1,FilterEnable,Pulldown
     bf6:	f8df a144 	ldr.w	sl, [pc, #324]	; d3c <FE_ControlledDcMotor::FE_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x14c>
     bfa:	9c0e      	ldr	r4, [sp, #56]	; 0x38
     bfc:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
     bfe:	f8bd 5040 	ldrh.w	r5, [sp, #64]	; 0x40
					: ControlledDcMotor(motorDirPin, motorPwmPin, input, output, setPoint, Kp, Ki, Kd, intervall){
     c02:	9400      	str	r4, [sp, #0]
     c04:	9601      	str	r6, [sp, #4]
     c06:	9502      	str	r5, [sp, #8]
#include "FE_ControlledDcMotor.h"

FE_ControlledDcMotor::FE_ControlledDcMotor(uint8_t motorDirPin, uint8_t motorPwmPin, double * input, double * output, double * setPoint, float Kp, float Ki, float Kd, const uint16_t intervall)
     c08:	4604      	mov	r4, r0
					: ControlledDcMotor(motorDirPin, motorPwmPin, input, output, setPoint, Kp, Ki, Kd, intervall){
     c0a:	4605      	mov	r5, r0
     c0c:	f7ff fe3c 	bl	888 <ControlledDcMotor::ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)>
	volatile prevInt_t v_prevInt;	
	volatile uint8_t v_intStatus;	// For interrupt routine debugging

    public:
	
	QuadDecode(){
     c10:	4842      	ldr	r0, [pc, #264]	; (d1c <FE_ControlledDcMotor::FE_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x12c>)
     c12:	4b43      	ldr	r3, [pc, #268]	; (d20 <FE_ControlledDcMotor::FE_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x130>)
     c14:	f845 3b78 	str.w	r3, [r5], #120
     c18:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
     c1c:	f8c4 009c 	str.w	r0, [r4, #156]	; 0x9c
     c20:	3054      	adds	r0, #84	; 0x54
     c22:	f8c4 00b8 	str.w	r0, [r4, #184]	; 0xb8
     c26:	f8c4 00bc 	str.w	r0, [r4, #188]	; 0xbc
     c2a:	3010      	adds	r0, #16
     c2c:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
     c30:	f8c4 00c4 	str.w	r0, [r4, #196]	; 0xc4
	    // Order of contstructor execution not guaranteed, 
	    //   start with start()
	    if (N<2){	// Point to this instance for ISR
		apQDcd1=reinterpret_cast<QuadDecode<1>*>(this);
     c34:	4b3b      	ldr	r3, [pc, #236]	; (d24 <FE_ControlledDcMotor::FE_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x134>)
	volatile prevInt_t v_prevInt;	
	volatile uint8_t v_intStatus;	// For interrupt routine debugging

    public:
	
	QuadDecode(){
     c36:	493c      	ldr	r1, [pc, #240]	; (d28 <FE_ControlledDcMotor::FE_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x138>)
     c38:	4a3c      	ldr	r2, [pc, #240]	; (d2c <FE_ControlledDcMotor::FE_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x13c>)
     c3a:	4e3d      	ldr	r6, [pc, #244]	; (d30 <FE_ControlledDcMotor::FE_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x140>)
     c3c:	f8df 8100 	ldr.w	r8, [pc, #256]	; d40 <FE_ControlledDcMotor::FE_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x150>
     c40:	f8df e100 	ldr.w	lr, [pc, #256]	; d44 <FE_ControlledDcMotor::FE_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x154>
     c44:	f8df c100 	ldr.w	ip, [pc, #256]	; d48 <FE_ControlledDcMotor::FE_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x158>
     c48:	4f3a      	ldr	r7, [pc, #232]	; (d34 <FE_ControlledDcMotor::FE_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x144>)
	PORTA_PCR13 = 0x00000712;   //Alt7-QD_FTM1,FilterEnable,Pulldown
     c4a:	f8df b100 	ldr.w	fp, [pc, #256]	; d4c <FE_ControlledDcMotor::FE_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x15c>
     c4e:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
     c52:	3004      	adds	r0, #4
     c54:	f8c4 00c8 	str.w	r0, [r4, #200]	; 0xc8
     c58:	f8c4 00cc 	str.w	r0, [r4, #204]	; 0xcc
void QuadDecode<N>::setup(){
    // Set up input pins
    if (N<2){	//FTM1
	// K20 pin 28,29
	// Bit 8-10 is Alt Assignment
	PORTA_PCR12 = 0x00000712;   //Alt7-QD_FTM1,FilterEnable,Pulldown
     c5c:	f240 7912 	movw	r9, #1810	; 0x712
     c60:	3008      	adds	r0, #8
     c62:	f8c4 2094 	str.w	r2, [r4, #148]	; 0x94
     c66:	f8c4 1080 	str.w	r1, [r4, #128]	; 0x80
     c6a:	f8c4 1084 	str.w	r1, [r4, #132]	; 0x84
	    // Order of contstructor execution not guaranteed, 
	    //   start with start()
	    if (N<2){	// Point to this instance for ISR
		apQDcd1=reinterpret_cast<QuadDecode<1>*>(this);
     c6e:	601d      	str	r5, [r3, #0]
	volatile prevInt_t v_prevInt;	
	volatile uint8_t v_intStatus;	// For interrupt routine debugging

    public:
	
	QuadDecode(){
     c70:	f8c4 e078 	str.w	lr, [r4, #120]	; 0x78
     c74:	f8c4 e07c 	str.w	lr, [r4, #124]	; 0x7c
     c78:	f8c4 c0a0 	str.w	ip, [r4, #160]	; 0xa0
     c7c:	f8c4 c0a4 	str.w	ip, [r4, #164]	; 0xa4
     c80:	f8c4 80b0 	str.w	r8, [r4, #176]	; 0xb0
     c84:	f8c4 80b4 	str.w	r8, [r4, #180]	; 0xb4
     c88:	f8c4 00d0 	str.w	r0, [r4, #208]	; 0xd0
     c8c:	f8c4 00d4 	str.w	r0, [r4, #212]	; 0xd4
     c90:	f8c4 6088 	str.w	r6, [r4, #136]	; 0x88
     c94:	f8c4 608c 	str.w	r6, [r4, #140]	; 0x8c
     c98:	f8c4 70a8 	str.w	r7, [r4, #168]	; 0xa8
     c9c:	f8c4 70ac 	str.w	r7, [r4, #172]	; 0xac
     ca0:	f8ca 9000 	str.w	r9, [sl]
	PORTB_PCR19 = 0x00000612;   //Alt6-QD_FTM2,FilterEnable,Pulldown
	//Default is input, don't need to write PDDR (Direction)
    };

    //Set FTMEN to be able to write registers
    FTM_MODE=0x04;	    // Write protect disable - reset value
     ca4:	f04f 0a04 	mov.w	sl, #4
    FTM_MODE=0x05;	    // Set FTM Enable

    // Set registers written in pins_teensy.c back to default
    FTM_CNT = 0;
     ca8:	2300      	movs	r3, #0
    // Set up input pins
    if (N<2){	//FTM1
	// K20 pin 28,29
	// Bit 8-10 is Alt Assignment
	PORTA_PCR12 = 0x00000712;   //Alt7-QD_FTM1,FilterEnable,Pulldown
	PORTA_PCR13 = 0x00000712;   //Alt7-QD_FTM1,FilterEnable,Pulldown
     caa:	f8cb 9000 	str.w	r9, [fp]
	PORTB_PCR19 = 0x00000612;   //Alt6-QD_FTM2,FilterEnable,Pulldown
	//Default is input, don't need to write PDDR (Direction)
    };

    //Set FTMEN to be able to write registers
    FTM_MODE=0x04;	    // Write protect disable - reset value
     cae:	f8c8 a000 	str.w	sl, [r8]
    FTM_MODE=0x05;	    // Set FTM Enable
     cb2:	f04f 0905 	mov.w	r9, #5
    FTM_C0SC =0;
    FTM_C1SC =0;
    FTM_SC = 0;

    // Set registers to count quadrature
    FTM_FILTER=0x22;	// 2x4 clock filters on both channels
     cb6:	f04f 0b22 	mov.w	fp, #34	; 0x22
    FTM_CNTIN=0;
    FTM_MOD=0xFFFF;	// Maximum value of counter
     cba:	f64f 7aff 	movw	sl, #65535	; 0xffff
	//Default is input, don't need to write PDDR (Direction)
    };

    //Set FTMEN to be able to write registers
    FTM_MODE=0x04;	    // Write protect disable - reset value
    FTM_MODE=0x05;	    // Set FTM Enable
     cbe:	f8c8 9000 	str.w	r9, [r8]

    // Set registers written in pins_teensy.c back to default
    FTM_CNT = 0;
     cc2:	600b      	str	r3, [r1, #0]
    FTM_MOD = 0;
     cc4:	6033      	str	r3, [r6, #0]
    FTM_C0SC =0;
     cc6:	6013      	str	r3, [r2, #0]
    FTM_C1SC =0;
     cc8:	f8cc 3000 	str.w	r3, [ip]
    FTM_SC = 0;
     ccc:	f8ce 3000 	str.w	r3, [lr]

    // Set registers to count quadrature
    FTM_FILTER=0x22;	// 2x4 clock filters on both channels
     cd0:	f840 bc08 	str.w	fp, [r0, #-8]
    FTM_CNTIN=0;
     cd4:	603b      	str	r3, [r7, #0]
    FTM_MOD=0xFFFF;	// Maximum value of counter
     cd6:	f8c6 a000 	str.w	sl, [r6]
    FTM_CNT=0;		// Updates counter with CNTIN
     cda:	600b      	str	r3, [r1, #0]

    // Set Registers for output compare mode
    FTM_COMBINE=0;	    // Reset value, make sure
     cdc:	660b      	str	r3, [r1, #96]	; 0x60
    FTM_C0SC=0x10;	    // Bit 4 Channel Mode
    FTM_C0V= COMP_LOW;	    // Initial Compare Interrupt Value
     cde:	4b0f      	ldr	r3, [pc, #60]	; (d1c <FE_ControlledDcMotor::FE_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x12c>)

    FTM_QDCTRL=0b11000001;	    // Quadrature control
     ce0:	f04f 0cc1 	mov.w	ip, #193	; 0xc1
    //        Filter enabled, QUADEN set
	    
    // Write Protect Enable
    FTM_FMS=0x40;		// Write Protect, WPDIS=1
     ce4:	f04f 0e40 	mov.w	lr, #64	; 0x40
    FTM_MOD=0xFFFF;	// Maximum value of counter
    FTM_CNT=0;		// Updates counter with CNTIN

    // Set Registers for output compare mode
    FTM_COMBINE=0;	    // Reset value, make sure
    FTM_C0SC=0x10;	    // Bit 4 Channel Mode
     ce8:	f04f 0910 	mov.w	r9, #16
    FTM_C0V= COMP_LOW;	    // Initial Compare Interrupt Value
     cec:	f44f 48c0 	mov.w	r8, #24576	; 0x6000
    FTM_MOD=0xFFFF;	// Maximum value of counter
    FTM_CNT=0;		// Updates counter with CNTIN

    // Set Registers for output compare mode
    FTM_COMBINE=0;	    // Reset value, make sure
    FTM_C0SC=0x10;	    // Bit 4 Channel Mode
     cf0:	f8c2 9000 	str.w	r9, [r2]

	_encoder.setup();
	_encoder.zeroFTM();
     cf4:	4628      	mov	r0, r5
    FTM_C0V= COMP_LOW;	    // Initial Compare Interrupt Value
     cf6:	f8c3 8000 	str.w	r8, [r3]

    FTM_QDCTRL=0b11000001;	    // Quadrature control
     cfa:	f8c3 c070 	str.w	ip, [r3, #112]	; 0x70
    //        Filter enabled, QUADEN set
	    
    // Write Protect Enable
    FTM_FMS=0x40;		// Write Protect, WPDIS=1
     cfe:	f8c3 e064 	str.w	lr, [r3, #100]	; 0x64
     d02:	f7ff ff3f 	bl	b84 <QuadDecode<1>::zeroFTM()>
};

//Enable interrupts and start counting
template <int N>
void QuadDecode<N>::start(){
    zeroFTM();	// Zero FTM counter
     d06:	4628      	mov	r0, r5
     d08:	f7ff ff3c 	bl	b84 <QuadDecode<1>::zeroFTM()>
    // Enable global FTMx interrupt
    // Assume global interrupts already enabled 
    //   No individual FTM sources enabled yet
	
    if (N<2){	//FTM1
	NVIC_ENABLE_IRQ(IRQ_FTM1);
     d0c:	4b0a      	ldr	r3, [pc, #40]	; (d38 <FE_ControlledDcMotor::FE_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x148>)
     d0e:	f44f 6200 	mov.w	r2, #2048	; 0x800
	_encoder.start();
}
     d12:	4620      	mov	r0, r4
     d14:	601a      	str	r2, [r3, #0]
     d16:	b005      	add	sp, #20
     d18:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     d1c:	40039010 	.word	0x40039010
     d20:	00006900 	.word	0x00006900
     d24:	1fff1608 	.word	0x1fff1608
     d28:	40039004 	.word	0x40039004
     d2c:	4003900c 	.word	0x4003900c
     d30:	40039008 	.word	0x40039008
     d34:	4003904c 	.word	0x4003904c
     d38:	e000e104 	.word	0xe000e104
     d3c:	40049030 	.word	0x40049030
     d40:	40039054 	.word	0x40039054
     d44:	40039000 	.word	0x40039000
     d48:	40039014 	.word	0x40039014
     d4c:	40049034 	.word	0x40049034

00000d50 <QuadDecode<1>::calcPosn()>:
    bool cpTOFDirUp;	// TOFDIR in QDCTRL (bit 1)
    int32_t cpBasePosn;
    int32_t currentPosn;
    bool dataConsistent;

    noInterrupts();	    // Variables can change if FTM interrrupt occurs
     d50:	b672      	cpsid	i
    if (!(FTM_SC & TOIE)){  // Check TOIE - TOF Interrupt disabled
     d52:	6843      	ldr	r3, [r0, #4]
     d54:	681a      	ldr	r2, [r3, #0]
     d56:	0652      	lsls	r2, r2, #25
     d58:	d417      	bmi.n	d8a <QuadDecode<1>::calcPosn()+0x3a>
	count16=FTM_CNT;    // Read current counter 
     d5a:	68c2      	ldr	r2, [r0, #12]
     d5c:	6812      	ldr	r2, [r2, #0]
     d5e:	b292      	uxth	r2, r2
	count32=count16;
	// TOF Interrupt disabled so no change to basePosn
	if (count16 < LOW_VALUE){
     d60:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
     d64:	d30d      	bcc.n	d82 <QuadDecode<1>::calcPosn()+0x32>
	    currentPosn=v_basePosn + count32;
	    interrupts();   // Turn interrupts back on before return
	    return currentPosn;
	}; 
	if ((count16 > HIGH_VALUE)){
     d66:	f5b2 4f40 	cmp.w	r2, #49152	; 0xc000
     d6a:	d822      	bhi.n	db2 <QuadDecode<1>::calcPosn()+0x62>
	    currentPosn=v_basePosn + count32 - NUM_64K;
	    interrupts();   // Turn interrupts back on before return
	    return currentPosn;
	}; 
        // Away from TOF, add or subtract depending on DIR last crossed TOF 
	if (v_initZeroTOF){	// No TOF since zero
     d6c:	f890 1068 	ldrb.w	r1, [r0, #104]	; 0x68
     d70:	b111      	cbz	r1, d78 <QuadDecode<1>::calcPosn()+0x28>
	    if (FTM_SC & TOF){  //TOF Set
     d72:	681b      	ldr	r3, [r3, #0]
     d74:	0619      	lsls	r1, r3, #24
     d76:	d504      	bpl.n	d82 <QuadDecode<1>::calcPosn()+0x32>
	    } else {
		cpTOFDirUp = true;	// Reversal will cause TOF
					//   so counting up
	    }
	}else{
	    cpTOFDirUp=FTM_QDCTRL & TOFDIR; // Away from TOF so stable
     d78:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
     d7a:	681b      	ldr	r3, [r3, #0]
     d7c:	f3c3 0340 	ubfx	r3, r3, #1, #1
	}
	// Use last TOFDIR to determine direction 
	if (cpTOFDirUp){
     d80:	b1bb      	cbz	r3, db2 <QuadDecode<1>::calcPosn()+0x62>
	    currentPosn=v_basePosn + count32;
     d82:	6e43      	ldr	r3, [r0, #100]	; 0x64
     d84:	1898      	adds	r0, r3, r2
	    interrupts();   // Turn interrupts back on before return
     d86:	b662      	cpsie	i
	    return currentPosn;
     d88:	4770      	bx	lr
	    interrupts();   // Turn interrupts back on before return
	    return currentPosn;
	};
    };
    // TOF Interrupt enabled
    interrupts();   // Allow TOF interrupt if pending
     d8a:	b662      	cpsie	i
    count16=FTM_CNT;    // Read current counter 
     d8c:	68c3      	ldr	r3, [r0, #12]
    count32=count16;
    cpBasePosn=v_basePosn;  // Unchanging copy
    dataConsistent=(FTM_SC & TOIE);  // Still TOIE, no TOF
     d8e:	6842      	ldr	r2, [r0, #4]
	    return currentPosn;
	};
    };
    // TOF Interrupt enabled
    interrupts();   // Allow TOF interrupt if pending
    count16=FTM_CNT;    // Read current counter 
     d90:	681b      	ldr	r3, [r3, #0]
    count32=count16;
    cpBasePosn=v_basePosn;  // Unchanging copy
     d92:	6e41      	ldr	r1, [r0, #100]	; 0x64
    dataConsistent=(FTM_SC & TOIE);  // Still TOIE, no TOF
     d94:	6812      	ldr	r2, [r2, #0]
    // prevTOFUp set in Compare int that turns on TOIE
    //   Compare Int could occur but prevTOFUp should remain the same
    if (dataConsistent){
     d96:	0652      	lsls	r2, r2, #25
     d98:	d505      	bpl.n	da6 <QuadDecode<1>::calcPosn()+0x56>
	// v_prevTOFUp changes in compare int, should be stable
	// Need to go thru compare int to set TOIE after zero
	if (v_prevTOFUp){	// Counting up
     d9a:	f890 2069 	ldrb.w	r2, [r0, #105]	; 0x69
     d9e:	b29b      	uxth	r3, r3
     da0:	b11a      	cbz	r2, daa <QuadDecode<1>::calcPosn()+0x5a>
	    currentPosn=cpBasePosn + count32;
     da2:	18c8      	adds	r0, r1, r3
     da4:	4770      	bx	lr
	} else {
	    currentPosn=cpBasePosn + count32 - NUM_64K;
	}
	return currentPosn;
    } else {	// Just crossed over TOF
	return v_basePosn;  // Position is new basePosition, no addtl counts
     da6:	6e40      	ldr	r0, [r0, #100]	; 0x64
     da8:	4770      	bx	lr
	// v_prevTOFUp changes in compare int, should be stable
	// Need to go thru compare int to set TOIE after zero
	if (v_prevTOFUp){	// Counting up
	    currentPosn=cpBasePosn + count32;
	} else {
	    currentPosn=cpBasePosn + count32 - NUM_64K;
     daa:	f5a1 3080 	sub.w	r0, r1, #65536	; 0x10000
     dae:	4418      	add	r0, r3
     db0:	4770      	bx	lr
	    currentPosn=v_basePosn + count32;
	    interrupts();   // Turn interrupts back on before return
	    return currentPosn;
	}; 
	if (!cpTOFDirUp){
	    currentPosn=v_basePosn + count32 - NUM_64K;
     db2:	6e43      	ldr	r3, [r0, #100]	; 0x64
     db4:	f5a3 3380 	sub.w	r3, r3, #65536	; 0x10000
     db8:	1898      	adds	r0, r3, r2
	    interrupts();   // Turn interrupts back on before return
     dba:	b662      	cpsie	i
	    return currentPosn;
     dbc:	4770      	bx	lr
     dbe:	bf00      	nop

00000dc0 <FE_ControlledDcMotor::handleMotorControl()>:

void FE_ControlledDcMotor::handleMotorControl(){
     dc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int32_t lastEncoderPos = *(_input);
     dc2:	6845      	ldr	r5, [r0, #4]
	_encoder.setup();
	_encoder.zeroFTM();
	_encoder.start();
}

void FE_ControlledDcMotor::handleMotorControl(){
     dc4:	4604      	mov	r4, r0
	int32_t lastEncoderPos = *(_input);
     dc6:	e9d5 0100 	ldrd	r0, r1, [r5]
     dca:	f004 ffdb 	bl	5d84 <__aeabi_d2iz>
     dce:	4607      	mov	r7, r0
	*(_input) = _encoder.calcPosn();
     dd0:	f104 0078 	add.w	r0, r4, #120	; 0x78
     dd4:	f7ff ffbc 	bl	d50 <QuadDecode<1>::calcPosn()>
     dd8:	f004 fcbe 	bl	5758 <__aeabi_i2d>

	//calculate speed in steps per second
	_encoderSpeed = (int32_t)((float)(*(_input)-lastEncoderPos) / (float)(_sampleTime) * 1000000.0f);
     ddc:	6866      	ldr	r6, [r4, #4]
	_encoder.start();
}

void FE_ControlledDcMotor::handleMotorControl(){
	int32_t lastEncoderPos = *(_input);
	*(_input) = _encoder.calcPosn();
     dde:	e9c5 0100 	strd	r0, r1, [r5]

	//calculate speed in steps per second
	_encoderSpeed = (int32_t)((float)(*(_input)-lastEncoderPos) / (float)(_sampleTime) * 1000000.0f);
     de2:	4638      	mov	r0, r7
     de4:	f004 fcb8 	bl	5758 <__aeabi_i2d>
     de8:	460b      	mov	r3, r1
     dea:	4602      	mov	r2, r0
     dec:	e9d6 0100 	ldrd	r0, r1, [r6]
     df0:	f004 fb64 	bl	54bc <__aeabi_dsub>
     df4:	f005 f80e 	bl	5e14 <__aeabi_d2f>
     df8:	7c23      	ldrb	r3, [r4, #16]
     dfa:	eddf 6a0a 	vldr	s13, [pc, #40]	; e24 <FE_ControlledDcMotor::handleMotorControl()+0x64>
     dfe:	ee07 3a10 	vmov	s14, r3
     e02:	ee06 0a10 	vmov	s12, r0
     e06:	eeb8 7a47 	vcvt.f32.u32	s14, s14

	calculate();
     e0a:	4620      	mov	r0, r4
void FE_ControlledDcMotor::handleMotorControl(){
	int32_t lastEncoderPos = *(_input);
	*(_input) = _encoder.calcPosn();

	//calculate speed in steps per second
	_encoderSpeed = (int32_t)((float)(*(_input)-lastEncoderPos) / (float)(_sampleTime) * 1000000.0f);
     e0c:	eec6 7a07 	vdiv.f32	s15, s12, s14
     e10:	ee67 7aa6 	vmul.f32	s15, s15, s13
     e14:	eefd 7ae7 	vcvt.s32.f32	s15, s15
     e18:	edc4 7a05 	vstr	s15, [r4, #20]

	calculate();
}
     e1c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	*(_input) = _encoder.calcPosn();

	//calculate speed in steps per second
	_encoderSpeed = (int32_t)((float)(*(_input)-lastEncoderPos) / (float)(_sampleTime) * 1000000.0f);

	calculate();
     e20:	f7ff bd92 	b.w	948 <ControlledDcMotor::calculate()>
     e24:	49742400 	.word	0x49742400

00000e28 <FE_ControlledDcMotor::getEncoderValue()>:

void FE_ControlledDcMotor::zeroEncoder(){
	_encoder.zeroFTM();
}

int32_t FE_ControlledDcMotor::getEncoderValue(){
     e28:	b508      	push	{r3, lr}
	return _encoder.calcPosn();
     e2a:	3078      	adds	r0, #120	; 0x78
     e2c:	f7ff ff90 	bl	d50 <QuadDecode<1>::calcPosn()>
}
     e30:	bd08      	pop	{r3, pc}
     e32:	bf00      	nop

00000e34 <mapf(double, double, double, double, double)>:
#include <math.h>

//Header file containing different helper functions

//https://gist.github.com/nadavmatalon/71ccaf154bc4bd71f811289e78c65918
double mapf(double val, double in_min, double in_max, double out_min, double out_max) {
     e34:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     e38:	ec57 6b11 	vmov	r6, r7, d1
     e3c:	b085      	sub	sp, #20
	return (val - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
     e3e:	ee11 2a10 	vmov	r2, s2
     e42:	ec51 0b10 	vmov	r0, r1, d0
     e46:	463b      	mov	r3, r7
#include <math.h>

//Header file containing different helper functions

//https://gist.github.com/nadavmatalon/71ccaf154bc4bd71f811289e78c65918
double mapf(double val, double in_min, double in_max, double out_min, double out_max) {
     e48:	ec55 4b13 	vmov	r4, r5, d3
     e4c:	ed8d 2b00 	vstr	d2, [sp]
     e50:	ed8d 4b02 	vstr	d4, [sp, #8]
	return (val - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
     e54:	f004 fb32 	bl	54bc <__aeabi_dsub>
     e58:	ed9d 4b02 	vldr	d4, [sp, #8]
     e5c:	4680      	mov	r8, r0
     e5e:	4689      	mov	r9, r1
     e60:	4622      	mov	r2, r4
     e62:	ec51 0b14 	vmov	r0, r1, d4
     e66:	462b      	mov	r3, r5
     e68:	f004 fb28 	bl	54bc <__aeabi_dsub>
     e6c:	4602      	mov	r2, r0
     e6e:	460b      	mov	r3, r1
     e70:	4640      	mov	r0, r8
     e72:	4649      	mov	r1, r9
     e74:	f004 fcd6 	bl	5824 <__aeabi_dmul>
     e78:	ed9d 2b00 	vldr	d2, [sp]
     e7c:	4680      	mov	r8, r0
     e7e:	4689      	mov	r9, r1
     e80:	4632      	mov	r2, r6
     e82:	ec51 0b12 	vmov	r0, r1, d2
     e86:	463b      	mov	r3, r7
     e88:	f004 fb18 	bl	54bc <__aeabi_dsub>
     e8c:	4602      	mov	r2, r0
     e8e:	460b      	mov	r3, r1
     e90:	4640      	mov	r0, r8
     e92:	4649      	mov	r1, r9
     e94:	f004 fdf0 	bl	5a78 <__aeabi_ddiv>
     e98:	4622      	mov	r2, r4
     e9a:	462b      	mov	r3, r5
     e9c:	f004 fb10 	bl	54c0 <__adddf3>
}
     ea0:	ec41 0b10 	vmov	d0, r0, r1
     ea4:	b005      	add	sp, #20
     ea6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     eaa:	bf00      	nop

00000eac <realmod(float, float)>:

float realmod(float x, float y){
     eac:	b500      	push	{lr}
     eae:	ed2d 8b02 	vpush	{d8}
	float result = fmod(x, y);
     eb2:	ee10 0a90 	vmov	r0, s1
//https://gist.github.com/nadavmatalon/71ccaf154bc4bd71f811289e78c65918
double mapf(double val, double in_min, double in_max, double out_min, double out_max) {
	return (val - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

float realmod(float x, float y){
     eb6:	b085      	sub	sp, #20
     eb8:	eeb0 8a60 	vmov.f32	s16, s1
     ebc:	ed8d 0a03 	vstr	s0, [sp, #12]
	float result = fmod(x, y);
     ec0:	f004 fc5c 	bl	577c <__aeabi_f2d>
     ec4:	ed9d 0a03 	vldr	s0, [sp, #12]
     ec8:	e9cd 0100 	strd	r0, r1, [sp]
     ecc:	ee10 0a10 	vmov	r0, s0
     ed0:	f004 fc54 	bl	577c <__aeabi_f2d>
     ed4:	ed9d 1b00 	vldr	d1, [sp]
     ed8:	ec41 0b10 	vmov	d0, r0, r1
     edc:	f003 fb50 	bl	4580 <fmod>
     ee0:	ec51 0b10 	vmov	r0, r1, d0
     ee4:	f004 ff96 	bl	5e14 <__aeabi_d2f>
     ee8:	ee00 0a10 	vmov	s0, r0
	return result >= 0 ? result : result + y;
     eec:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
     ef0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     ef4:	bfb8      	it	lt
     ef6:	ee38 0a00 	vaddlt.f32	s0, s16, s0
}
     efa:	b005      	add	sp, #20
     efc:	ecbd 8b02 	vpop	{d8}
     f00:	f85d fb04 	ldr.w	pc, [sp], #4

00000f04 <secToMicroSec(float)>:

uint32_t secToMicroSec(float sec){
	return (uint32_t)(sec * 1000000.0f);
     f04:	eddf 7a04 	vldr	s15, [pc, #16]	; f18 <secToMicroSec(float)+0x14>
     f08:	ee20 0a27 	vmul.f32	s0, s0, s15
}
     f0c:	eefc 7ac0 	vcvt.u32.f32	s15, s0
     f10:	ee17 0a90 	vmov	r0, s15
     f14:	4770      	bx	lr
     f16:	bf00      	nop
     f18:	49742400 	.word	0x49742400
     f1c:	ffffffff 	.word	0xffffffff

00000f20 <PID::SetTunings(double, double, double, int) [clone .part.0]>:
	lastInput = input;
	return true;
}


void PID::SetTunings(double Kp, double Ki, double Kd, int POn){
     f20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     f24:	990c      	ldr	r1, [sp, #48]	; 0x30
	if (Kp < 0 || Ki < 0 || Kd < 0) return;

	pOnE = POn ? P_ON_E : P_ON_M;
     f26:	3100      	adds	r1, #0
     f28:	bf18      	it	ne
     f2a:	2101      	movne	r1, #1
	lastInput = input;
	return true;
}


void PID::SetTunings(double Kp, double Ki, double Kd, int POn){
     f2c:	4682      	mov	sl, r0
	if (Kp < 0 || Ki < 0 || Kd < 0) return;

	pOnE = POn ? P_ON_E : P_ON_M;
     f2e:	7701      	strb	r1, [r0, #28]

	double SampleTimeInSec = ((double)SampleTime) / 1000000;
     f30:	6c00      	ldr	r0, [r0, #64]	; 0x40
	lastInput = input;
	return true;
}


void PID::SetTunings(double Kp, double Ki, double Kd, int POn){
     f32:	4690      	mov	r8, r2
     f34:	4699      	mov	r9, r3
	if (Kp < 0 || Ki < 0 || Kd < 0) return;

	pOnE = POn ? P_ON_E : P_ON_M;

	double SampleTimeInSec = ((double)SampleTime) / 1000000;
     f36:	f004 fbff 	bl	5738 <__aeabi_ui2d>
     f3a:	a31d      	add	r3, pc, #116	; (adr r3, fb0 <PID::SetTunings(double, double, double, int) [clone .part.0]+0x90>)
     f3c:	e9d3 2300 	ldrd	r2, r3, [r3]
     f40:	f004 fd9a 	bl	5a78 <__aeabi_ddiv>
	kp = Kp;
	ki = Ki * SampleTimeInSec;
     f44:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
	if (Kp < 0 || Ki < 0 || Kd < 0) return;

	pOnE = POn ? P_ON_E : P_ON_M;

	double SampleTimeInSec = ((double)SampleTime) / 1000000;
	kp = Kp;
     f48:	e9ca 8900 	strd	r8, r9, [sl]
void PID::SetTunings(double Kp, double Ki, double Kd, int POn){
	if (Kp < 0 || Ki < 0 || Kd < 0) return;

	pOnE = POn ? P_ON_E : P_ON_M;

	double SampleTimeInSec = ((double)SampleTime) / 1000000;
     f4c:	4604      	mov	r4, r0
     f4e:	460d      	mov	r5, r1
	kp = Kp;
	ki = Ki * SampleTimeInSec;
     f50:	f004 fc68 	bl	5824 <__aeabi_dmul>
     f54:	4606      	mov	r6, r0
     f56:	460f      	mov	r7, r1
	kd = Kd / SampleTimeInSec;
     f58:	462b      	mov	r3, r5
     f5a:	4622      	mov	r2, r4

	pOnE = POn ? P_ON_E : P_ON_M;

	double SampleTimeInSec = ((double)SampleTime) / 1000000;
	kp = Kp;
	ki = Ki * SampleTimeInSec;
     f5c:	e9ca 6702 	strd	r6, r7, [sl, #8]
	kd = Kd / SampleTimeInSec;
     f60:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
     f64:	f004 fd88 	bl	5a78 <__aeabi_ddiv>

	if (controllerDirection == REVERSE)
     f68:	f8da 3018 	ldr.w	r3, [sl, #24]
	pOnE = POn ? P_ON_E : P_ON_M;

	double SampleTimeInSec = ((double)SampleTime) / 1000000;
	kp = Kp;
	ki = Ki * SampleTimeInSec;
	kd = Kd / SampleTimeInSec;
     f6c:	4604      	mov	r4, r0
     f6e:	460d      	mov	r5, r1

	if (controllerDirection == REVERSE)
     f70:	2b01      	cmp	r3, #1
	pOnE = POn ? P_ON_E : P_ON_M;

	double SampleTimeInSec = ((double)SampleTime) / 1000000;
	kp = Kp;
	ki = Ki * SampleTimeInSec;
	kd = Kd / SampleTimeInSec;
     f72:	e9ca 4504 	strd	r4, r5, [sl, #16]

	if (controllerDirection == REVERSE)
     f76:	d117      	bne.n	fa8 <PID::SetTunings(double, double, double, int) [clone .part.0]+0x88>
	{
		kp = (0 - kp);
     f78:	4642      	mov	r2, r8
     f7a:	464b      	mov	r3, r9
     f7c:	2000      	movs	r0, #0
     f7e:	2100      	movs	r1, #0
     f80:	f004 fa9c 	bl	54bc <__aeabi_dsub>
		ki = (0 - ki);
     f84:	4632      	mov	r2, r6
	ki = Ki * SampleTimeInSec;
	kd = Kd / SampleTimeInSec;

	if (controllerDirection == REVERSE)
	{
		kp = (0 - kp);
     f86:	e9ca 0100 	strd	r0, r1, [sl]
		ki = (0 - ki);
     f8a:	463b      	mov	r3, r7
     f8c:	2000      	movs	r0, #0
     f8e:	2100      	movs	r1, #0
     f90:	f004 fa94 	bl	54bc <__aeabi_dsub>
		kd = (0 - kd);
     f94:	4622      	mov	r2, r4
	kd = Kd / SampleTimeInSec;

	if (controllerDirection == REVERSE)
	{
		kp = (0 - kp);
		ki = (0 - ki);
     f96:	e9ca 0102 	strd	r0, r1, [sl, #8]
		kd = (0 - kd);
     f9a:	462b      	mov	r3, r5
     f9c:	2000      	movs	r0, #0
     f9e:	2100      	movs	r1, #0
     fa0:	f004 fa8c 	bl	54bc <__aeabi_dsub>
     fa4:	e9ca 0104 	strd	r0, r1, [sl, #16]
     fa8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     fac:	f3af 8000 	nop.w
     fb0:	00000000 	.word	0x00000000
     fb4:	412e8480 	.word	0x412e8480

00000fb8 <PID::PID(double*, double*, double*, double, double, double, int, unsigned short)>:
	PID::SetControllerDirection(ControllerDirection);
	PID::SetTunings(Kp, Ki, Kd, POn);
}

//Defaults to proportional on error
PID::PID(double* Input, double* Output, double* Setpoint, double Kp, double Ki, double Kd, int ControllerDirection, uint16_t sampleTime)
     fb8:	e92d 4fd0 	stmdb	sp!, {r4, r6, r7, r8, r9, sl, fp, lr}
     fbc:	ed2d 8b04 	vpush	{d8-d9}
     fc0:	eeb0 8a41 	vmov.f32	s16, s2
     fc4:	eef0 8a61 	vmov.f32	s17, s3
     fc8:	eeb0 9a42 	vmov.f32	s18, s4
     fcc:	eef0 9a62 	vmov.f32	s19, s5
     fd0:	4604      	mov	r4, r0
     fd2:	b086      	sub	sp, #24


void PID::SetOutputLimits(double Min, double Max){
	if (Min >= Max) return;
	outMin = Min;
	outMax = Max;
     fd4:	f20f 0b78 	addw	fp, pc, #120	; 0x78
     fd8:	e9db ab00 	ldrd	sl, fp, [fp]
	PID::SetControllerDirection(ControllerDirection);
	PID::SetTunings(Kp, Ki, Kd, POn);
}

//Defaults to proportional on error
PID::PID(double* Input, double* Output, double* Setpoint, double Kp, double Ki, double Kd, int ControllerDirection, uint16_t sampleTime)
     fdc:	ec59 8b10 	vmov	r8, r9, d0

#include "PID_Controller.h"


PID::PID(double* Input, double* Output, double* Setpoint, double Kp, double Ki, double Kd, int POn, int ControllerDirection, uint16_t sampleTime){
	myOutput = Output;
     fe0:	6242      	str	r2, [r0, #36]	; 0x24
}


void PID::SetOutputLimits(double Min, double Max){
	if (Min >= Max) return;
	outMin = Min;
     fe2:	2600      	movs	r6, #0
     fe4:	2700      	movs	r7, #0

PID::PID(double* Input, double* Output, double* Setpoint, double Kp, double Ki, double Kd, int POn, int ControllerDirection, uint16_t sampleTime){
	myOutput = Output;
	myInput = Input;
	mySetpoint = Setpoint;
	inAuto = false;
     fe6:	2000      	movs	r0, #0
	PID::SetControllerDirection(ControllerDirection);
	PID::SetTunings(Kp, Ki, Kd, POn);
}

//Defaults to proportional on error
PID::PID(double* Input, double* Output, double* Setpoint, double Kp, double Ki, double Kd, int ControllerDirection, uint16_t sampleTime)
     fe8:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c


PID::PID(double* Input, double* Output, double* Setpoint, double Kp, double Ki, double Kd, int POn, int ControllerDirection, uint16_t sampleTime){
	myOutput = Output;
	myInput = Input;
	mySetpoint = Setpoint;
     fec:	62a3      	str	r3, [r4, #40]	; 0x28
	PID::SetControllerDirection(ControllerDirection);
	PID::SetTunings(Kp, Ki, Kd, POn);
}

//Defaults to proportional on error
PID::PID(double* Input, double* Output, double* Setpoint, double Kp, double Ki, double Kd, int ControllerDirection, uint16_t sampleTime)
     fee:	9b12      	ldr	r3, [sp, #72]	; 0x48
#include "PID_Controller.h"


PID::PID(double* Input, double* Output, double* Setpoint, double Kp, double Ki, double Kd, int POn, int ControllerDirection, uint16_t sampleTime){
	myOutput = Output;
	myInput = Input;
     ff0:	6221      	str	r1, [r4, #32]
	mySetpoint = Setpoint;
	inAuto = false;
     ff2:	7760      	strb	r0, [r4, #29]

	//default output limit corresponds to the pwm limits of the used microcontroller
	PID::SetOutputLimits(0, PWM_MAX_VALUE);

	SampleTime = sampleTime;
     ff4:	6422      	str	r2, [r4, #64]	; 0x40
	{
		kp = (0 - kp);
		ki = (0 - ki);
		kd = (0 - kd);
	}
	controllerDirection = Direction;
     ff6:	61a3      	str	r3, [r4, #24]


void PID::SetOutputLimits(double Min, double Max){
	if (Min >= Max) return;
	outMin = Min;
	outMax = Max;
     ff8:	e9c4 ab14 	strd	sl, fp, [r4, #80]	; 0x50
}


void PID::SetOutputLimits(double Min, double Max){
	if (Min >= Max) return;
	outMin = Min;
     ffc:	e9c4 6712 	strd	r6, r7, [r4, #72]	; 0x48
	return true;
}


void PID::SetTunings(double Kp, double Ki, double Kd, int POn){
	if (Kp < 0 || Ki < 0 || Kd < 0) return;
    1000:	4632      	mov	r2, r6
    1002:	463b      	mov	r3, r7
    1004:	ee10 0a10 	vmov	r0, s0
    1008:	4649      	mov	r1, r9
    100a:	f004 fe7d 	bl	5d08 <__aeabi_dcmplt>
    100e:	b9c0      	cbnz	r0, 1042 <PID::PID(double*, double*, double*, double, double, double, int, unsigned short)+0x8a>
    1010:	4632      	mov	r2, r6
    1012:	463b      	mov	r3, r7
    1014:	ec51 0b18 	vmov	r0, r1, d8
    1018:	f004 fe76 	bl	5d08 <__aeabi_dcmplt>
    101c:	b988      	cbnz	r0, 1042 <PID::PID(double*, double*, double*, double, double, double, int, unsigned short)+0x8a>
    101e:	4632      	mov	r2, r6
    1020:	463b      	mov	r3, r7
    1022:	ec51 0b19 	vmov	r0, r1, d9
    1026:	f004 fe6f 	bl	5d08 <__aeabi_dcmplt>
    102a:	b950      	cbnz	r0, 1042 <PID::PID(double*, double*, double*, double, double, double, int, unsigned short)+0x8a>
    102c:	2101      	movs	r1, #1
    102e:	ed8d 9b02 	vstr	d9, [sp, #8]
    1032:	ed8d 8b00 	vstr	d8, [sp]
    1036:	4642      	mov	r2, r8
    1038:	464b      	mov	r3, r9
    103a:	9104      	str	r1, [sp, #16]
    103c:	4620      	mov	r0, r4
    103e:	f7ff ff6f 	bl	f20 <PID::SetTunings(double, double, double, int) [clone .part.0]>
	PID::SetTunings(Kp, Ki, Kd, POn);
}

//Defaults to proportional on error
PID::PID(double* Input, double* Output, double* Setpoint, double Kp, double Ki, double Kd, int ControllerDirection, uint16_t sampleTime)
	:PID::PID(Input, Output, Setpoint, Kp, Ki, Kd, P_ON_E, ControllerDirection, sampleTime){}
    1042:	4620      	mov	r0, r4
    1044:	b006      	add	sp, #24
    1046:	ecbd 8b04 	vpop	{d8-d9}
    104a:	e8bd 8fd0 	ldmia.w	sp!, {r4, r6, r7, r8, r9, sl, fp, pc}
    104e:	bf00      	nop
    1050:	00000000 	.word	0x00000000
    1054:	40affe00 	.word	0x40affe00

00001058 <PID::Compute()>:


//Must be called with constant frequency matching the one specified in sample time
bool PID::Compute(){
    1058:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!inAuto) return false;
    105c:	7f45      	ldrb	r5, [r0, #29]
PID::PID(double* Input, double* Output, double* Setpoint, double Kp, double Ki, double Kd, int ControllerDirection, uint16_t sampleTime)
	:PID::PID(Input, Output, Setpoint, Kp, Ki, Kd, P_ON_E, ControllerDirection, sampleTime){}


//Must be called with constant frequency matching the one specified in sample time
bool PID::Compute(){
    105e:	b089      	sub	sp, #36	; 0x24
	if (!inAuto) return false;
    1060:	2d00      	cmp	r5, #0
    1062:	f000 8083 	beq.w	116c <PID::Compute()+0x114>

	/*Compute all the working error variables*/
	double input = *myInput;
    1066:	6a02      	ldr	r2, [r0, #32]
	double error = *mySetpoint - input;
    1068:	6a83      	ldr	r3, [r0, #40]	; 0x28
//Must be called with constant frequency matching the one specified in sample time
bool PID::Compute(){
	if (!inAuto) return false;

	/*Compute all the working error variables*/
	double input = *myInput;
    106a:	ed92 7b00 	vldr	d7, [r2]
	double error = *mySetpoint - input;
    106e:	ec59 8b17 	vmov	r8, r9, d7
    1072:	4604      	mov	r4, r0
    1074:	ee17 2a10 	vmov	r2, s14
    1078:	e9d3 0100 	ldrd	r0, r1, [r3]
    107c:	464b      	mov	r3, r9
//Must be called with constant frequency matching the one specified in sample time
bool PID::Compute(){
	if (!inAuto) return false;

	/*Compute all the working error variables*/
	double input = *myInput;
    107e:	ed8d 7b00 	vstr	d7, [sp]
	double error = *mySetpoint - input;
    1082:	f004 fa1b 	bl	54bc <__aeabi_dsub>
	double dInput = (input - lastInput);
    1086:	e9d4 230e 	ldrd	r2, r3, [r4, #56]	; 0x38
bool PID::Compute(){
	if (!inAuto) return false;

	/*Compute all the working error variables*/
	double input = *myInput;
	double error = *mySetpoint - input;
    108a:	4606      	mov	r6, r0
    108c:	460f      	mov	r7, r1
	double dInput = (input - lastInput);
    108e:	4640      	mov	r0, r8
    1090:	4649      	mov	r1, r9
bool PID::Compute(){
	if (!inAuto) return false;

	/*Compute all the working error variables*/
	double input = *myInput;
	double error = *mySetpoint - input;
    1092:	e9cd 6704 	strd	r6, r7, [sp, #16]
	double dInput = (input - lastInput);
    1096:	f004 fa11 	bl	54bc <__aeabi_dsub>
	outputSum += (ki * error);
    109a:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
	if (!inAuto) return false;

	/*Compute all the working error variables*/
	double input = *myInput;
	double error = *mySetpoint - input;
	double dInput = (input - lastInput);
    109e:	4681      	mov	r9, r0
    10a0:	468a      	mov	sl, r1
	outputSum += (ki * error);
    10a2:	4630      	mov	r0, r6
    10a4:	4639      	mov	r1, r7
	if (!inAuto) return false;

	/*Compute all the working error variables*/
	double input = *myInput;
	double error = *mySetpoint - input;
	double dInput = (input - lastInput);
    10a6:	e9cd 9a02 	strd	r9, sl, [sp, #8]
	outputSum += (ki * error);
    10aa:	f004 fbbb 	bl	5824 <__aeabi_dmul>
    10ae:	e9d4 230c 	ldrd	r2, r3, [r4, #48]	; 0x30
    10b2:	f004 fa05 	bl	54c0 <__adddf3>

	/*Add Proportional on Measurement, if P_ON_M is specified*/
	if (!pOnE) outputSum -= kp * dInput;
    10b6:	f894 801c 	ldrb.w	r8, [r4, #28]

	/*Compute all the working error variables*/
	double input = *myInput;
	double error = *mySetpoint - input;
	double dInput = (input - lastInput);
	outputSum += (ki * error);
    10ba:	4606      	mov	r6, r0
    10bc:	460f      	mov	r7, r1
    10be:	e9c4 670c 	strd	r6, r7, [r4, #48]	; 0x30

	/*Add Proportional on Measurement, if P_ON_M is specified*/
	if (!pOnE) outputSum -= kp * dInput;
    10c2:	f1b8 0f00 	cmp.w	r8, #0
    10c6:	d10f      	bne.n	10e8 <PID::Compute()+0x90>
    10c8:	e9d4 2300 	ldrd	r2, r3, [r4]
    10cc:	4648      	mov	r0, r9
    10ce:	4651      	mov	r1, sl
    10d0:	f004 fba8 	bl	5824 <__aeabi_dmul>
    10d4:	4602      	mov	r2, r0
    10d6:	460b      	mov	r3, r1
    10d8:	4630      	mov	r0, r6
    10da:	4639      	mov	r1, r7
    10dc:	f004 f9ee 	bl	54bc <__aeabi_dsub>
    10e0:	4606      	mov	r6, r0
    10e2:	460f      	mov	r7, r1
    10e4:	e9c4 670c 	strd	r6, r7, [r4, #48]	; 0x30

	if (outputSum > outMax) outputSum = outMax;
    10e8:	e9d4 ab14 	ldrd	sl, fp, [r4, #80]	; 0x50
    10ec:	4632      	mov	r2, r6
    10ee:	463b      	mov	r3, r7
    10f0:	4650      	mov	r0, sl
    10f2:	4659      	mov	r1, fp
    10f4:	f004 fe08 	bl	5d08 <__aeabi_dcmplt>
    10f8:	2800      	cmp	r0, #0
    10fa:	d03b      	beq.n	1174 <PID::Compute()+0x11c>
    10fc:	e9c4 ab0c 	strd	sl, fp, [r4, #48]	; 0x30
    1100:	4656      	mov	r6, sl
    1102:	465f      	mov	r7, fp
	else if (outputSum < outMin) outputSum = outMin;

	/*Add Proportional on Error, if P_ON_E is specified*/
	double output;
	if (pOnE) output = kp * error;
    1104:	f1b8 0f00 	cmp.w	r8, #0
    1108:	d049      	beq.n	119e <PID::Compute()+0x146>
    110a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    110e:	e9d4 2300 	ldrd	r2, r3, [r4]
    1112:	f004 fb87 	bl	5824 <__aeabi_dmul>
    1116:	4680      	mov	r8, r0
    1118:	4689      	mov	r9, r1
	else output = 0;

	/*Compute Rest of PID Output*/
	output += outputSum - kd * dInput;
    111a:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    111e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    1122:	f004 fb7f 	bl	5824 <__aeabi_dmul>
    1126:	4602      	mov	r2, r0
    1128:	460b      	mov	r3, r1
    112a:	4630      	mov	r0, r6
    112c:	4639      	mov	r1, r7
    112e:	f004 f9c5 	bl	54bc <__aeabi_dsub>
    1132:	4642      	mov	r2, r8
    1134:	464b      	mov	r3, r9
    1136:	f004 f9c3 	bl	54c0 <__adddf3>
    113a:	4606      	mov	r6, r0
    113c:	460f      	mov	r7, r1

	if (output > outMax) output = outMax;
    113e:	4602      	mov	r2, r0
    1140:	460b      	mov	r3, r1
    1142:	4650      	mov	r0, sl
    1144:	4659      	mov	r1, fp
    1146:	f004 fddf 	bl	5d08 <__aeabi_dcmplt>
    114a:	b940      	cbnz	r0, 115e <PID::Compute()+0x106>
	else if (output < outMin) output = outMin;
    114c:	e9d4 ab12 	ldrd	sl, fp, [r4, #72]	; 0x48
    1150:	4630      	mov	r0, r6
    1152:	4639      	mov	r1, r7
    1154:	4652      	mov	r2, sl
    1156:	465b      	mov	r3, fp
    1158:	f004 fdd6 	bl	5d08 <__aeabi_dcmplt>
    115c:	b320      	cbz	r0, 11a8 <PID::Compute()+0x150>
	*myOutput = output;

	/*Remember some variables for next time*/
	lastInput = input;
    115e:	ed9d 7b00 	vldr	d7, [sp]
	/*Compute Rest of PID Output*/
	output += outputSum - kd * dInput;

	if (output > outMax) output = outMax;
	else if (output < outMin) output = outMin;
	*myOutput = output;
    1162:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1164:	e9c3 ab00 	strd	sl, fp, [r3]

	/*Remember some variables for next time*/
	lastInput = input;
    1168:	ed84 7b0e 	vstr	d7, [r4, #56]	; 0x38
	return true;
}
    116c:	4628      	mov	r0, r5
    116e:	b009      	add	sp, #36	; 0x24
    1170:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

	/*Add Proportional on Measurement, if P_ON_M is specified*/
	if (!pOnE) outputSum -= kp * dInput;

	if (outputSum > outMax) outputSum = outMax;
	else if (outputSum < outMin) outputSum = outMin;
    1174:	ed94 7b12 	vldr	d7, [r4, #72]	; 0x48
    1178:	4632      	mov	r2, r6
    117a:	463b      	mov	r3, r7
    117c:	ec51 0b17 	vmov	r0, r1, d7
    1180:	ed8d 7b06 	vstr	d7, [sp, #24]
    1184:	f004 fdde 	bl	5d44 <__aeabi_dcmpgt>
    1188:	2800      	cmp	r0, #0
    118a:	d0bb      	beq.n	1104 <PID::Compute()+0xac>
    118c:	ed9d 7b06 	vldr	d7, [sp, #24]
    1190:	ed84 7b0c 	vstr	d7, [r4, #48]	; 0x30
    1194:	ec57 6b17 	vmov	r6, r7, d7

	/*Add Proportional on Error, if P_ON_E is specified*/
	double output;
	if (pOnE) output = kp * error;
    1198:	f1b8 0f00 	cmp.w	r8, #0
    119c:	d1b5      	bne.n	110a <PID::Compute()+0xb2>
	else output = 0;
    119e:	f04f 0800 	mov.w	r8, #0
    11a2:	f04f 0900 	mov.w	r9, #0
    11a6:	e7b8      	b.n	111a <PID::Compute()+0xc2>

	/*Compute Rest of PID Output*/
	output += outputSum - kd * dInput;
    11a8:	46b2      	mov	sl, r6
    11aa:	46bb      	mov	fp, r7
    11ac:	e7d7      	b.n	115e <PID::Compute()+0x106>
    11ae:	bf00      	nop

000011b0 <PID::SetOutputLimits(double, double)>:
	kd /= ratio;
	SampleTime = (unsigned long)NewSampleTime;
}


void PID::SetOutputLimits(double Min, double Max){
    11b0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    11b4:	ec57 6b10 	vmov	r6, r7, d0
    11b8:	ec55 4b11 	vmov	r4, r5, d1
    11bc:	4682      	mov	sl, r0
	if (Min >= Max) return;
    11be:	ee11 2a10 	vmov	r2, s2
    11c2:	462b      	mov	r3, r5
    11c4:	ee10 0a10 	vmov	r0, s0
    11c8:	4639      	mov	r1, r7
    11ca:	f004 fdb1 	bl	5d30 <__aeabi_dcmpge>
    11ce:	2800      	cmp	r0, #0
    11d0:	d130      	bne.n	1234 <PID::SetOutputLimits(double, double)+0x84>
	outMin = Min;
	outMax = Max;

	//limit output when in auto mode and already past new limits
	if (inAuto){
    11d2:	f89a 301d 	ldrb.w	r3, [sl, #29]
}


void PID::SetOutputLimits(double Min, double Max){
	if (Min >= Max) return;
	outMin = Min;
    11d6:	e9ca 6712 	strd	r6, r7, [sl, #72]	; 0x48
	outMax = Max;
    11da:	e9ca 4514 	strd	r4, r5, [sl, #80]	; 0x50

	//limit output when in auto mode and already past new limits
	if (inAuto){
    11de:	b34b      	cbz	r3, 1234 <PID::SetOutputLimits(double, double)+0x84>
		if (*myOutput > outMax) *myOutput = outMax;
    11e0:	f8da b024 	ldr.w	fp, [sl, #36]	; 0x24
    11e4:	e9db 8900 	ldrd	r8, r9, [fp]
    11e8:	4620      	mov	r0, r4
    11ea:	4629      	mov	r1, r5
    11ec:	4642      	mov	r2, r8
    11ee:	464b      	mov	r3, r9
    11f0:	f004 fd8a 	bl	5d08 <__aeabi_dcmplt>
    11f4:	bb00      	cbnz	r0, 1238 <PID::SetOutputLimits(double, double)+0x88>
		else if (*myOutput < outMin) *myOutput = outMin;
    11f6:	4642      	mov	r2, r8
    11f8:	464b      	mov	r3, r9
    11fa:	4630      	mov	r0, r6
    11fc:	4639      	mov	r1, r7
    11fe:	f004 fda1 	bl	5d44 <__aeabi_dcmpgt>
    1202:	b118      	cbz	r0, 120c <PID::SetOutputLimits(double, double)+0x5c>
    1204:	e9cb 6700 	strd	r6, r7, [fp]
    1208:	e9da 4514 	ldrd	r4, r5, [sl, #80]	; 0x50

		if (outputSum > outMax) outputSum = outMax;
    120c:	e9da 670c 	ldrd	r6, r7, [sl, #48]	; 0x30
    1210:	4622      	mov	r2, r4
    1212:	462b      	mov	r3, r5
    1214:	4630      	mov	r0, r6
    1216:	4639      	mov	r1, r7
    1218:	f004 fd94 	bl	5d44 <__aeabi_dcmpgt>
    121c:	b940      	cbnz	r0, 1230 <PID::SetOutputLimits(double, double)+0x80>
		else if (outputSum < outMin) outputSum = outMin;
    121e:	e9da 4512 	ldrd	r4, r5, [sl, #72]	; 0x48
    1222:	4630      	mov	r0, r6
    1224:	4639      	mov	r1, r7
    1226:	4622      	mov	r2, r4
    1228:	462b      	mov	r3, r5
    122a:	f004 fd6d 	bl	5d08 <__aeabi_dcmplt>
    122e:	b108      	cbz	r0, 1234 <PID::SetOutputLimits(double, double)+0x84>
    1230:	e9ca 450c 	strd	r4, r5, [sl, #48]	; 0x30
    1234:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	outMin = Min;
	outMax = Max;

	//limit output when in auto mode and already past new limits
	if (inAuto){
		if (*myOutput > outMax) *myOutput = outMax;
    1238:	e9cb 4500 	strd	r4, r5, [fp]
    123c:	e9da 4514 	ldrd	r4, r5, [sl, #80]	; 0x50
    1240:	e7e4      	b.n	120c <PID::SetOutputLimits(double, double)+0x5c>
    1242:	bf00      	nop

00001244 <PID::SetMode(int)>:
	}
}

//Manual (0) or Automatic (non zero) --> handles transition from manual to auto automatically
void PID::SetMode(int Mode){
	bool newAuto = (Mode == AUTOMATIC);
    1244:	2901      	cmp	r1, #1
		else if (outputSum < outMin) outputSum = outMin;
	}
}

//Manual (0) or Automatic (non zero) --> handles transition from manual to auto automatically
void PID::SetMode(int Mode){
    1246:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    124a:	4604      	mov	r4, r0
	bool newAuto = (Mode == AUTOMATIC);
    124c:	bf0c      	ite	eq
    124e:	2501      	moveq	r5, #1
    1250:	2500      	movne	r5, #0

	if (newAuto && !inAuto){
    1252:	d002      	beq.n	125a <PID::SetMode(int)+0x16>
		//we just went from manual to auto
		PID::Initialize();
	}
	inAuto = newAuto;
    1254:	7765      	strb	r5, [r4, #29]
    1256:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

//Manual (0) or Automatic (non zero) --> handles transition from manual to auto automatically
void PID::SetMode(int Mode){
	bool newAuto = (Mode == AUTOMATIC);

	if (newAuto && !inAuto){
    125a:	7f43      	ldrb	r3, [r0, #29]
    125c:	2b00      	cmp	r3, #0
    125e:	d1f9      	bne.n	1254 <PID::SetMode(int)+0x10>
	}
	inAuto = newAuto;
}
//Allows transfer from manual to automatic
void PID::Initialize(){
	outputSum = *myOutput;
    1260:	6a42      	ldr	r2, [r0, #36]	; 0x24
	lastInput = *myInput;
    1262:	6a03      	ldr	r3, [r0, #32]
	}
	inAuto = newAuto;
}
//Allows transfer from manual to automatic
void PID::Initialize(){
	outputSum = *myOutput;
    1264:	e9d2 6700 	ldrd	r6, r7, [r2]
    1268:	e9c0 670c 	strd	r6, r7, [r0, #48]	; 0x30
	lastInput = *myInput;
	if (outputSum > outMax) outputSum = outMax;
    126c:	e9d0 8914 	ldrd	r8, r9, [r0, #80]	; 0x50
	inAuto = newAuto;
}
//Allows transfer from manual to automatic
void PID::Initialize(){
	outputSum = *myOutput;
	lastInput = *myInput;
    1270:	e9d3 2300 	ldrd	r2, r3, [r3]
	if (outputSum > outMax) outputSum = outMax;
    1274:	4630      	mov	r0, r6
	inAuto = newAuto;
}
//Allows transfer from manual to automatic
void PID::Initialize(){
	outputSum = *myOutput;
	lastInput = *myInput;
    1276:	e9c4 230e 	strd	r2, r3, [r4, #56]	; 0x38
	if (outputSum > outMax) outputSum = outMax;
    127a:	4639      	mov	r1, r7
    127c:	4642      	mov	r2, r8
    127e:	464b      	mov	r3, r9
    1280:	f004 fd60 	bl	5d44 <__aeabi_dcmpgt>
    1284:	b948      	cbnz	r0, 129a <PID::SetMode(int)+0x56>
	else if (outputSum < outMin) outputSum = outMin;
    1286:	e9d4 8912 	ldrd	r8, r9, [r4, #72]	; 0x48
    128a:	4630      	mov	r0, r6
    128c:	4639      	mov	r1, r7
    128e:	4642      	mov	r2, r8
    1290:	464b      	mov	r3, r9
    1292:	f004 fd39 	bl	5d08 <__aeabi_dcmplt>
    1296:	2800      	cmp	r0, #0
    1298:	d0dc      	beq.n	1254 <PID::SetMode(int)+0x10>
    129a:	e9c4 890c 	strd	r8, r9, [r4, #48]	; 0x30

	if (newAuto && !inAuto){
		//we just went from manual to auto
		PID::Initialize();
	}
	inAuto = newAuto;
    129e:	7765      	strb	r5, [r4, #29]
    12a0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000012a4 <QuadDecode<2>::zeroFTM()>:
void QuadDecode<N>::zeroFTM(void){

    // Turn off counter to disable interrupts and clear any 
    //   overflow and compare bits

    v_read=FTM_FMS;	// Requires reading before WPDIS can be set
    12a4:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    12a6:	681b      	ldr	r3, [r3, #0]

// Initializies FTM for initialization or zero
//   Turn off counting, then no interrupts should be generated
//     and no Overflow bits set
template <int N>
void QuadDecode<N>::zeroFTM(void){
    12a8:	b430      	push	{r4, r5}

    // Turn off counter to disable interrupts and clear any 
    //   overflow and compare bits

    v_read=FTM_FMS;	// Requires reading before WPDIS can be set
    12aa:	6603      	str	r3, [r0, #96]	; 0x60

    noInterrupts();
    12ac:	b672      	cpsid	i
    FTM_MODE=0x05;	// Write Protect Disable with FTMEN set
    12ae:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
    FTM_QDCTRL=0xC0;	// Disable QUADEN, filter still enabled
    12b0:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    //   overflow and compare bits

    v_read=FTM_FMS;	// Requires reading before WPDIS can be set

    noInterrupts();
    FTM_MODE=0x05;	// Write Protect Disable with FTMEN set
    12b2:	2405      	movs	r4, #5
    FTM_QDCTRL=0xC0;	// Disable QUADEN, filter still enabled
    12b4:	22c0      	movs	r2, #192	; 0xc0
    //   overflow and compare bits

    v_read=FTM_FMS;	// Requires reading before WPDIS can be set

    noInterrupts();
    FTM_MODE=0x05;	// Write Protect Disable with FTMEN set
    12b6:	600c      	str	r4, [r1, #0]
    FTM_QDCTRL=0xC0;	// Disable QUADEN, filter still enabled
    12b8:	601a      	str	r2, [r3, #0]
                        //   Turns off counter so no interrupts
    interrupts();
    12ba:	b662      	cpsie	i

    FTM_CNT=0;
    12bc:	68c5      	ldr	r5, [r0, #12]
    v_read=FTM_SC;	// Need to read Overflow before it can be set
    12be:	6844      	ldr	r4, [r0, #4]
    FTM_SC=0;		// Disable TOF interrupt, clear Overflow bit
    v_read=FTM_C0SC;	// Need to read Overflow before it can be set
    12c0:	69c3      	ldr	r3, [r0, #28]
   
    v_basePosn=0;
    v_initZeroTOF=true;	// Special case to determine direction 

    //v_prevInt=prevIntTOF;   // Value not used, remove code
    if (FTM_QDCTRL & QUADDIR){	//QuadDir says counting up
    12c2:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
    FTM_MODE=0x05;	// Write Protect Disable with FTMEN set
    FTM_QDCTRL=0xC0;	// Disable QUADEN, filter still enabled
                        //   Turns off counter so no interrupts
    interrupts();

    FTM_CNT=0;
    12c4:	2200      	movs	r2, #0
    12c6:	602a      	str	r2, [r5, #0]
    v_read=FTM_SC;	// Need to read Overflow before it can be set
    12c8:	6825      	ldr	r5, [r4, #0]
    12ca:	6605      	str	r5, [r0, #96]	; 0x60
    FTM_SC=0;		// Disable TOF interrupt, clear Overflow bit
    12cc:	6022      	str	r2, [r4, #0]
    v_read=FTM_C0SC;	// Need to read Overflow before it can be set
    12ce:	681c      	ldr	r4, [r3, #0]
    12d0:	6604      	str	r4, [r0, #96]	; 0x60
    FTM_C0SC=0x10;	// Disable Channel compare int, clear compare bit
    12d2:	2510      	movs	r5, #16
			//   Leaves Mode bit for compare set

   
    v_basePosn=0;
    v_initZeroTOF=true;	// Special case to determine direction 
    12d4:	2401      	movs	r4, #1

    FTM_CNT=0;
    v_read=FTM_SC;	// Need to read Overflow before it can be set
    FTM_SC=0;		// Disable TOF interrupt, clear Overflow bit
    v_read=FTM_C0SC;	// Need to read Overflow before it can be set
    FTM_C0SC=0x10;	// Disable Channel compare int, clear compare bit
    12d6:	601d      	str	r5, [r3, #0]
			//   Leaves Mode bit for compare set

   
    v_basePosn=0;
    12d8:	6642      	str	r2, [r0, #100]	; 0x64
    v_initZeroTOF=true;	// Special case to determine direction 
    12da:	f880 4068 	strb.w	r4, [r0, #104]	; 0x68

    //v_prevInt=prevIntTOF;   // Value not used, remove code
    if (FTM_QDCTRL & QUADDIR){	//QuadDir says counting up
    12de:	680a      	ldr	r2, [r1, #0]
    12e0:	f012 0f01 	tst.w	r2, #1
	FTM_C0V=COMP_LOW;	// Compare Interrupt Value
    12e4:	6a42      	ldr	r2, [r0, #36]	; 0x24
	FTM_C0V=COMP_HIGH;
    }

    // Enable counter again
    FTM_QDCTRL=0xC1;	// QUADEN
    FTM_FMS=0x40;  	// Write Protect, WPDIS=1
    12e6:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
    v_basePosn=0;
    v_initZeroTOF=true;	// Special case to determine direction 

    //v_prevInt=prevIntTOF;   // Value not used, remove code
    if (FTM_QDCTRL & QUADDIR){	//QuadDir says counting up
	FTM_C0V=COMP_LOW;	// Compare Interrupt Value
    12e8:	bf14      	ite	ne
    12ea:	f44f 44c0 	movne.w	r4, #24576	; 0x6000
    } else {			//   according to last counting value
	FTM_C0V=COMP_HIGH;
    12ee:	f44f 4420 	moveq.w	r4, #40960	; 0xa000
    12f2:	6014      	str	r4, [r2, #0]
    }

    // Enable counter again
    FTM_QDCTRL=0xC1;	// QUADEN
    12f4:	25c1      	movs	r5, #193	; 0xc1
    FTM_FMS=0x40;  	// Write Protect, WPDIS=1
    12f6:	2440      	movs	r4, #64	; 0x40
   
    //  Set channel interrupt
    FTM_C0SC=0x50;     // Enable Channel interrupt and Mode 
    12f8:	2250      	movs	r2, #80	; 0x50
    } else {			//   according to last counting value
	FTM_C0V=COMP_HIGH;
    }

    // Enable counter again
    FTM_QDCTRL=0xC1;	// QUADEN
    12fa:	600d      	str	r5, [r1, #0]
    FTM_FMS=0x40;  	// Write Protect, WPDIS=1
    12fc:	6004      	str	r4, [r0, #0]
   
    //  Set channel interrupt
    FTM_C0SC=0x50;     // Enable Channel interrupt and Mode 
    12fe:	601a      	str	r2, [r3, #0]

}
    1300:	bc30      	pop	{r4, r5}
    1302:	4770      	bx	lr

00001304 <PS_ControlledDcMotor::zeroEncoder()>:
	_encoderSpeed = (int32_t)((float)(*(_input)-lastEncoderPos) / (float)(_sampleTime) * 1000000.0f);

	calculate();
}

void PS_ControlledDcMotor::zeroEncoder(){
    1304:	b508      	push	{r3, lr}
	_encoder.zeroFTM();
    1306:	3078      	adds	r0, #120	; 0x78
    1308:	f7ff ffcc 	bl	12a4 <QuadDecode<2>::zeroFTM()>
    130c:	bd08      	pop	{r3, pc}
    130e:	bf00      	nop

00001310 <PS_ControlledDcMotor::PS_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)>:
#include "PS_ControlledDcMotor.h"

PS_ControlledDcMotor::PS_ControlledDcMotor(uint8_t motorDirPin, uint8_t motorPwmPin, double * input, double * output, double * setPoint, float Kp, float Ki, float Kd, const uint16_t intervall)
    1310:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1314:	b085      	sub	sp, #20
	//Default is input, don't need to write PDDR (Direction)

    }else{  // FTM2
	// K20 pin 41,42
	// Bit 8-10 is Alt Assignment
	PORTB_PCR18 = 0x00000612;   //Alt6-QD_FTM2,FilterEnable,Pulldown
    1316:	f8df a144 	ldr.w	sl, [pc, #324]	; 145c <PS_ControlledDcMotor::PS_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x14c>
    131a:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    131c:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
    131e:	f8bd 5040 	ldrh.w	r5, [sp, #64]	; 0x40
					: ControlledDcMotor(motorDirPin, motorPwmPin, input, output, setPoint, Kp, Ki, Kd, intervall){
    1322:	9400      	str	r4, [sp, #0]
    1324:	9601      	str	r6, [sp, #4]
    1326:	9502      	str	r5, [sp, #8]
#include "PS_ControlledDcMotor.h"

PS_ControlledDcMotor::PS_ControlledDcMotor(uint8_t motorDirPin, uint8_t motorPwmPin, double * input, double * output, double * setPoint, float Kp, float Ki, float Kd, const uint16_t intervall)
    1328:	4604      	mov	r4, r0
					: ControlledDcMotor(motorDirPin, motorPwmPin, input, output, setPoint, Kp, Ki, Kd, intervall){
    132a:	4605      	mov	r5, r0
    132c:	f7ff faac 	bl	888 <ControlledDcMotor::ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)>
    1330:	4842      	ldr	r0, [pc, #264]	; (143c <PS_ControlledDcMotor::PS_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x12c>)
    1332:	4b43      	ldr	r3, [pc, #268]	; (1440 <PS_ControlledDcMotor::PS_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x130>)
    1334:	f845 3b78 	str.w	r3, [r5], #120
    1338:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
    133c:	f8c4 009c 	str.w	r0, [r4, #156]	; 0x9c
    1340:	3054      	adds	r0, #84	; 0x54
    1342:	f8c4 00b8 	str.w	r0, [r4, #184]	; 0xb8
    1346:	f8c4 00bc 	str.w	r0, [r4, #188]	; 0xbc
    134a:	3010      	adds	r0, #16
    134c:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
    1350:	f8c4 00c4 	str.w	r0, [r4, #196]	; 0xc4
		apQDcd1=reinterpret_cast<QuadDecode<1>*>(this);
		// Without reintepret_cast compiler complains about unused 
		//   case.  Pointer for unused case not used, so don't
		//   care what it is.  Used case casts to existing type.
	    }else{
		apQDcd2=reinterpret_cast<QuadDecode<2>*>(this);
    1354:	4b3b      	ldr	r3, [pc, #236]	; (1444 <PS_ControlledDcMotor::PS_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x134>)
	volatile prevInt_t v_prevInt;	
	volatile uint8_t v_intStatus;	// For interrupt routine debugging

    public:
	
	QuadDecode(){
    1356:	493c      	ldr	r1, [pc, #240]	; (1448 <PS_ControlledDcMotor::PS_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x138>)
    1358:	4a3c      	ldr	r2, [pc, #240]	; (144c <PS_ControlledDcMotor::PS_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x13c>)
    135a:	4e3d      	ldr	r6, [pc, #244]	; (1450 <PS_ControlledDcMotor::PS_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x140>)
    135c:	f8df 8100 	ldr.w	r8, [pc, #256]	; 1460 <PS_ControlledDcMotor::PS_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x150>
    1360:	f8df e100 	ldr.w	lr, [pc, #256]	; 1464 <PS_ControlledDcMotor::PS_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x154>
    1364:	f8df c100 	ldr.w	ip, [pc, #256]	; 1468 <PS_ControlledDcMotor::PS_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x158>
    1368:	4f3a      	ldr	r7, [pc, #232]	; (1454 <PS_ControlledDcMotor::PS_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x144>)
	PORTB_PCR19 = 0x00000612;   //Alt6-QD_FTM2,FilterEnable,Pulldown
    136a:	f8df b100 	ldr.w	fp, [pc, #256]	; 146c <PS_ControlledDcMotor::PS_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x15c>
    136e:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
    1372:	3004      	adds	r0, #4
    1374:	f8c4 00c8 	str.w	r0, [r4, #200]	; 0xc8
    1378:	f8c4 00cc 	str.w	r0, [r4, #204]	; 0xcc
	//Default is input, don't need to write PDDR (Direction)

    }else{  // FTM2
	// K20 pin 41,42
	// Bit 8-10 is Alt Assignment
	PORTB_PCR18 = 0x00000612;   //Alt6-QD_FTM2,FilterEnable,Pulldown
    137c:	f240 6912 	movw	r9, #1554	; 0x612
    1380:	3008      	adds	r0, #8
    1382:	f8c4 2094 	str.w	r2, [r4, #148]	; 0x94
    1386:	f8c4 1080 	str.w	r1, [r4, #128]	; 0x80
    138a:	f8c4 1084 	str.w	r1, [r4, #132]	; 0x84
		apQDcd1=reinterpret_cast<QuadDecode<1>*>(this);
		// Without reintepret_cast compiler complains about unused 
		//   case.  Pointer for unused case not used, so don't
		//   care what it is.  Used case casts to existing type.
	    }else{
		apQDcd2=reinterpret_cast<QuadDecode<2>*>(this);
    138e:	601d      	str	r5, [r3, #0]
	volatile prevInt_t v_prevInt;	
	volatile uint8_t v_intStatus;	// For interrupt routine debugging

    public:
	
	QuadDecode(){
    1390:	f8c4 e078 	str.w	lr, [r4, #120]	; 0x78
    1394:	f8c4 e07c 	str.w	lr, [r4, #124]	; 0x7c
    1398:	f8c4 c0a0 	str.w	ip, [r4, #160]	; 0xa0
    139c:	f8c4 c0a4 	str.w	ip, [r4, #164]	; 0xa4
    13a0:	f8c4 80b0 	str.w	r8, [r4, #176]	; 0xb0
    13a4:	f8c4 80b4 	str.w	r8, [r4, #180]	; 0xb4
    13a8:	f8c4 00d0 	str.w	r0, [r4, #208]	; 0xd0
    13ac:	f8c4 00d4 	str.w	r0, [r4, #212]	; 0xd4
    13b0:	f8c4 6088 	str.w	r6, [r4, #136]	; 0x88
    13b4:	f8c4 608c 	str.w	r6, [r4, #140]	; 0x8c
    13b8:	f8c4 70a8 	str.w	r7, [r4, #168]	; 0xa8
    13bc:	f8c4 70ac 	str.w	r7, [r4, #172]	; 0xac
    13c0:	f8ca 9000 	str.w	r9, [sl]
	PORTB_PCR19 = 0x00000612;   //Alt6-QD_FTM2,FilterEnable,Pulldown
	//Default is input, don't need to write PDDR (Direction)
    };

    //Set FTMEN to be able to write registers
    FTM_MODE=0x04;	    // Write protect disable - reset value
    13c4:	f04f 0a04 	mov.w	sl, #4
    FTM_MODE=0x05;	    // Set FTM Enable

    // Set registers written in pins_teensy.c back to default
    FTM_CNT = 0;
    13c8:	2300      	movs	r3, #0

    }else{  // FTM2
	// K20 pin 41,42
	// Bit 8-10 is Alt Assignment
	PORTB_PCR18 = 0x00000612;   //Alt6-QD_FTM2,FilterEnable,Pulldown
	PORTB_PCR19 = 0x00000612;   //Alt6-QD_FTM2,FilterEnable,Pulldown
    13ca:	f8cb 9000 	str.w	r9, [fp]
	//Default is input, don't need to write PDDR (Direction)
    };

    //Set FTMEN to be able to write registers
    FTM_MODE=0x04;	    // Write protect disable - reset value
    13ce:	f8c8 a000 	str.w	sl, [r8]
    FTM_MODE=0x05;	    // Set FTM Enable
    13d2:	f04f 0905 	mov.w	r9, #5
    FTM_C0SC =0;
    FTM_C1SC =0;
    FTM_SC = 0;

    // Set registers to count quadrature
    FTM_FILTER=0x22;	// 2x4 clock filters on both channels
    13d6:	f04f 0b22 	mov.w	fp, #34	; 0x22
    FTM_CNTIN=0;
    FTM_MOD=0xFFFF;	// Maximum value of counter
    13da:	f64f 7aff 	movw	sl, #65535	; 0xffff
	//Default is input, don't need to write PDDR (Direction)
    };

    //Set FTMEN to be able to write registers
    FTM_MODE=0x04;	    // Write protect disable - reset value
    FTM_MODE=0x05;	    // Set FTM Enable
    13de:	f8c8 9000 	str.w	r9, [r8]

    // Set registers written in pins_teensy.c back to default
    FTM_CNT = 0;
    13e2:	600b      	str	r3, [r1, #0]
    FTM_MOD = 0;
    13e4:	6033      	str	r3, [r6, #0]
    FTM_C0SC =0;
    13e6:	6013      	str	r3, [r2, #0]
    FTM_C1SC =0;
    13e8:	f8cc 3000 	str.w	r3, [ip]
    FTM_SC = 0;
    13ec:	f8ce 3000 	str.w	r3, [lr]

    // Set registers to count quadrature
    FTM_FILTER=0x22;	// 2x4 clock filters on both channels
    13f0:	f840 bc08 	str.w	fp, [r0, #-8]
    FTM_CNTIN=0;
    13f4:	603b      	str	r3, [r7, #0]
    FTM_MOD=0xFFFF;	// Maximum value of counter
    13f6:	f8c6 a000 	str.w	sl, [r6]
    FTM_CNT=0;		// Updates counter with CNTIN
    13fa:	600b      	str	r3, [r1, #0]

    // Set Registers for output compare mode
    FTM_COMBINE=0;	    // Reset value, make sure
    13fc:	660b      	str	r3, [r1, #96]	; 0x60
    FTM_C0SC=0x10;	    // Bit 4 Channel Mode
    FTM_C0V= COMP_LOW;	    // Initial Compare Interrupt Value
    13fe:	4b0f      	ldr	r3, [pc, #60]	; (143c <PS_ControlledDcMotor::PS_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x12c>)

    FTM_QDCTRL=0b11000001;	    // Quadrature control
    1400:	f04f 0cc1 	mov.w	ip, #193	; 0xc1
    //        Filter enabled, QUADEN set
	    
    // Write Protect Enable
    FTM_FMS=0x40;		// Write Protect, WPDIS=1
    1404:	f04f 0e40 	mov.w	lr, #64	; 0x40
    FTM_MOD=0xFFFF;	// Maximum value of counter
    FTM_CNT=0;		// Updates counter with CNTIN

    // Set Registers for output compare mode
    FTM_COMBINE=0;	    // Reset value, make sure
    FTM_C0SC=0x10;	    // Bit 4 Channel Mode
    1408:	f04f 0910 	mov.w	r9, #16
    FTM_C0V= COMP_LOW;	    // Initial Compare Interrupt Value
    140c:	f44f 48c0 	mov.w	r8, #24576	; 0x6000
    FTM_MOD=0xFFFF;	// Maximum value of counter
    FTM_CNT=0;		// Updates counter with CNTIN

    // Set Registers for output compare mode
    FTM_COMBINE=0;	    // Reset value, make sure
    FTM_C0SC=0x10;	    // Bit 4 Channel Mode
    1410:	f8c2 9000 	str.w	r9, [r2]

	_encoder.setup();
	_encoder.zeroFTM();
    1414:	4628      	mov	r0, r5
    FTM_C0V= COMP_LOW;	    // Initial Compare Interrupt Value
    1416:	f8c3 8000 	str.w	r8, [r3]

    FTM_QDCTRL=0b11000001;	    // Quadrature control
    141a:	f8c3 c070 	str.w	ip, [r3, #112]	; 0x70
    //        Filter enabled, QUADEN set
	    
    // Write Protect Enable
    FTM_FMS=0x40;		// Write Protect, WPDIS=1
    141e:	f8c3 e064 	str.w	lr, [r3, #100]	; 0x64
    1422:	f7ff ff3f 	bl	12a4 <QuadDecode<2>::zeroFTM()>
};

//Enable interrupts and start counting
template <int N>
void QuadDecode<N>::start(){
    zeroFTM();	// Zero FTM counter
    1426:	4628      	mov	r0, r5
    1428:	f7ff ff3c 	bl	12a4 <QuadDecode<2>::zeroFTM()>
    //   No individual FTM sources enabled yet
	
    if (N<2){	//FTM1
	NVIC_ENABLE_IRQ(IRQ_FTM1);
    } else {
	NVIC_ENABLE_IRQ(IRQ_FTM2);
    142c:	4b0a      	ldr	r3, [pc, #40]	; (1458 <PS_ControlledDcMotor::PS_ControlledDcMotor(unsigned char, unsigned char, double*, double*, double*, float, float, float, unsigned short)+0x148>)
    142e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
	_encoder.start();
}
    1432:	4620      	mov	r0, r4
    1434:	601a      	str	r2, [r3, #0]
    1436:	b005      	add	sp, #20
    1438:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    143c:	400b8010 	.word	0x400b8010
    1440:	00006914 	.word	0x00006914
    1444:	1fff160c 	.word	0x1fff160c
    1448:	400b8004 	.word	0x400b8004
    144c:	400b800c 	.word	0x400b800c
    1450:	400b8008 	.word	0x400b8008
    1454:	400b804c 	.word	0x400b804c
    1458:	e000e104 	.word	0xe000e104
    145c:	4004a048 	.word	0x4004a048
    1460:	400b8054 	.word	0x400b8054
    1464:	400b8000 	.word	0x400b8000
    1468:	400b8014 	.word	0x400b8014
    146c:	4004a04c 	.word	0x4004a04c

00001470 <QuadDecode<2>::calcPosn()>:
    bool cpTOFDirUp;	// TOFDIR in QDCTRL (bit 1)
    int32_t cpBasePosn;
    int32_t currentPosn;
    bool dataConsistent;

    noInterrupts();	    // Variables can change if FTM interrrupt occurs
    1470:	b672      	cpsid	i
    if (!(FTM_SC & TOIE)){  // Check TOIE - TOF Interrupt disabled
    1472:	6843      	ldr	r3, [r0, #4]
    1474:	681a      	ldr	r2, [r3, #0]
    1476:	0652      	lsls	r2, r2, #25
    1478:	d417      	bmi.n	14aa <QuadDecode<2>::calcPosn()+0x3a>
	count16=FTM_CNT;    // Read current counter 
    147a:	68c2      	ldr	r2, [r0, #12]
    147c:	6812      	ldr	r2, [r2, #0]
    147e:	b292      	uxth	r2, r2
	count32=count16;
	// TOF Interrupt disabled so no change to basePosn
	if (count16 < LOW_VALUE){
    1480:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
    1484:	d30d      	bcc.n	14a2 <QuadDecode<2>::calcPosn()+0x32>
	    currentPosn=v_basePosn + count32;
	    interrupts();   // Turn interrupts back on before return
	    return currentPosn;
	}; 
	if ((count16 > HIGH_VALUE)){
    1486:	f5b2 4f40 	cmp.w	r2, #49152	; 0xc000
    148a:	d822      	bhi.n	14d2 <QuadDecode<2>::calcPosn()+0x62>
	    currentPosn=v_basePosn + count32 - NUM_64K;
	    interrupts();   // Turn interrupts back on before return
	    return currentPosn;
	}; 
        // Away from TOF, add or subtract depending on DIR last crossed TOF 
	if (v_initZeroTOF){	// No TOF since zero
    148c:	f890 1068 	ldrb.w	r1, [r0, #104]	; 0x68
    1490:	b111      	cbz	r1, 1498 <QuadDecode<2>::calcPosn()+0x28>
	    if (FTM_SC & TOF){  //TOF Set
    1492:	681b      	ldr	r3, [r3, #0]
    1494:	0619      	lsls	r1, r3, #24
    1496:	d504      	bpl.n	14a2 <QuadDecode<2>::calcPosn()+0x32>
	    } else {
		cpTOFDirUp = true;	// Reversal will cause TOF
					//   so counting up
	    }
	}else{
	    cpTOFDirUp=FTM_QDCTRL & TOFDIR; // Away from TOF so stable
    1498:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    149a:	681b      	ldr	r3, [r3, #0]
    149c:	f3c3 0340 	ubfx	r3, r3, #1, #1
	}
	// Use last TOFDIR to determine direction 
	if (cpTOFDirUp){
    14a0:	b1bb      	cbz	r3, 14d2 <QuadDecode<2>::calcPosn()+0x62>
	    currentPosn=v_basePosn + count32;
    14a2:	6e43      	ldr	r3, [r0, #100]	; 0x64
    14a4:	1898      	adds	r0, r3, r2
	    interrupts();   // Turn interrupts back on before return
    14a6:	b662      	cpsie	i
	    return currentPosn;
    14a8:	4770      	bx	lr
	    interrupts();   // Turn interrupts back on before return
	    return currentPosn;
	};
    };
    // TOF Interrupt enabled
    interrupts();   // Allow TOF interrupt if pending
    14aa:	b662      	cpsie	i
    count16=FTM_CNT;    // Read current counter 
    14ac:	68c3      	ldr	r3, [r0, #12]
    count32=count16;
    cpBasePosn=v_basePosn;  // Unchanging copy
    dataConsistent=(FTM_SC & TOIE);  // Still TOIE, no TOF
    14ae:	6842      	ldr	r2, [r0, #4]
	    return currentPosn;
	};
    };
    // TOF Interrupt enabled
    interrupts();   // Allow TOF interrupt if pending
    count16=FTM_CNT;    // Read current counter 
    14b0:	681b      	ldr	r3, [r3, #0]
    count32=count16;
    cpBasePosn=v_basePosn;  // Unchanging copy
    14b2:	6e41      	ldr	r1, [r0, #100]	; 0x64
    dataConsistent=(FTM_SC & TOIE);  // Still TOIE, no TOF
    14b4:	6812      	ldr	r2, [r2, #0]
    // prevTOFUp set in Compare int that turns on TOIE
    //   Compare Int could occur but prevTOFUp should remain the same
    if (dataConsistent){
    14b6:	0652      	lsls	r2, r2, #25
    14b8:	d505      	bpl.n	14c6 <QuadDecode<2>::calcPosn()+0x56>
	// v_prevTOFUp changes in compare int, should be stable
	// Need to go thru compare int to set TOIE after zero
	if (v_prevTOFUp){	// Counting up
    14ba:	f890 2069 	ldrb.w	r2, [r0, #105]	; 0x69
    14be:	b29b      	uxth	r3, r3
    14c0:	b11a      	cbz	r2, 14ca <QuadDecode<2>::calcPosn()+0x5a>
	    currentPosn=cpBasePosn + count32;
    14c2:	18c8      	adds	r0, r1, r3
    14c4:	4770      	bx	lr
	} else {
	    currentPosn=cpBasePosn + count32 - NUM_64K;
	}
	return currentPosn;
    } else {	// Just crossed over TOF
	return v_basePosn;  // Position is new basePosition, no addtl counts
    14c6:	6e40      	ldr	r0, [r0, #100]	; 0x64
    14c8:	4770      	bx	lr
	// v_prevTOFUp changes in compare int, should be stable
	// Need to go thru compare int to set TOIE after zero
	if (v_prevTOFUp){	// Counting up
	    currentPosn=cpBasePosn + count32;
	} else {
	    currentPosn=cpBasePosn + count32 - NUM_64K;
    14ca:	f5a1 3080 	sub.w	r0, r1, #65536	; 0x10000
    14ce:	4418      	add	r0, r3
    14d0:	4770      	bx	lr
	    currentPosn=v_basePosn + count32;
	    interrupts();   // Turn interrupts back on before return
	    return currentPosn;
	}; 
	if (!cpTOFDirUp){
	    currentPosn=v_basePosn + count32 - NUM_64K;
    14d2:	6e43      	ldr	r3, [r0, #100]	; 0x64
    14d4:	f5a3 3380 	sub.w	r3, r3, #65536	; 0x10000
    14d8:	1898      	adds	r0, r3, r2
	    interrupts();   // Turn interrupts back on before return
    14da:	b662      	cpsie	i
	    return currentPosn;
    14dc:	4770      	bx	lr
    14de:	bf00      	nop

000014e0 <PS_ControlledDcMotor::handleMotorControl()>:

void PS_ControlledDcMotor::handleMotorControl(){
    14e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int32_t lastEncoderPos = *(_input);
    14e2:	6845      	ldr	r5, [r0, #4]
	_encoder.setup();
	_encoder.zeroFTM();
	_encoder.start();
}

void PS_ControlledDcMotor::handleMotorControl(){
    14e4:	4604      	mov	r4, r0
	int32_t lastEncoderPos = *(_input);
    14e6:	e9d5 0100 	ldrd	r0, r1, [r5]
    14ea:	f004 fc4b 	bl	5d84 <__aeabi_d2iz>
    14ee:	4607      	mov	r7, r0
	*(_input) = _encoder.calcPosn();
    14f0:	f104 0078 	add.w	r0, r4, #120	; 0x78
    14f4:	f7ff ffbc 	bl	1470 <QuadDecode<2>::calcPosn()>
    14f8:	f004 f92e 	bl	5758 <__aeabi_i2d>

	//calculate speed in steps per second
	_encoderSpeed = (int32_t)((float)(*(_input)-lastEncoderPos) / (float)(_sampleTime) * 1000000.0f);
    14fc:	6866      	ldr	r6, [r4, #4]
	_encoder.start();
}

void PS_ControlledDcMotor::handleMotorControl(){
	int32_t lastEncoderPos = *(_input);
	*(_input) = _encoder.calcPosn();
    14fe:	e9c5 0100 	strd	r0, r1, [r5]

	//calculate speed in steps per second
	_encoderSpeed = (int32_t)((float)(*(_input)-lastEncoderPos) / (float)(_sampleTime) * 1000000.0f);
    1502:	4638      	mov	r0, r7
    1504:	f004 f928 	bl	5758 <__aeabi_i2d>
    1508:	460b      	mov	r3, r1
    150a:	4602      	mov	r2, r0
    150c:	e9d6 0100 	ldrd	r0, r1, [r6]
    1510:	f003 ffd4 	bl	54bc <__aeabi_dsub>
    1514:	f004 fc7e 	bl	5e14 <__aeabi_d2f>
    1518:	7c23      	ldrb	r3, [r4, #16]
    151a:	eddf 6a0a 	vldr	s13, [pc, #40]	; 1544 <PS_ControlledDcMotor::handleMotorControl()+0x64>
    151e:	ee07 3a10 	vmov	s14, r3
    1522:	ee06 0a10 	vmov	s12, r0
    1526:	eeb8 7a47 	vcvt.f32.u32	s14, s14

	calculate();
    152a:	4620      	mov	r0, r4
void PS_ControlledDcMotor::handleMotorControl(){
	int32_t lastEncoderPos = *(_input);
	*(_input) = _encoder.calcPosn();

	//calculate speed in steps per second
	_encoderSpeed = (int32_t)((float)(*(_input)-lastEncoderPos) / (float)(_sampleTime) * 1000000.0f);
    152c:	eec6 7a07 	vdiv.f32	s15, s12, s14
    1530:	ee67 7aa6 	vmul.f32	s15, s15, s13
    1534:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    1538:	edc4 7a05 	vstr	s15, [r4, #20]

	calculate();
}
    153c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	*(_input) = _encoder.calcPosn();

	//calculate speed in steps per second
	_encoderSpeed = (int32_t)((float)(*(_input)-lastEncoderPos) / (float)(_sampleTime) * 1000000.0f);

	calculate();
    1540:	f7ff ba02 	b.w	948 <ControlledDcMotor::calculate()>
    1544:	49742400 	.word	0x49742400

00001548 <PS_ControlledDcMotor::getEncoderValue()>:

void PS_ControlledDcMotor::zeroEncoder(){
	_encoder.zeroFTM();
}

int32_t PS_ControlledDcMotor::getEncoderValue(){
    1548:	b508      	push	{r3, lr}
	return _encoder.calcPosn();
    154a:	3078      	adds	r0, #120	; 0x78
    154c:	f7ff ff90 	bl	1470 <QuadDecode<2>::calcPosn()>
}
    1550:	bd08      	pop	{r3, pc}
    1552:	bf00      	nop

00001554 <ftm1_isr>:
QuadDecode<1> *apQDcd1;	    // Pointers to  correct instance for ISR
QuadDecode<2> *apQDcd2;


void ftm1_isr(void){
    apQDcd1->ftm_isr();
    1554:	4b3a      	ldr	r3, [pc, #232]	; (1640 <ftm1_isr+0xec>)
    1556:	681b      	ldr	r3, [r3, #0]
 
template <int N>
void QuadDecode<N>::ftm_isr(void){
    
    //First determine which interrupt enabled
    if(FTM_SC == (TOF|TOIE)){	// TOIE and TOF set, TOF interrupt
    1558:	685a      	ldr	r2, [r3, #4]
    155a:	6811      	ldr	r1, [r2, #0]
    155c:	29c0      	cmp	r1, #192	; 0xc0

QuadDecode<1> *apQDcd1;	    // Pointers to  correct instance for ISR
QuadDecode<2> *apQDcd2;


void ftm1_isr(void){
    155e:	b430      	push	{r4, r5}
    1560:	d02f      	beq.n	15c2 <ftm1_isr+0x6e>
		v_basePosn-=NUM_64K;
	    }
	}   // Previous and current direction not the same
	    //   indicate reversal, basePosn remains same
    }else { // Channel Compare Int
	v_intStatus=2;
    1562:	2102      	movs	r1, #2
    1564:	f883 106b 	strb.w	r1, [r3, #107]	; 0x6b
	if (v_initZeroTOF){	// No TOF since zero
    1568:	f893 1068 	ldrb.w	r1, [r3, #104]	; 0x68
    156c:	b141      	cbz	r1, 1580 <ftm1_isr+0x2c>
	    if (FTM_SC & TOF){  //TOF Set
    156e:	6811      	ldr	r1, [r2, #0]
    1570:	0609      	lsls	r1, r1, #24
		v_initZeroTOF=false;	// TOF occured, TOFDIR valid
    1572:	bf4b      	itete	mi
    1574:	2100      	movmi	r1, #0
	    } else {
		v_prevTOFUp = true;	// Reversal will cause TOF
    1576:	2101      	movpl	r1, #1
	    //   indicate reversal, basePosn remains same
    }else { // Channel Compare Int
	v_intStatus=2;
	if (v_initZeroTOF){	// No TOF since zero
	    if (FTM_SC & TOF){  //TOF Set
		v_initZeroTOF=false;	// TOF occured, TOFDIR valid
    1578:	f883 1068 	strbmi.w	r1, [r3, #104]	; 0x68
	    } else {
		v_prevTOFUp = true;	// Reversal will cause TOF
    157c:	f883 1069 	strbpl.w	r1, [r3, #105]	; 0x69
					//   so counting up
	    }
	}
	if (!v_initZeroTOF){	// TOFDIR valid
    1580:	f893 1068 	ldrb.w	r1, [r3, #104]	; 0x68
    1584:	b1b1      	cbz	r1, 15b4 <ftm1_isr+0x60>
	    v_prevTOFUp=FTM_QDCTRL & TOFDIR;	// Dir last crossed TOF
	}

	FTM_SC = TOIE;	// Should have been read in if statement
			// Can clear TOF, set TOIE 
	v_read=FTM_C0SC;   // Read to clear CHF Channel Flag
    1586:	69d9      	ldr	r1, [r3, #28]
	}
	if (!v_initZeroTOF){	// TOFDIR valid
	    v_prevTOFUp=FTM_QDCTRL & TOFDIR;	// Dir last crossed TOF
	}

	FTM_SC = TOIE;	// Should have been read in if statement
    1588:	2040      	movs	r0, #64	; 0x40
    158a:	6010      	str	r0, [r2, #0]
			// Can clear TOF, set TOIE 
	v_read=FTM_C0SC;   // Read to clear CHF Channel Flag
    158c:	6808      	ldr	r0, [r1, #0]
    158e:	6618      	str	r0, [r3, #96]	; 0x60
	FTM_C0SC= 0x50;    // Clear Channel Flag, leave CHIE set
	if (FTM_C0V==COMP_LOW){
    1590:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	}

	FTM_SC = TOIE;	// Should have been read in if statement
			// Can clear TOF, set TOIE 
	v_read=FTM_C0SC;   // Read to clear CHF Channel Flag
	FTM_C0SC= 0x50;    // Clear Channel Flag, leave CHIE set
    1592:	2050      	movs	r0, #80	; 0x50
    1594:	6008      	str	r0, [r1, #0]
	if (FTM_C0V==COMP_LOW){
    1596:	6811      	ldr	r1, [r2, #0]
    1598:	f5b1 4fc0 	cmp.w	r1, #24576	; 0x6000
    159c:	d033      	beq.n	1606 <ftm1_isr+0xb2>
	    v_intStatus=30;
	    v_prevInt=prevIntCompLow;
	    FTM_C0V=COMP_HIGH;	// Set to other compare value
	} else {    // Compare at high value
	    v_intStatus=40;
    159e:	2428      	movs	r4, #40	; 0x28
	    v_prevInt=prevIntCompHigh;
    15a0:	2002      	movs	r0, #2
	    FTM_C0V=COMP_LOW;
    15a2:	f44f 41c0 	mov.w	r1, #24576	; 0x6000
	if (FTM_C0V==COMP_LOW){
	    v_intStatus=30;
	    v_prevInt=prevIntCompLow;
	    FTM_C0V=COMP_HIGH;	// Set to other compare value
	} else {    // Compare at high value
	    v_intStatus=40;
    15a6:	f883 406b 	strb.w	r4, [r3, #107]	; 0x6b
	    v_prevInt=prevIntCompHigh;
    15aa:	f883 006a 	strb.w	r0, [r3, #106]	; 0x6a
	    FTM_C0V=COMP_LOW;
    15ae:	6011      	str	r1, [r2, #0]
    apQDcd1->ftm_isr();
};
    15b0:	bc30      	pop	{r4, r5}
    15b2:	4770      	bx	lr
		v_prevTOFUp = true;	// Reversal will cause TOF
					//   so counting up
	    }
	}
	if (!v_initZeroTOF){	// TOFDIR valid
	    v_prevTOFUp=FTM_QDCTRL & TOFDIR;	// Dir last crossed TOF
    15b4:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
    15b6:	6809      	ldr	r1, [r1, #0]
    15b8:	f3c1 0140 	ubfx	r1, r1, #1, #1
    15bc:	f883 1069 	strb.w	r1, [r3, #105]	; 0x69
    15c0:	e7e1      	b.n	1586 <ftm1_isr+0x32>

	// If previous direction and current same add or subtract 64K
	//   from base position
	// Otherwise reversed in mid-count, base position stays same
	FTM_SC = 0;	    // Clear TOIE, TOF don't care 
	FTM_C0SC= 0x50;	    // Set CHIE Channel Interrupt Enable
    15c2:	69d8      	ldr	r0, [r3, #28]
    
    //First determine which interrupt enabled
    if(FTM_SC == (TOF|TOIE)){	// TOIE and TOF set, TOF interrupt
	v_intStatus=1;

	v_initZeroTOF=false;	// TOF occured, TOFDIR valid
    15c4:	2100      	movs	r1, #0
template <int N>
void QuadDecode<N>::ftm_isr(void){
    
    //First determine which interrupt enabled
    if(FTM_SC == (TOF|TOIE)){	// TOIE and TOF set, TOF interrupt
	v_intStatus=1;
    15c6:	2501      	movs	r5, #1

	// If previous direction and current same add or subtract 64K
	//   from base position
	// Otherwise reversed in mid-count, base position stays same
	FTM_SC = 0;	    // Clear TOIE, TOF don't care 
	FTM_C0SC= 0x50;	    // Set CHIE Channel Interrupt Enable
    15c8:	2450      	movs	r4, #80	; 0x50
template <int N>
void QuadDecode<N>::ftm_isr(void){
    
    //First determine which interrupt enabled
    if(FTM_SC == (TOF|TOIE)){	// TOIE and TOF set, TOF interrupt
	v_intStatus=1;
    15ca:	f883 506b 	strb.w	r5, [r3, #107]	; 0x6b

	v_initZeroTOF=false;	// TOF occured, TOFDIR valid
    15ce:	f883 1068 	strb.w	r1, [r3, #104]	; 0x68

	// If previous direction and current same add or subtract 64K
	//   from base position
	// Otherwise reversed in mid-count, base position stays same
	FTM_SC = 0;	    // Clear TOIE, TOF don't care 
    15d2:	6011      	str	r1, [r2, #0]
	FTM_C0SC= 0x50;	    // Set CHIE Channel Interrupt Enable
    15d4:	6004      	str	r4, [r0, #0]
  	if (v_prevInt==prevIntCompHigh){	// Counting up
    15d6:	f893 206a 	ldrb.w	r2, [r3, #106]	; 0x6a
    15da:	2a02      	cmp	r2, #2
	    v_intStatus=110;
	    FTM_C0V=COMP_LOW;	    // Set compare to closest value
    15dc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	// If previous direction and current same add or subtract 64K
	//   from base position
	// Otherwise reversed in mid-count, base position stays same
	FTM_SC = 0;	    // Clear TOIE, TOF don't care 
	FTM_C0SC= 0x50;	    // Set CHIE Channel Interrupt Enable
  	if (v_prevInt==prevIntCompHigh){	// Counting up
    15de:	d01d      	beq.n	161c <ftm1_isr+0xc8>
	    if (v_prevTOFUp){
		v_intStatus=111;
		v_basePosn+=NUM_64K;    // Up for one counter cycle
	    }
	} else {    // prevIntCompLow, counting down
	    v_intStatus=100;
    15e0:	2064      	movs	r0, #100	; 0x64
	    FTM_C0V=COMP_HIGH;	// First expected compare counting down
    15e2:	f44f 4120 	mov.w	r1, #40960	; 0xa000
	    if (v_prevTOFUp){
		v_intStatus=111;
		v_basePosn+=NUM_64K;    // Up for one counter cycle
	    }
	} else {    // prevIntCompLow, counting down
	    v_intStatus=100;
    15e6:	f883 006b 	strb.w	r0, [r3, #107]	; 0x6b
	    FTM_C0V=COMP_HIGH;	// First expected compare counting down
    15ea:	6011      	str	r1, [r2, #0]
	    if (!v_prevTOFUp){
    15ec:	f893 2069 	ldrb.w	r2, [r3, #105]	; 0x69
    15f0:	2a00      	cmp	r2, #0
    15f2:	d1dd      	bne.n	15b0 <ftm1_isr+0x5c>
		v_intStatus=101;
    15f4:	2265      	movs	r2, #101	; 0x65
    15f6:	f883 206b 	strb.w	r2, [r3, #107]	; 0x6b
		v_basePosn-=NUM_64K;
    15fa:	6e5a      	ldr	r2, [r3, #100]	; 0x64
    15fc:	f5a2 3280 	sub.w	r2, r2, #65536	; 0x10000
    1600:	665a      	str	r2, [r3, #100]	; 0x64
    1602:	bc30      	pop	{r4, r5}
    1604:	4770      	bx	lr
	FTM_SC = TOIE;	// Should have been read in if statement
			// Can clear TOF, set TOIE 
	v_read=FTM_C0SC;   // Read to clear CHF Channel Flag
	FTM_C0SC= 0x50;    // Clear Channel Flag, leave CHIE set
	if (FTM_C0V==COMP_LOW){
	    v_intStatus=30;
    1606:	241e      	movs	r4, #30
    1608:	f883 406b 	strb.w	r4, [r3, #107]	; 0x6b
	    v_prevInt=prevIntCompLow;
    160c:	2001      	movs	r0, #1
	    FTM_C0V=COMP_HIGH;	// Set to other compare value
    160e:	f44f 4120 	mov.w	r1, #40960	; 0xa000
			// Can clear TOF, set TOIE 
	v_read=FTM_C0SC;   // Read to clear CHF Channel Flag
	FTM_C0SC= 0x50;    // Clear Channel Flag, leave CHIE set
	if (FTM_C0V==COMP_LOW){
	    v_intStatus=30;
	    v_prevInt=prevIntCompLow;
    1612:	f883 006a 	strb.w	r0, [r3, #106]	; 0x6a
    1616:	bc30      	pop	{r4, r5}
	    FTM_C0V=COMP_HIGH;	// Set to other compare value
    1618:	6011      	str	r1, [r2, #0]
    161a:	4770      	bx	lr
	//   from base position
	// Otherwise reversed in mid-count, base position stays same
	FTM_SC = 0;	    // Clear TOIE, TOF don't care 
	FTM_C0SC= 0x50;	    // Set CHIE Channel Interrupt Enable
  	if (v_prevInt==prevIntCompHigh){	// Counting up
	    v_intStatus=110;
    161c:	206e      	movs	r0, #110	; 0x6e
	    FTM_C0V=COMP_LOW;	    // Set compare to closest value
    161e:	f44f 41c0 	mov.w	r1, #24576	; 0x6000
	//   from base position
	// Otherwise reversed in mid-count, base position stays same
	FTM_SC = 0;	    // Clear TOIE, TOF don't care 
	FTM_C0SC= 0x50;	    // Set CHIE Channel Interrupt Enable
  	if (v_prevInt==prevIntCompHigh){	// Counting up
	    v_intStatus=110;
    1622:	f883 006b 	strb.w	r0, [r3, #107]	; 0x6b
	    FTM_C0V=COMP_LOW;	    // Set compare to closest value
    1626:	6011      	str	r1, [r2, #0]
		// SYNCEN in FTM1_COMBINE 0, update on next counter edge 
	    if (v_prevTOFUp){
    1628:	f893 2069 	ldrb.w	r2, [r3, #105]	; 0x69
    162c:	2a00      	cmp	r2, #0
    162e:	d0bf      	beq.n	15b0 <ftm1_isr+0x5c>
		v_intStatus=111;
    1630:	226f      	movs	r2, #111	; 0x6f
    1632:	f883 206b 	strb.w	r2, [r3, #107]	; 0x6b
		v_basePosn+=NUM_64K;    // Up for one counter cycle
    1636:	6e5a      	ldr	r2, [r3, #100]	; 0x64
    1638:	f502 3280 	add.w	r2, r2, #65536	; 0x10000
    163c:	665a      	str	r2, [r3, #100]	; 0x64
    163e:	e7b7      	b.n	15b0 <ftm1_isr+0x5c>
    1640:	1fff1608 	.word	0x1fff1608

00001644 <ftm2_isr>:

void ftm2_isr(void){
    apQDcd2->ftm_isr();
    1644:	4b3a      	ldr	r3, [pc, #232]	; (1730 <ftm2_isr+0xec>)
    1646:	681b      	ldr	r3, [r3, #0]
 
template <int N>
void QuadDecode<N>::ftm_isr(void){
    
    //First determine which interrupt enabled
    if(FTM_SC == (TOF|TOIE)){	// TOIE and TOF set, TOF interrupt
    1648:	685a      	ldr	r2, [r3, #4]
    164a:	6811      	ldr	r1, [r2, #0]
    164c:	29c0      	cmp	r1, #192	; 0xc0

void ftm1_isr(void){
    apQDcd1->ftm_isr();
};

void ftm2_isr(void){
    164e:	b430      	push	{r4, r5}
    1650:	d02f      	beq.n	16b2 <ftm2_isr+0x6e>
		v_basePosn-=NUM_64K;
	    }
	}   // Previous and current direction not the same
	    //   indicate reversal, basePosn remains same
    }else { // Channel Compare Int
	v_intStatus=2;
    1652:	2102      	movs	r1, #2
    1654:	f883 106b 	strb.w	r1, [r3, #107]	; 0x6b
	if (v_initZeroTOF){	// No TOF since zero
    1658:	f893 1068 	ldrb.w	r1, [r3, #104]	; 0x68
    165c:	b141      	cbz	r1, 1670 <ftm2_isr+0x2c>
	    if (FTM_SC & TOF){  //TOF Set
    165e:	6811      	ldr	r1, [r2, #0]
    1660:	0609      	lsls	r1, r1, #24
		v_initZeroTOF=false;	// TOF occured, TOFDIR valid
    1662:	bf4b      	itete	mi
    1664:	2100      	movmi	r1, #0
	    } else {
		v_prevTOFUp = true;	// Reversal will cause TOF
    1666:	2101      	movpl	r1, #1
	    //   indicate reversal, basePosn remains same
    }else { // Channel Compare Int
	v_intStatus=2;
	if (v_initZeroTOF){	// No TOF since zero
	    if (FTM_SC & TOF){  //TOF Set
		v_initZeroTOF=false;	// TOF occured, TOFDIR valid
    1668:	f883 1068 	strbmi.w	r1, [r3, #104]	; 0x68
	    } else {
		v_prevTOFUp = true;	// Reversal will cause TOF
    166c:	f883 1069 	strbpl.w	r1, [r3, #105]	; 0x69
					//   so counting up
	    }
	}
	if (!v_initZeroTOF){	// TOFDIR valid
    1670:	f893 1068 	ldrb.w	r1, [r3, #104]	; 0x68
    1674:	b1b1      	cbz	r1, 16a4 <ftm2_isr+0x60>
	    v_prevTOFUp=FTM_QDCTRL & TOFDIR;	// Dir last crossed TOF
	}

	FTM_SC = TOIE;	// Should have been read in if statement
			// Can clear TOF, set TOIE 
	v_read=FTM_C0SC;   // Read to clear CHF Channel Flag
    1676:	69d9      	ldr	r1, [r3, #28]
	}
	if (!v_initZeroTOF){	// TOFDIR valid
	    v_prevTOFUp=FTM_QDCTRL & TOFDIR;	// Dir last crossed TOF
	}

	FTM_SC = TOIE;	// Should have been read in if statement
    1678:	2040      	movs	r0, #64	; 0x40
    167a:	6010      	str	r0, [r2, #0]
			// Can clear TOF, set TOIE 
	v_read=FTM_C0SC;   // Read to clear CHF Channel Flag
    167c:	6808      	ldr	r0, [r1, #0]
    167e:	6618      	str	r0, [r3, #96]	; 0x60
	FTM_C0SC= 0x50;    // Clear Channel Flag, leave CHIE set
	if (FTM_C0V==COMP_LOW){
    1680:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	}

	FTM_SC = TOIE;	// Should have been read in if statement
			// Can clear TOF, set TOIE 
	v_read=FTM_C0SC;   // Read to clear CHF Channel Flag
	FTM_C0SC= 0x50;    // Clear Channel Flag, leave CHIE set
    1682:	2050      	movs	r0, #80	; 0x50
    1684:	6008      	str	r0, [r1, #0]
	if (FTM_C0V==COMP_LOW){
    1686:	6811      	ldr	r1, [r2, #0]
    1688:	f5b1 4fc0 	cmp.w	r1, #24576	; 0x6000
    168c:	d033      	beq.n	16f6 <ftm2_isr+0xb2>
	    v_intStatus=30;
	    v_prevInt=prevIntCompLow;
	    FTM_C0V=COMP_HIGH;	// Set to other compare value
	} else {    // Compare at high value
	    v_intStatus=40;
    168e:	2428      	movs	r4, #40	; 0x28
	    v_prevInt=prevIntCompHigh;
    1690:	2002      	movs	r0, #2
	    FTM_C0V=COMP_LOW;
    1692:	f44f 41c0 	mov.w	r1, #24576	; 0x6000
	if (FTM_C0V==COMP_LOW){
	    v_intStatus=30;
	    v_prevInt=prevIntCompLow;
	    FTM_C0V=COMP_HIGH;	// Set to other compare value
	} else {    // Compare at high value
	    v_intStatus=40;
    1696:	f883 406b 	strb.w	r4, [r3, #107]	; 0x6b
	    v_prevInt=prevIntCompHigh;
    169a:	f883 006a 	strb.w	r0, [r3, #106]	; 0x6a
	    FTM_C0V=COMP_LOW;
    169e:	6011      	str	r1, [r2, #0]
    apQDcd2->ftm_isr();
    16a0:	bc30      	pop	{r4, r5}
    16a2:	4770      	bx	lr
		v_prevTOFUp = true;	// Reversal will cause TOF
					//   so counting up
	    }
	}
	if (!v_initZeroTOF){	// TOFDIR valid
	    v_prevTOFUp=FTM_QDCTRL & TOFDIR;	// Dir last crossed TOF
    16a4:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
    16a6:	6809      	ldr	r1, [r1, #0]
    16a8:	f3c1 0140 	ubfx	r1, r1, #1, #1
    16ac:	f883 1069 	strb.w	r1, [r3, #105]	; 0x69
    16b0:	e7e1      	b.n	1676 <ftm2_isr+0x32>

	// If previous direction and current same add or subtract 64K
	//   from base position
	// Otherwise reversed in mid-count, base position stays same
	FTM_SC = 0;	    // Clear TOIE, TOF don't care 
	FTM_C0SC= 0x50;	    // Set CHIE Channel Interrupt Enable
    16b2:	69d8      	ldr	r0, [r3, #28]
    
    //First determine which interrupt enabled
    if(FTM_SC == (TOF|TOIE)){	// TOIE and TOF set, TOF interrupt
	v_intStatus=1;

	v_initZeroTOF=false;	// TOF occured, TOFDIR valid
    16b4:	2100      	movs	r1, #0
template <int N>
void QuadDecode<N>::ftm_isr(void){
    
    //First determine which interrupt enabled
    if(FTM_SC == (TOF|TOIE)){	// TOIE and TOF set, TOF interrupt
	v_intStatus=1;
    16b6:	2501      	movs	r5, #1

	// If previous direction and current same add or subtract 64K
	//   from base position
	// Otherwise reversed in mid-count, base position stays same
	FTM_SC = 0;	    // Clear TOIE, TOF don't care 
	FTM_C0SC= 0x50;	    // Set CHIE Channel Interrupt Enable
    16b8:	2450      	movs	r4, #80	; 0x50
template <int N>
void QuadDecode<N>::ftm_isr(void){
    
    //First determine which interrupt enabled
    if(FTM_SC == (TOF|TOIE)){	// TOIE and TOF set, TOF interrupt
	v_intStatus=1;
    16ba:	f883 506b 	strb.w	r5, [r3, #107]	; 0x6b

	v_initZeroTOF=false;	// TOF occured, TOFDIR valid
    16be:	f883 1068 	strb.w	r1, [r3, #104]	; 0x68

	// If previous direction and current same add or subtract 64K
	//   from base position
	// Otherwise reversed in mid-count, base position stays same
	FTM_SC = 0;	    // Clear TOIE, TOF don't care 
    16c2:	6011      	str	r1, [r2, #0]
	FTM_C0SC= 0x50;	    // Set CHIE Channel Interrupt Enable
    16c4:	6004      	str	r4, [r0, #0]
  	if (v_prevInt==prevIntCompHigh){	// Counting up
    16c6:	f893 206a 	ldrb.w	r2, [r3, #106]	; 0x6a
    16ca:	2a02      	cmp	r2, #2
	    v_intStatus=110;
	    FTM_C0V=COMP_LOW;	    // Set compare to closest value
    16cc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	// If previous direction and current same add or subtract 64K
	//   from base position
	// Otherwise reversed in mid-count, base position stays same
	FTM_SC = 0;	    // Clear TOIE, TOF don't care 
	FTM_C0SC= 0x50;	    // Set CHIE Channel Interrupt Enable
  	if (v_prevInt==prevIntCompHigh){	// Counting up
    16ce:	d01d      	beq.n	170c <ftm2_isr+0xc8>
	    if (v_prevTOFUp){
		v_intStatus=111;
		v_basePosn+=NUM_64K;    // Up for one counter cycle
	    }
	} else {    // prevIntCompLow, counting down
	    v_intStatus=100;
    16d0:	2064      	movs	r0, #100	; 0x64
	    FTM_C0V=COMP_HIGH;	// First expected compare counting down
    16d2:	f44f 4120 	mov.w	r1, #40960	; 0xa000
	    if (v_prevTOFUp){
		v_intStatus=111;
		v_basePosn+=NUM_64K;    // Up for one counter cycle
	    }
	} else {    // prevIntCompLow, counting down
	    v_intStatus=100;
    16d6:	f883 006b 	strb.w	r0, [r3, #107]	; 0x6b
	    FTM_C0V=COMP_HIGH;	// First expected compare counting down
    16da:	6011      	str	r1, [r2, #0]
	    if (!v_prevTOFUp){
    16dc:	f893 2069 	ldrb.w	r2, [r3, #105]	; 0x69
    16e0:	2a00      	cmp	r2, #0
    16e2:	d1dd      	bne.n	16a0 <ftm2_isr+0x5c>
		v_intStatus=101;
    16e4:	2265      	movs	r2, #101	; 0x65
    16e6:	f883 206b 	strb.w	r2, [r3, #107]	; 0x6b
		v_basePosn-=NUM_64K;
    16ea:	6e5a      	ldr	r2, [r3, #100]	; 0x64
    16ec:	f5a2 3280 	sub.w	r2, r2, #65536	; 0x10000
    16f0:	665a      	str	r2, [r3, #100]	; 0x64
    16f2:	bc30      	pop	{r4, r5}
    16f4:	4770      	bx	lr
	FTM_SC = TOIE;	// Should have been read in if statement
			// Can clear TOF, set TOIE 
	v_read=FTM_C0SC;   // Read to clear CHF Channel Flag
	FTM_C0SC= 0x50;    // Clear Channel Flag, leave CHIE set
	if (FTM_C0V==COMP_LOW){
	    v_intStatus=30;
    16f6:	241e      	movs	r4, #30
    16f8:	f883 406b 	strb.w	r4, [r3, #107]	; 0x6b
	    v_prevInt=prevIntCompLow;
    16fc:	2001      	movs	r0, #1
	    FTM_C0V=COMP_HIGH;	// Set to other compare value
    16fe:	f44f 4120 	mov.w	r1, #40960	; 0xa000
			// Can clear TOF, set TOIE 
	v_read=FTM_C0SC;   // Read to clear CHF Channel Flag
	FTM_C0SC= 0x50;    // Clear Channel Flag, leave CHIE set
	if (FTM_C0V==COMP_LOW){
	    v_intStatus=30;
	    v_prevInt=prevIntCompLow;
    1702:	f883 006a 	strb.w	r0, [r3, #106]	; 0x6a
    1706:	bc30      	pop	{r4, r5}
	    FTM_C0V=COMP_HIGH;	// Set to other compare value
    1708:	6011      	str	r1, [r2, #0]
    170a:	4770      	bx	lr
	//   from base position
	// Otherwise reversed in mid-count, base position stays same
	FTM_SC = 0;	    // Clear TOIE, TOF don't care 
	FTM_C0SC= 0x50;	    // Set CHIE Channel Interrupt Enable
  	if (v_prevInt==prevIntCompHigh){	// Counting up
	    v_intStatus=110;
    170c:	206e      	movs	r0, #110	; 0x6e
	    FTM_C0V=COMP_LOW;	    // Set compare to closest value
    170e:	f44f 41c0 	mov.w	r1, #24576	; 0x6000
	//   from base position
	// Otherwise reversed in mid-count, base position stays same
	FTM_SC = 0;	    // Clear TOIE, TOF don't care 
	FTM_C0SC= 0x50;	    // Set CHIE Channel Interrupt Enable
  	if (v_prevInt==prevIntCompHigh){	// Counting up
	    v_intStatus=110;
    1712:	f883 006b 	strb.w	r0, [r3, #107]	; 0x6b
	    FTM_C0V=COMP_LOW;	    // Set compare to closest value
    1716:	6011      	str	r1, [r2, #0]
		// SYNCEN in FTM1_COMBINE 0, update on next counter edge 
	    if (v_prevTOFUp){
    1718:	f893 2069 	ldrb.w	r2, [r3, #105]	; 0x69
    171c:	2a00      	cmp	r2, #0
    171e:	d0bf      	beq.n	16a0 <ftm2_isr+0x5c>
		v_intStatus=111;
    1720:	226f      	movs	r2, #111	; 0x6f
    1722:	f883 206b 	strb.w	r2, [r3, #107]	; 0x6b
		v_basePosn+=NUM_64K;    // Up for one counter cycle
    1726:	6e5a      	ldr	r2, [r3, #100]	; 0x64
    1728:	f502 3280 	add.w	r2, r2, #65536	; 0x10000
    172c:	665a      	str	r2, [r3, #100]	; 0x64
    172e:	e7b7      	b.n	16a0 <ftm2_isr+0x5c>
    1730:	1fff160c 	.word	0x1fff160c

00001734 <Waveform::Waveform(Waveform::Type, unsigned long, float)>:
Waveform::Waveform(Type type, uint32_t period, float amplitude, uint32_t delayTime){
	_type = type;
	
	_period = period;
	_delay = delayTime;
	_periodInSeconds = (float)_period / 1000000.0f;
    1734:	ee07 2a90 	vmov	s15, r2
    1738:	eef8 6a67 	vcvt.f32.u32	s13, s15
    173c:	ed9f 7a07 	vldr	s14, [pc, #28]	; 175c <Waveform::Waveform(Waveform::Type, unsigned long, float)+0x28>
#include "Waveform.h"
#include <math.h>
#include "Helper.h"

Waveform::Waveform(Type type, uint32_t period, float amplitude, uint32_t delayTime){
	_type = type;
    1740:	7001      	strb	r1, [r0, #0]
	
	_period = period;
	_delay = delayTime;
	_periodInSeconds = (float)_period / 1000000.0f;
    1742:	eec6 7a87 	vdiv.f32	s15, s13, s14

	_amplitude = amplitude;
}

Waveform::Waveform(Type type, uint32_t period, float amplitude) : Waveform(type, period, amplitude, 0) {}
    1746:	b410      	push	{r4}

Waveform::Waveform(Type type, uint32_t period, float amplitude, uint32_t delayTime){
	_type = type;
	
	_period = period;
	_delay = delayTime;
    1748:	2400      	movs	r4, #0
    174a:	6084      	str	r4, [r0, #8]
#include "Helper.h"

Waveform::Waveform(Type type, uint32_t period, float amplitude, uint32_t delayTime){
	_type = type;
	
	_period = period;
    174c:	6042      	str	r2, [r0, #4]
	_periodInSeconds = (float)_period / 1000000.0f;

	_amplitude = amplitude;
}

Waveform::Waveform(Type type, uint32_t period, float amplitude) : Waveform(type, period, amplitude, 0) {}
    174e:	f85d 4b04 	ldr.w	r4, [sp], #4
	
	_period = period;
	_delay = delayTime;
	_periodInSeconds = (float)_period / 1000000.0f;

	_amplitude = amplitude;
    1752:	ed80 0a04 	vstr	s0, [r0, #16]
Waveform::Waveform(Type type, uint32_t period, float amplitude, uint32_t delayTime){
	_type = type;
	
	_period = period;
	_delay = delayTime;
	_periodInSeconds = (float)_period / 1000000.0f;
    1756:	edc0 7a03 	vstr	s15, [r0, #12]

	_amplitude = amplitude;
}

Waveform::Waveform(Type type, uint32_t period, float amplitude) : Waveform(type, period, amplitude, 0) {}
    175a:	4770      	bx	lr
    175c:	49742400 	.word	0x49742400

00001760 <Waveform::getValue(unsigned long)>:

double Waveform::getValue(uint32_t time){
	if (time <= _delay) return 0.0;	//return 0 when delay time is not yet passed
    1760:	6883      	ldr	r3, [r0, #8]
    1762:	428b      	cmp	r3, r1
    1764:	d216      	bcs.n	1794 <Waveform::getValue(unsigned long)+0x34>

	uint32_t delayedTime = time - _delay;
	float timeInSeconds = (float)delayedTime / 1000000.0f;	//time in microseconds
    1766:	1ac9      	subs	r1, r1, r3
    1768:	ee07 1a90 	vmov	s15, r1
	double returnValue = 0;

	switch (_type){
    176c:	7803      	ldrb	r3, [r0, #0]

double Waveform::getValue(uint32_t time){
	if (time <= _delay) return 0.0;	//return 0 when delay time is not yet passed

	uint32_t delayedTime = time - _delay;
	float timeInSeconds = (float)delayedTime / 1000000.0f;	//time in microseconds
    176e:	ed9f 7a2c 	vldr	s14, [pc, #176]	; 1820 <Waveform::getValue(unsigned long)+0xc0>
    1772:	eef8 7a67 	vcvt.f32.u32	s15, s15
	double returnValue = 0;

	switch (_type){
    1776:	2b01      	cmp	r3, #1
	_amplitude = amplitude;
}

Waveform::Waveform(Type type, uint32_t period, float amplitude) : Waveform(type, period, amplitude, 0) {}

double Waveform::getValue(uint32_t time){
    1778:	b510      	push	{r4, lr}
	if (time <= _delay) return 0.0;	//return 0 when delay time is not yet passed

	uint32_t delayedTime = time - _delay;
	float timeInSeconds = (float)delayedTime / 1000000.0f;	//time in microseconds
    177a:	ee87 0a87 	vdiv.f32	s0, s15, s14
    177e:	4604      	mov	r4, r0
	double returnValue = 0;

	switch (_type){
    1780:	d00e      	beq.n	17a0 <Waveform::getValue(unsigned long)+0x40>
    1782:	d333      	bcc.n	17ec <Waveform::getValue(unsigned long)+0x8c>
    1784:	2b02      	cmp	r3, #2
    1786:	d108      	bne.n	179a <Waveform::getValue(unsigned long)+0x3a>
		case SIN:
			returnValue = _amplitude * sinf(2.0f * PI / _periodInSeconds * timeInSeconds);
			break;

		case STEP:
			return _amplitude;
    1788:	6900      	ldr	r0, [r0, #16]
    178a:	f003 fff7 	bl	577c <__aeabi_f2d>
    178e:	ec41 0b10 	vmov	d0, r0, r1
    1792:	bd10      	pop	{r4, pc}
}

Waveform::Waveform(Type type, uint32_t period, float amplitude) : Waveform(type, period, amplitude, 0) {}

double Waveform::getValue(uint32_t time){
	if (time <= _delay) return 0.0;	//return 0 when delay time is not yet passed
    1794:	ed9f 0b20 	vldr	d0, [pc, #128]	; 1818 <Waveform::getValue(unsigned long)+0xb8>
			returnValue = 0.0;
			break;
	}

	return returnValue;
    1798:	4770      	bx	lr
double Waveform::getValue(uint32_t time){
	if (time <= _delay) return 0.0;	//return 0 when delay time is not yet passed

	uint32_t delayedTime = time - _delay;
	float timeInSeconds = (float)delayedTime / 1000000.0f;	//time in microseconds
	double returnValue = 0;
    179a:	ed9f 0b1f 	vldr	d0, [pc, #124]	; 1818 <Waveform::getValue(unsigned long)+0xb8>
			returnValue = 0.0;
			break;
	}

	return returnValue;
    179e:	bd10      	pop	{r4, pc}
			//implementation from https://en.wikipedia.org/wiki/Triangle_wave
			//returnValue = _amplitude * 2.0 / PI * asin(sin(2.0 * PI / periodInSeconds * timeInSeconds)); //probably too slow

			//fmod does not return the desired result --> now uses realmod in Helper.h --> https://stackoverflow.com/questions/28888619/modulo-function-in-c-that-behaves-like-mod-in-matlab
			float absValue;	//prevents initialization error --> don't exactly know why
			absValue = realmod((timeInSeconds - (_periodInSeconds / 4.0f)), _periodInSeconds) - (_periodInSeconds / 2.0f);
    17a0:	edd0 0a03 	vldr	s1, [r0, #12]
    17a4:	eef5 7a00 	vmov.f32	s15, #80	; 0x3e800000  0.250
    17a8:	eea0 0ae7 	vfms.f32	s0, s1, s15
    17ac:	f7ff fb7e 	bl	eac <realmod(float, float)>
    17b0:	edd4 6a03 	vldr	s13, [r4, #12]
			returnValue = (_amplitude * 4.0f / _periodInSeconds) * abs(absValue) - _amplitude;
    17b4:	ed94 7a04 	vldr	s14, [r4, #16]
			//implementation from https://en.wikipedia.org/wiki/Triangle_wave
			//returnValue = _amplitude * 2.0 / PI * asin(sin(2.0 * PI / periodInSeconds * timeInSeconds)); //probably too slow

			//fmod does not return the desired result --> now uses realmod in Helper.h --> https://stackoverflow.com/questions/28888619/modulo-function-in-c-that-behaves-like-mod-in-matlab
			float absValue;	//prevents initialization error --> don't exactly know why
			absValue = realmod((timeInSeconds - (_periodInSeconds / 4.0f)), _periodInSeconds) - (_periodInSeconds / 2.0f);
    17b8:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    17bc:	eea6 0ae7 	vfms.f32	s0, s13, s15
			returnValue = (_amplitude * 4.0f / _periodInSeconds) * abs(absValue) - _amplitude;
    17c0:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
    17c4:	ee67 7a27 	vmul.f32	s15, s14, s15
    17c8:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
    17cc:	ee87 6aa6 	vdiv.f32	s12, s15, s13
    17d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    17d4:	bfd8      	it	le
    17d6:	eeb1 0a40 	vnegle.f32	s0, s0
    17da:	ee90 7a06 	vfnms.f32	s14, s0, s12
    17de:	ee17 0a10 	vmov	r0, s14
    17e2:	f003 ffcb 	bl	577c <__aeabi_f2d>
    17e6:	ec41 0b10 	vmov	d0, r0, r1
			break;
    17ea:	bd10      	pop	{r4, pc}
	float timeInSeconds = (float)delayedTime / 1000000.0f;	//time in microseconds
	double returnValue = 0;

	switch (_type){
		case SIN:
			returnValue = _amplitude * sinf(2.0f * PI / _periodInSeconds * timeInSeconds);
    17ec:	ed90 7a03 	vldr	s14, [r0, #12]
    17f0:	eddf 6a0c 	vldr	s13, [pc, #48]	; 1824 <Waveform::getValue(unsigned long)+0xc4>
    17f4:	eec6 7a87 	vdiv.f32	s15, s13, s14
    17f8:	ee27 0a80 	vmul.f32	s0, s15, s0
    17fc:	f002 fe76 	bl	44ec <sinf>
    1800:	edd4 7a04 	vldr	s15, [r4, #16]
    1804:	ee60 7a27 	vmul.f32	s15, s0, s15
    1808:	ee17 0a90 	vmov	r0, s15
    180c:	f003 ffb6 	bl	577c <__aeabi_f2d>
    1810:	ec41 0b10 	vmov	d0, r0, r1
			break;
    1814:	bd10      	pop	{r4, pc}
    1816:	bf00      	nop
	...
    1820:	49742400 	.word	0x49742400
    1824:	40c90fdb 	.word	0x40c90fdb

00001828 <wait_for_cal>:
{
	uint16_t sum;

	//serial_print("wait_for_cal\n");
#if defined(HAS_KINETIS_ADC0) && defined(HAS_KINETIS_ADC1)
	while ((ADC0_SC3 & ADC_SC3_CAL) || (ADC1_SC3 & ADC_SC3_CAL)) {
    1828:	4a37      	ldr	r2, [pc, #220]	; (1908 <wait_for_cal+0xe0>)
    182a:	4938      	ldr	r1, [pc, #224]	; (190c <wait_for_cal+0xe4>)
    182c:	6813      	ldr	r3, [r2, #0]
    182e:	061b      	lsls	r3, r3, #24
    1830:	d4fc      	bmi.n	182c <wait_for_cal+0x4>
    1832:	680b      	ldr	r3, [r1, #0]
    1834:	f013 0380 	ands.w	r3, r3, #128	; 0x80
    1838:	d1f8      	bne.n	182c <wait_for_cal+0x4>
#elif defined(HAS_KINETIS_ADC0)
	while (ADC0_SC3 & ADC_SC3_CAL) {
		// wait
	}
#endif
	__disable_irq();
    183a:	b672      	cpsid	i
	if (calibrating) {
    183c:	4934      	ldr	r1, [pc, #208]	; (1910 <wait_for_cal+0xe8>)
    183e:	780a      	ldrb	r2, [r1, #0]
    1840:	2a00      	cmp	r2, #0
    1842:	d05f      	beq.n	1904 <wait_for_cal+0xdc>
		//serial_print("\n");
		sum = ADC0_CLPS + ADC0_CLP4 + ADC0_CLP3 + ADC0_CLP2 + ADC0_CLP1 + ADC0_CLP0;
    1844:	4a33      	ldr	r2, [pc, #204]	; (1914 <wait_for_cal+0xec>)
    1846:	4834      	ldr	r0, [pc, #208]	; (1918 <wait_for_cal+0xf0>)
	}
	calibrating = 1;
}

static void wait_for_cal(void)
{
    1848:	b4f0      	push	{r4, r5, r6, r7}
	}
#endif
	__disable_irq();
	if (calibrating) {
		//serial_print("\n");
		sum = ADC0_CLPS + ADC0_CLP4 + ADC0_CLP3 + ADC0_CLP2 + ADC0_CLP1 + ADC0_CLP0;
    184a:	4c34      	ldr	r4, [pc, #208]	; (191c <wait_for_cal+0xf4>)
    184c:	6817      	ldr	r7, [r2, #0]
    184e:	6806      	ldr	r6, [r0, #0]
    1850:	6825      	ldr	r5, [r4, #0]
    1852:	68d4      	ldr	r4, [r2, #12]
    1854:	300c      	adds	r0, #12
		sum = (sum / 2) | 0x8000;
    1856:	443e      	add	r6, r7
	}
#endif
	__disable_irq();
	if (calibrating) {
		//serial_print("\n");
		sum = ADC0_CLPS + ADC0_CLP4 + ADC0_CLP3 + ADC0_CLP2 + ADC0_CLP1 + ADC0_CLP0;
    1858:	3214      	adds	r2, #20
    185a:	6800      	ldr	r0, [r0, #0]
    185c:	6812      	ldr	r2, [r2, #0]
		sum = (sum / 2) | 0x8000;
		ADC0_PG = sum;
    185e:	4f30      	ldr	r7, [pc, #192]	; (1920 <wait_for_cal+0xf8>)
#endif
	__disable_irq();
	if (calibrating) {
		//serial_print("\n");
		sum = ADC0_CLPS + ADC0_CLP4 + ADC0_CLP3 + ADC0_CLP2 + ADC0_CLP1 + ADC0_CLP0;
		sum = (sum / 2) | 0x8000;
    1860:	4435      	add	r5, r6
    1862:	442c      	add	r4, r5
    1864:	4420      	add	r0, r4
    1866:	4402      	add	r2, r0
    1868:	f3c2 024e 	ubfx	r2, r2, #1, #15
		ADC0_PG = sum;
		//serial_print("ADC0_PG = ");
		//serial_phex16(sum);
		//serial_print("\n");
		sum = ADC0_CLMS + ADC0_CLM4 + ADC0_CLM3 + ADC0_CLM2 + ADC0_CLM1 + ADC0_CLM0;
    186c:	4e2d      	ldr	r6, [pc, #180]	; (1924 <wait_for_cal+0xfc>)
    186e:	482e      	ldr	r0, [pc, #184]	; (1928 <wait_for_cal+0x100>)
    1870:	4d2e      	ldr	r5, [pc, #184]	; (192c <wait_for_cal+0x104>)
    1872:	4c2f      	ldr	r4, [pc, #188]	; (1930 <wait_for_cal+0x108>)
	__disable_irq();
	if (calibrating) {
		//serial_print("\n");
		sum = ADC0_CLPS + ADC0_CLP4 + ADC0_CLP3 + ADC0_CLP2 + ADC0_CLP1 + ADC0_CLP0;
		sum = (sum / 2) | 0x8000;
		ADC0_PG = sum;
    1874:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    1878:	603a      	str	r2, [r7, #0]
		//serial_print("ADC0_PG = ");
		//serial_phex16(sum);
		//serial_print("\n");
		sum = ADC0_CLMS + ADC0_CLM4 + ADC0_CLM3 + ADC0_CLM2 + ADC0_CLM1 + ADC0_CLM0;
    187a:	6837      	ldr	r7, [r6, #0]
    187c:	6806      	ldr	r6, [r0, #0]
    187e:	682d      	ldr	r5, [r5, #0]
    1880:	4a2c      	ldr	r2, [pc, #176]	; (1934 <wait_for_cal+0x10c>)
    1882:	6824      	ldr	r4, [r4, #0]
    1884:	300c      	adds	r0, #12
		sum = (sum / 2) | 0x8000;
    1886:	443e      	add	r6, r7
		sum = (sum / 2) | 0x8000;
		ADC0_PG = sum;
		//serial_print("ADC0_PG = ");
		//serial_phex16(sum);
		//serial_print("\n");
		sum = ADC0_CLMS + ADC0_CLM4 + ADC0_CLM3 + ADC0_CLM2 + ADC0_CLM1 + ADC0_CLM0;
    1888:	6800      	ldr	r0, [r0, #0]
    188a:	6812      	ldr	r2, [r2, #0]
		sum = (sum / 2) | 0x8000;
		ADC0_MG = sum;
    188c:	4f2a      	ldr	r7, [pc, #168]	; (1938 <wait_for_cal+0x110>)
		ADC0_PG = sum;
		//serial_print("ADC0_PG = ");
		//serial_phex16(sum);
		//serial_print("\n");
		sum = ADC0_CLMS + ADC0_CLM4 + ADC0_CLM3 + ADC0_CLM2 + ADC0_CLM1 + ADC0_CLM0;
		sum = (sum / 2) | 0x8000;
    188e:	4435      	add	r5, r6
    1890:	442c      	add	r4, r5
    1892:	4420      	add	r0, r4
    1894:	4402      	add	r2, r0
    1896:	f3c2 024e 	ubfx	r2, r2, #1, #15
		ADC0_MG = sum;
		//serial_print("ADC0_MG = ");
		//serial_phex16(sum);
		//serial_print("\n");
#ifdef HAS_KINETIS_ADC1
		sum = ADC1_CLPS + ADC1_CLP4 + ADC1_CLP3 + ADC1_CLP2 + ADC1_CLP1 + ADC1_CLP0;
    189a:	4e28      	ldr	r6, [pc, #160]	; (193c <wait_for_cal+0x114>)
    189c:	4828      	ldr	r0, [pc, #160]	; (1940 <wait_for_cal+0x118>)
    189e:	4d29      	ldr	r5, [pc, #164]	; (1944 <wait_for_cal+0x11c>)
    18a0:	4c29      	ldr	r4, [pc, #164]	; (1948 <wait_for_cal+0x120>)
		//serial_print("ADC0_PG = ");
		//serial_phex16(sum);
		//serial_print("\n");
		sum = ADC0_CLMS + ADC0_CLM4 + ADC0_CLM3 + ADC0_CLM2 + ADC0_CLM1 + ADC0_CLM0;
		sum = (sum / 2) | 0x8000;
		ADC0_MG = sum;
    18a2:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    18a6:	603a      	str	r2, [r7, #0]
		//serial_print("ADC0_MG = ");
		//serial_phex16(sum);
		//serial_print("\n");
#ifdef HAS_KINETIS_ADC1
		sum = ADC1_CLPS + ADC1_CLP4 + ADC1_CLP3 + ADC1_CLP2 + ADC1_CLP1 + ADC1_CLP0;
    18a8:	6837      	ldr	r7, [r6, #0]
    18aa:	6806      	ldr	r6, [r0, #0]
    18ac:	682d      	ldr	r5, [r5, #0]
    18ae:	4a27      	ldr	r2, [pc, #156]	; (194c <wait_for_cal+0x124>)
    18b0:	6824      	ldr	r4, [r4, #0]
    18b2:	300c      	adds	r0, #12
		sum = (sum / 2) | 0x8000;
    18b4:	443e      	add	r6, r7
		ADC0_MG = sum;
		//serial_print("ADC0_MG = ");
		//serial_phex16(sum);
		//serial_print("\n");
#ifdef HAS_KINETIS_ADC1
		sum = ADC1_CLPS + ADC1_CLP4 + ADC1_CLP3 + ADC1_CLP2 + ADC1_CLP1 + ADC1_CLP0;
    18b6:	6800      	ldr	r0, [r0, #0]
    18b8:	6812      	ldr	r2, [r2, #0]
		sum = (sum / 2) | 0x8000;
		ADC1_PG = sum;
    18ba:	4f25      	ldr	r7, [pc, #148]	; (1950 <wait_for_cal+0x128>)
		//serial_print("ADC0_MG = ");
		//serial_phex16(sum);
		//serial_print("\n");
#ifdef HAS_KINETIS_ADC1
		sum = ADC1_CLPS + ADC1_CLP4 + ADC1_CLP3 + ADC1_CLP2 + ADC1_CLP1 + ADC1_CLP0;
		sum = (sum / 2) | 0x8000;
    18bc:	4435      	add	r5, r6
    18be:	442c      	add	r4, r5
    18c0:	4420      	add	r0, r4
    18c2:	4402      	add	r2, r0
    18c4:	f3c2 024e 	ubfx	r2, r2, #1, #15
		ADC1_PG = sum;
		sum = ADC1_CLMS + ADC1_CLM4 + ADC1_CLM3 + ADC1_CLM2 + ADC1_CLM1 + ADC1_CLM0;
    18c8:	4e22      	ldr	r6, [pc, #136]	; (1954 <wait_for_cal+0x12c>)
    18ca:	4823      	ldr	r0, [pc, #140]	; (1958 <wait_for_cal+0x130>)
    18cc:	4d23      	ldr	r5, [pc, #140]	; (195c <wait_for_cal+0x134>)
    18ce:	4c24      	ldr	r4, [pc, #144]	; (1960 <wait_for_cal+0x138>)
		//serial_phex16(sum);
		//serial_print("\n");
#ifdef HAS_KINETIS_ADC1
		sum = ADC1_CLPS + ADC1_CLP4 + ADC1_CLP3 + ADC1_CLP2 + ADC1_CLP1 + ADC1_CLP0;
		sum = (sum / 2) | 0x8000;
		ADC1_PG = sum;
    18d0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    18d4:	603a      	str	r2, [r7, #0]
		sum = ADC1_CLMS + ADC1_CLM4 + ADC1_CLM3 + ADC1_CLM2 + ADC1_CLM1 + ADC1_CLM0;
    18d6:	6837      	ldr	r7, [r6, #0]
    18d8:	6806      	ldr	r6, [r0, #0]
    18da:	682d      	ldr	r5, [r5, #0]
    18dc:	4a21      	ldr	r2, [pc, #132]	; (1964 <wait_for_cal+0x13c>)
    18de:	6824      	ldr	r4, [r4, #0]
    18e0:	300c      	adds	r0, #12
		sum = (sum / 2) | 0x8000;
    18e2:	443e      	add	r6, r7
		//serial_print("\n");
#ifdef HAS_KINETIS_ADC1
		sum = ADC1_CLPS + ADC1_CLP4 + ADC1_CLP3 + ADC1_CLP2 + ADC1_CLP1 + ADC1_CLP0;
		sum = (sum / 2) | 0x8000;
		ADC1_PG = sum;
		sum = ADC1_CLMS + ADC1_CLM4 + ADC1_CLM3 + ADC1_CLM2 + ADC1_CLM1 + ADC1_CLM0;
    18e4:	6800      	ldr	r0, [r0, #0]
    18e6:	6812      	ldr	r2, [r2, #0]
		sum = (sum / 2) | 0x8000;
    18e8:	4435      	add	r5, r6
    18ea:	442c      	add	r4, r5
    18ec:	4420      	add	r0, r4
    18ee:	4402      	add	r2, r0
    18f0:	f3c2 024e 	ubfx	r2, r2, #1, #15
		ADC1_MG = sum;
    18f4:	481c      	ldr	r0, [pc, #112]	; (1968 <wait_for_cal+0x140>)
    18f6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    18fa:	6002      	str	r2, [r0, #0]
#endif
		calibrating = 0;
    18fc:	700b      	strb	r3, [r1, #0]
	}
	__enable_irq();
    18fe:	b662      	cpsie	i
}
    1900:	bcf0      	pop	{r4, r5, r6, r7}
    1902:	4770      	bx	lr
		sum = (sum / 2) | 0x8000;
		ADC1_MG = sum;
#endif
		calibrating = 0;
	}
	__enable_irq();
    1904:	b662      	cpsie	i
    1906:	4770      	bx	lr
    1908:	4003b024 	.word	0x4003b024
    190c:	400bb024 	.word	0x400bb024
    1910:	1fff1611 	.word	0x1fff1611
    1914:	4003b038 	.word	0x4003b038
    1918:	4003b03c 	.word	0x4003b03c
    191c:	4003b040 	.word	0x4003b040
    1920:	4003b02c 	.word	0x4003b02c
    1924:	4003b058 	.word	0x4003b058
    1928:	4003b05c 	.word	0x4003b05c
    192c:	4003b060 	.word	0x4003b060
    1930:	4003b064 	.word	0x4003b064
    1934:	4003b06c 	.word	0x4003b06c
    1938:	4003b030 	.word	0x4003b030
    193c:	400bb038 	.word	0x400bb038
    1940:	400bb03c 	.word	0x400bb03c
    1944:	400bb040 	.word	0x400bb040
    1948:	400bb044 	.word	0x400bb044
    194c:	400bb04c 	.word	0x400bb04c
    1950:	400bb02c 	.word	0x400bb02c
    1954:	400bb058 	.word	0x400bb058
    1958:	400bb05c 	.word	0x400bb05c
    195c:	400bb060 	.word	0x400bb060
    1960:	400bb064 	.word	0x400bb064
    1964:	400bb06c 	.word	0x400bb06c
    1968:	400bb030 	.word	0x400bb030

0000196c <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    196c:	b430      	push	{r4, r5}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    196e:	4829      	ldr	r0, [pc, #164]	; (1a14 <analog_init+0xa8>)
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    1970:	4a29      	ldr	r2, [pc, #164]	; (1a18 <analog_init+0xac>)
	#endif

	if (analog_config_bits == 8) {
    1972:	4b2a      	ldr	r3, [pc, #168]	; (1a1c <analog_init+0xb0>)
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    1974:	4d2a      	ldr	r5, [pc, #168]	; (1a20 <analog_init+0xb4>)
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    1976:	2460      	movs	r4, #96	; 0x60
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    1978:	21e1      	movs	r1, #225	; 0xe1
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    197a:	7004      	strb	r4, [r0, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    197c:	7011      	strb	r1, [r2, #0]
	#endif

	if (analog_config_bits == 8) {
    197e:	781b      	ldrb	r3, [r3, #0]
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    1980:	4c28      	ldr	r4, [pc, #160]	; (1a24 <analog_init+0xb8>)
	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
    1982:	2b08      	cmp	r3, #8
    1984:	d030      	beq.n	19e8 <analog_init+0x7c>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    1986:	2b0a      	cmp	r3, #10
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    1988:	4827      	ldr	r0, [pc, #156]	; (1a28 <analog_init+0xbc>)
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    198a:	4928      	ldr	r1, [pc, #160]	; (1a2c <analog_init+0xc0>)
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    198c:	d037      	beq.n	19fe <analog_init+0x92>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    198e:	2b0c      	cmp	r3, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    1990:	bf0c      	ite	eq
    1992:	2235      	moveq	r2, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    1994:	225d      	movne	r2, #93	; 0x5d
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    1996:	2312      	movs	r3, #18
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    1998:	602a      	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    199a:	6023      	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    199c:	6002      	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    199e:	600b      	str	r3, [r1, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    19a0:	4b23      	ldr	r3, [pc, #140]	; (1a30 <analog_init+0xc4>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    19a2:	4924      	ldr	r1, [pc, #144]	; (1a34 <analog_init+0xc8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    19a4:	781b      	ldrb	r3, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    19a6:	4a24      	ldr	r2, [pc, #144]	; (1a38 <analog_init+0xcc>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    19a8:	b1bb      	cbz	r3, 19da <analog_init+0x6e>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    19aa:	2301      	movs	r3, #1
    19ac:	600b      	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    19ae:	6013      	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    19b0:	4b22      	ldr	r3, [pc, #136]	; (1a3c <analog_init+0xd0>)
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    19b2:	4923      	ldr	r1, [pc, #140]	; (1a40 <analog_init+0xd4>)
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    19b4:	781b      	ldrb	r3, [r3, #0]
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    19b6:	4a23      	ldr	r2, [pc, #140]	; (1a44 <analog_init+0xd8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
    19b8:	2b01      	cmp	r3, #1
    19ba:	d926      	bls.n	1a0a <analog_init+0x9e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    19bc:	2b04      	cmp	r3, #4
    19be:	d90f      	bls.n	19e0 <analog_init+0x74>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    19c0:	2b08      	cmp	r3, #8
    19c2:	d91e      	bls.n	1a02 <analog_init+0x96>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    19c4:	2b10      	cmp	r3, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    19c6:	bf94      	ite	ls
    19c8:	2386      	movls	r3, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    19ca:	2387      	movhi	r3, #135	; 0x87
    19cc:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    19ce:	6013      	str	r3, [r2, #0]
		#endif
	}
	calibrating = 1;
    19d0:	4b1d      	ldr	r3, [pc, #116]	; (1a48 <analog_init+0xdc>)
    19d2:	2201      	movs	r2, #1
    19d4:	701a      	strb	r2, [r3, #0]
}
    19d6:	bc30      	pop	{r4, r5}
    19d8:	4770      	bx	lr
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    19da:	600b      	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    19dc:	6013      	str	r3, [r2, #0]
    19de:	e7e7      	b.n	19b0 <analog_init+0x44>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    19e0:	2384      	movs	r3, #132	; 0x84
    19e2:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    19e4:	6013      	str	r3, [r2, #0]
    19e6:	e7f3      	b.n	19d0 <analog_init+0x64>

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    19e8:	f500 208e 	add.w	r0, r0, #290816	; 0x47000
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    19ec:	490f      	ldr	r1, [pc, #60]	; (1a2c <analog_init+0xc0>)

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    19ee:	3008      	adds	r0, #8
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    19f0:	2221      	movs	r2, #33	; 0x21
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    19f2:	2313      	movs	r3, #19
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    19f4:	602a      	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    19f6:	6023      	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    19f8:	6002      	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    19fa:	600b      	str	r3, [r1, #0]
    19fc:	e7d0      	b.n	19a0 <analog_init+0x34>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    19fe:	2239      	movs	r2, #57	; 0x39
    1a00:	e7f7      	b.n	19f2 <analog_init+0x86>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    1a02:	2385      	movs	r3, #133	; 0x85
    1a04:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    1a06:	6013      	str	r3, [r2, #0]
    1a08:	e7e2      	b.n	19d0 <analog_init+0x64>
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    1a0a:	2380      	movs	r3, #128	; 0x80
    1a0c:	600b      	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    1a0e:	6013      	str	r3, [r2, #0]
    1a10:	e7de      	b.n	19d0 <analog_init+0x64>
    1a12:	bf00      	nop
    1a14:	40074000 	.word	0x40074000
    1a18:	40074001 	.word	0x40074001
    1a1c:	1fff0818 	.word	0x1fff0818
    1a20:	4003b008 	.word	0x4003b008
    1a24:	4003b00c 	.word	0x4003b00c
    1a28:	400bb008 	.word	0x400bb008
    1a2c:	400bb00c 	.word	0x400bb00c
    1a30:	1fff1614 	.word	0x1fff1614
    1a34:	4003b020 	.word	0x4003b020
    1a38:	400bb020 	.word	0x400bb020
    1a3c:	1fff0819 	.word	0x1fff0819
    1a40:	4003b024 	.word	0x4003b024
    1a44:	400bb024 	.word	0x400bb024
    1a48:	1fff1611 	.word	0x1fff1611

00001a4c <analogReadRes>:

void analogReadRes(unsigned int bits)
{
	unsigned int config;

	if (bits >= 13) {
    1a4c:	280c      	cmp	r0, #12
	}
}


void analogReadRes(unsigned int bits)
{
    1a4e:	b430      	push	{r4, r5}
	unsigned int config;

	if (bits >= 13) {
    1a50:	d917      	bls.n	1a82 <analogReadRes+0x36>
    1a52:	2310      	movs	r3, #16
    1a54:	4298      	cmp	r0, r3
    1a56:	bf28      	it	cs
    1a58:	4618      	movcs	r0, r3
		if (bits > 16) bits = 16;
		config = 16;
    1a5a:	461c      	mov	r4, r3
		config = 10;
	} else {
		config = 8;
	}
	analog_right_shift = config - bits;
	if (config != analog_config_bits) {
    1a5c:	4a10      	ldr	r2, [pc, #64]	; (1aa0 <analogReadRes+0x54>)
	} else if (bits >= 9) {
		config = 10;
	} else {
		config = 8;
	}
	analog_right_shift = config - bits;
    1a5e:	4d11      	ldr	r5, [pc, #68]	; (1aa4 <analogReadRes+0x58>)
	if (config != analog_config_bits) {
    1a60:	7811      	ldrb	r1, [r2, #0]
	} else if (bits >= 9) {
		config = 10;
	} else {
		config = 8;
	}
	analog_right_shift = config - bits;
    1a62:	1a18      	subs	r0, r3, r0
	if (config != analog_config_bits) {
    1a64:	428c      	cmp	r4, r1
	} else if (bits >= 9) {
		config = 10;
	} else {
		config = 8;
	}
	analog_right_shift = config - bits;
    1a66:	7028      	strb	r0, [r5, #0]
	if (config != analog_config_bits) {
    1a68:	d018      	beq.n	1a9c <analogReadRes+0x50>
		analog_config_bits = config;
		if (calibrating) {
    1a6a:	490f      	ldr	r1, [pc, #60]	; (1aa8 <analogReadRes+0x5c>)
	} else {
		config = 8;
	}
	analog_right_shift = config - bits;
	if (config != analog_config_bits) {
		analog_config_bits = config;
    1a6c:	7013      	strb	r3, [r2, #0]
		if (calibrating) {
    1a6e:	780b      	ldrb	r3, [r1, #0]
    1a70:	b123      	cbz	r3, 1a7c <analogReadRes+0x30>
			ADC0_SC3 = 0; // cancel cal
    1a72:	490e      	ldr	r1, [pc, #56]	; (1aac <analogReadRes+0x60>)
			#ifdef HAS_KINETIS_ADC1
			ADC1_SC3 = 0;
    1a74:	4a0e      	ldr	r2, [pc, #56]	; (1ab0 <analogReadRes+0x64>)
	}
	analog_right_shift = config - bits;
	if (config != analog_config_bits) {
		analog_config_bits = config;
		if (calibrating) {
			ADC0_SC3 = 0; // cancel cal
    1a76:	2300      	movs	r3, #0
    1a78:	600b      	str	r3, [r1, #0]
			#ifdef HAS_KINETIS_ADC1
			ADC1_SC3 = 0;
    1a7a:	6013      	str	r3, [r2, #0]
			#endif
		}
		analog_init();
	}
}
    1a7c:	bc30      	pop	{r4, r5}
			ADC0_SC3 = 0; // cancel cal
			#ifdef HAS_KINETIS_ADC1
			ADC1_SC3 = 0;
			#endif
		}
		analog_init();
    1a7e:	f7ff bf75 	b.w	196c <analog_init>
	unsigned int config;

	if (bits >= 13) {
		if (bits > 16) bits = 16;
		config = 16;
	} else if (bits >= 11) {
    1a82:	280a      	cmp	r0, #10
    1a84:	d902      	bls.n	1a8c <analogReadRes+0x40>
    1a86:	230c      	movs	r3, #12
		config = 12;
    1a88:	461c      	mov	r4, r3
    1a8a:	e7e7      	b.n	1a5c <analogReadRes+0x10>
	} else if (bits >= 9) {
    1a8c:	2808      	cmp	r0, #8
    1a8e:	d902      	bls.n	1a96 <analogReadRes+0x4a>
    1a90:	230a      	movs	r3, #10
		config = 10;
    1a92:	461c      	mov	r4, r3
    1a94:	e7e2      	b.n	1a5c <analogReadRes+0x10>
    1a96:	2308      	movs	r3, #8
	} else {
		config = 8;
    1a98:	461c      	mov	r4, r3
    1a9a:	e7df      	b.n	1a5c <analogReadRes+0x10>
			ADC1_SC3 = 0;
			#endif
		}
		analog_init();
	}
}
    1a9c:	bc30      	pop	{r4, r5}
    1a9e:	4770      	bx	lr
    1aa0:	1fff0818 	.word	0x1fff0818
    1aa4:	1fff1610 	.word	0x1fff1610
    1aa8:	1fff1611 	.word	0x1fff1611
    1aac:	4003b024 	.word	0x4003b024
    1ab0:	400bb024 	.word	0x400bb024

00001ab4 <analogReadAveraging>:

void analogReadAveraging(unsigned int num)
{
    1ab4:	b510      	push	{r4, lr}

	if (calibrating) wait_for_cal();
    1ab6:	4b1a      	ldr	r3, [pc, #104]	; (1b20 <analogReadAveraging+0x6c>)
    1ab8:	781b      	ldrb	r3, [r3, #0]
		analog_init();
	}
}

void analogReadAveraging(unsigned int num)
{
    1aba:	4604      	mov	r4, r0

	if (calibrating) wait_for_cal();
    1abc:	b9bb      	cbnz	r3, 1aee <analogReadAveraging+0x3a>
	if (num <= 1) {
    1abe:	2c01      	cmp	r4, #1
    1ac0:	d919      	bls.n	1af6 <analogReadAveraging+0x42>
		num = 0;
		ADC0_SC3 = 0;
	} else if (num <= 4) {
    1ac2:	2c04      	cmp	r4, #4
		num = 4;
		ADC0_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    1ac4:	4b17      	ldr	r3, [pc, #92]	; (1b24 <analogReadAveraging+0x70>)
#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    1ac6:	4918      	ldr	r1, [pc, #96]	; (1b28 <analogReadAveraging+0x74>)

	if (calibrating) wait_for_cal();
	if (num <= 1) {
		num = 0;
		ADC0_SC3 = 0;
	} else if (num <= 4) {
    1ac8:	d90a      	bls.n	1ae0 <analogReadAveraging+0x2c>
		num = 4;
		ADC0_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(0);
#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(0);
#endif
	} else if (num <= 8) {
    1aca:	2c08      	cmp	r4, #8
    1acc:	d920      	bls.n	1b10 <analogReadAveraging+0x5c>
		num = 8;
		ADC0_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(1);
#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(1);
#endif
	} else if (num <= 16) {
    1ace:	2c10      	cmp	r4, #16
    1ad0:	d917      	bls.n	1b02 <analogReadAveraging+0x4e>
#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(2);
#endif
	} else {
		num = 32;
		ADC0_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    1ad2:	2207      	movs	r2, #7
    1ad4:	601a      	str	r2, [r3, #0]
#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    1ad6:	600a      	str	r2, [r1, #0]
#endif
	}
	analog_num_average = num;
    1ad8:	4a14      	ldr	r2, [pc, #80]	; (1b2c <analogReadAveraging+0x78>)
#endif
	} else {
		num = 32;
		ADC0_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(3);
#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    1ada:	2320      	movs	r3, #32
#endif
	}
	analog_num_average = num;
    1adc:	7013      	strb	r3, [r2, #0]
    1ade:	bd10      	pop	{r4, pc}
	if (num <= 1) {
		num = 0;
		ADC0_SC3 = 0;
	} else if (num <= 4) {
		num = 4;
		ADC0_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    1ae0:	2204      	movs	r2, #4
    1ae2:	601a      	str	r2, [r3, #0]
    1ae4:	4613      	mov	r3, r2
#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    1ae6:	600a      	str	r2, [r1, #0]
		ADC0_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(3);
#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(3);
#endif
	}
	analog_num_average = num;
    1ae8:	4a10      	ldr	r2, [pc, #64]	; (1b2c <analogReadAveraging+0x78>)
    1aea:	7013      	strb	r3, [r2, #0]
    1aec:	bd10      	pop	{r4, pc}
}

void analogReadAveraging(unsigned int num)
{

	if (calibrating) wait_for_cal();
    1aee:	f7ff fe9b 	bl	1828 <wait_for_cal>
	if (num <= 1) {
    1af2:	2c01      	cmp	r4, #1
    1af4:	d8e5      	bhi.n	1ac2 <analogReadAveraging+0xe>
		num = 0;
		ADC0_SC3 = 0;
    1af6:	4a0b      	ldr	r2, [pc, #44]	; (1b24 <analogReadAveraging+0x70>)
    1af8:	2300      	movs	r3, #0
    1afa:	6013      	str	r3, [r2, #0]
		ADC0_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(3);
#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(3);
#endif
	}
	analog_num_average = num;
    1afc:	4a0b      	ldr	r2, [pc, #44]	; (1b2c <analogReadAveraging+0x78>)
    1afe:	7013      	strb	r3, [r2, #0]
    1b00:	bd10      	pop	{r4, pc}
#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(1);
#endif
	} else if (num <= 16) {
		num = 16;
		ADC0_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    1b02:	2206      	movs	r2, #6
    1b04:	601a      	str	r2, [r3, #0]
#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    1b06:	600a      	str	r2, [r1, #0]
		ADC0_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(3);
#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(3);
#endif
	}
	analog_num_average = num;
    1b08:	4a08      	ldr	r2, [pc, #32]	; (1b2c <analogReadAveraging+0x78>)
    1b0a:	2310      	movs	r3, #16
    1b0c:	7013      	strb	r3, [r2, #0]
    1b0e:	bd10      	pop	{r4, pc}
#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(0);
#endif
	} else if (num <= 8) {
		num = 8;
		ADC0_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    1b10:	2205      	movs	r2, #5
    1b12:	601a      	str	r2, [r3, #0]
#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    1b14:	600a      	str	r2, [r1, #0]
		ADC0_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(3);
#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_AVGE + ADC_SC3_AVGS(3);
#endif
	}
	analog_num_average = num;
    1b16:	4a05      	ldr	r2, [pc, #20]	; (1b2c <analogReadAveraging+0x78>)
    1b18:	2308      	movs	r3, #8
    1b1a:	7013      	strb	r3, [r2, #0]
    1b1c:	bd10      	pop	{r4, pc}
    1b1e:	bf00      	nop
    1b20:	1fff1611 	.word	0x1fff1611
    1b24:	4003b024 	.word	0x4003b024
    1b28:	400bb024 	.word	0x400bb024
    1b2c:	1fff0819 	.word	0x1fff0819

00001b30 <analogRead>:
	uint8_t channel;

	//serial_phex(pin);
	//serial_print(" ");

	if (pin >= sizeof(pin2sc1a)) return 0;
    1b30:	2847      	cmp	r0, #71	; 0x47
    1b32:	d82f      	bhi.n	1b94 <analogRead+0x64>
	channel = pin2sc1a[pin];
    1b34:	4b33      	ldr	r3, [pc, #204]	; (1c04 <analogRead+0xd4>)
#ifdef HAS_KINETIS_ADC1
static volatile uint8_t analogReadBusyADC1 = 0;
#endif

int analogRead(uint8_t pin)
{
    1b36:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	//serial_phex(pin);
	//serial_print(" ");

	if (pin >= sizeof(pin2sc1a)) return 0;
	channel = pin2sc1a[pin];
    1b3a:	5c1e      	ldrb	r6, [r3, r0]
	if (channel == 255) return 0;
    1b3c:	2eff      	cmp	r6, #255	; 0xff
    1b3e:	d02b      	beq.n	1b98 <analogRead+0x68>

	if (calibrating) wait_for_cal();
    1b40:	4b31      	ldr	r3, [pc, #196]	; (1c08 <analogRead+0xd8>)
    1b42:	781b      	ldrb	r3, [r3, #0]
    1b44:	2b00      	cmp	r3, #0
    1b46:	d12a      	bne.n	1b9e <analogRead+0x6e>

#ifdef HAS_KINETIS_ADC1
	if (channel & 0x80) goto beginADC1;
    1b48:	0632      	lsls	r2, r6, #24
    1b4a:	d42c      	bmi.n	1ba6 <analogRead+0x76>
#endif

	__disable_irq();
    1b4c:	b672      	cpsid	i
    1b4e:	4d2f      	ldr	r5, [pc, #188]	; (1c0c <analogRead+0xdc>)
		channel &= 0x3F;
	} else {
		ADC0_CFG2 |= ADC_CFG2_MUXSEL;
	}
#endif
	ADC0_SC1A = channel;
    1b50:	4c2f      	ldr	r4, [pc, #188]	; (1c10 <analogRead+0xe0>)
	analogReadBusyADC0 = 1;
    1b52:	462f      	mov	r7, r5
    1b54:	2301      	movs	r3, #1
		channel &= 0x3F;
	} else {
		ADC0_CFG2 |= ADC_CFG2_MUXSEL;
	}
#endif
	ADC0_SC1A = channel;
    1b56:	6026      	str	r6, [r4, #0]
	analogReadBusyADC0 = 1;
    1b58:	702b      	strb	r3, [r5, #0]
	__enable_irq();
    1b5a:	b662      	cpsie	i
	while (1) {
		__disable_irq();
    1b5c:	b672      	cpsid	i
		if ((ADC0_SC1A & ADC_SC1_COCO)) {
    1b5e:	6823      	ldr	r3, [r4, #0]
    1b60:	061b      	lsls	r3, r3, #24
    1b62:	d40c      	bmi.n	1b7e <analogRead+0x4e>
			return result;
		}
		// detect if analogRead was used from an interrupt
		// if so, our analogRead got canceled, so it must
		// be restarted.
		if (!analogReadBusyADC0) goto startADC0;
    1b64:	783b      	ldrb	r3, [r7, #0]
    1b66:	b91b      	cbnz	r3, 1b70 <analogRead+0x40>
    1b68:	e7f4      	b.n	1b54 <analogRead+0x24>
    1b6a:	782b      	ldrb	r3, [r5, #0]
    1b6c:	2b00      	cmp	r3, #0
    1b6e:	d0f1      	beq.n	1b54 <analogRead+0x24>
		__enable_irq();
    1b70:	b662      	cpsie	i
		yield();
    1b72:	f002 f8c3 	bl	3cfc <yield>
#endif
	ADC0_SC1A = channel;
	analogReadBusyADC0 = 1;
	__enable_irq();
	while (1) {
		__disable_irq();
    1b76:	b672      	cpsid	i
		if ((ADC0_SC1A & ADC_SC1_COCO)) {
    1b78:	6823      	ldr	r3, [r4, #0]
    1b7a:	0618      	lsls	r0, r3, #24
    1b7c:	d5f5      	bpl.n	1b6a <analogRead+0x3a>
			result = ADC0_RA;
    1b7e:	4b25      	ldr	r3, [pc, #148]	; (1c14 <analogRead+0xe4>)
	analogReadBusyADC1 = 1;
	__enable_irq();
	while (1) {
		__disable_irq();
		if ((ADC1_SC1A & ADC_SC1_COCO)) {
			result = ADC1_RA;
    1b80:	681b      	ldr	r3, [r3, #0]
			analogReadBusyADC1 = 0;
    1b82:	2200      	movs	r2, #0
    1b84:	702a      	strb	r2, [r5, #0]
			__enable_irq();
    1b86:	b662      	cpsie	i
			result >>= analog_right_shift;
    1b88:	4a23      	ldr	r2, [pc, #140]	; (1c18 <analogRead+0xe8>)
    1b8a:	7810      	ldrb	r0, [r2, #0]
    1b8c:	fa43 f000 	asr.w	r0, r3, r0
			return result;
    1b90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint8_t channel;

	//serial_phex(pin);
	//serial_print(" ");

	if (pin >= sizeof(pin2sc1a)) return 0;
    1b94:	2000      	movs	r0, #0
		if (!analogReadBusyADC1) goto startADC1;
		__enable_irq();
		yield();
	}
#endif
}
    1b96:	4770      	bx	lr
	uint8_t channel;

	//serial_phex(pin);
	//serial_print(" ");

	if (pin >= sizeof(pin2sc1a)) return 0;
    1b98:	2000      	movs	r0, #0
		if (!analogReadBusyADC1) goto startADC1;
		__enable_irq();
		yield();
	}
#endif
}
    1b9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	if (pin >= sizeof(pin2sc1a)) return 0;
	channel = pin2sc1a[pin];
	if (channel == 255) return 0;

	if (calibrating) wait_for_cal();
    1b9e:	f7ff fe43 	bl	1828 <wait_for_cal>

#ifdef HAS_KINETIS_ADC1
	if (channel & 0x80) goto beginADC1;
    1ba2:	0632      	lsls	r2, r6, #24
    1ba4:	d5d2      	bpl.n	1b4c <analogRead+0x1c>
		yield();
	}

#ifdef HAS_KINETIS_ADC1
beginADC1:
	__disable_irq();
    1ba6:	b672      	cpsid	i
    1ba8:	4d1c      	ldr	r5, [pc, #112]	; (1c1c <analogRead+0xec>)
	//serial_print("startADC1\n");
	// ADC1_CFG2[MUXSEL] bit selects between ADCx_SEn channels a and b.
	if (channel & 0x40) {
		ADC1_CFG2 &= ~ADC_CFG2_MUXSEL;
	} else {
		ADC1_CFG2 |= ADC_CFG2_MUXSEL;
    1baa:	f8df 807c 	ldr.w	r8, [pc, #124]	; 1c28 <analogRead+0xf8>
	}
	ADC1_SC1A = channel & 0x3F;
    1bae:	4c1c      	ldr	r4, [pc, #112]	; (1c20 <analogRead+0xf0>)
    1bb0:	f006 0740 	and.w	r7, r6, #64	; 0x40
    1bb4:	b2ff      	uxtb	r7, r7
    1bb6:	f006 063f 	and.w	r6, r6, #63	; 0x3f
	__disable_irq();
startADC1:
	//serial_print("startADC1\n");
	// ADC1_CFG2[MUXSEL] bit selects between ADCx_SEn channels a and b.
	if (channel & 0x40) {
		ADC1_CFG2 &= ~ADC_CFG2_MUXSEL;
    1bba:	f8d8 3000 	ldr.w	r3, [r8]
beginADC1:
	__disable_irq();
startADC1:
	//serial_print("startADC1\n");
	// ADC1_CFG2[MUXSEL] bit selects between ADCx_SEn channels a and b.
	if (channel & 0x40) {
    1bbe:	b1df      	cbz	r7, 1bf8 <analogRead+0xc8>
		ADC1_CFG2 &= ~ADC_CFG2_MUXSEL;
    1bc0:	f023 0310 	bic.w	r3, r3, #16
    1bc4:	f8c8 3000 	str.w	r3, [r8]
	} else {
		ADC1_CFG2 |= ADC_CFG2_MUXSEL;
	}
	ADC1_SC1A = channel & 0x3F;
	analogReadBusyADC1 = 1;
    1bc8:	2301      	movs	r3, #1
	if (channel & 0x40) {
		ADC1_CFG2 &= ~ADC_CFG2_MUXSEL;
	} else {
		ADC1_CFG2 |= ADC_CFG2_MUXSEL;
	}
	ADC1_SC1A = channel & 0x3F;
    1bca:	6026      	str	r6, [r4, #0]
	analogReadBusyADC1 = 1;
    1bcc:	4a13      	ldr	r2, [pc, #76]	; (1c1c <analogRead+0xec>)
    1bce:	702b      	strb	r3, [r5, #0]
	__enable_irq();
    1bd0:	b662      	cpsie	i
	while (1) {
		__disable_irq();
    1bd2:	b672      	cpsid	i
		if ((ADC1_SC1A & ADC_SC1_COCO)) {
    1bd4:	6823      	ldr	r3, [r4, #0]
    1bd6:	0619      	lsls	r1, r3, #24
    1bd8:	d40c      	bmi.n	1bf4 <analogRead+0xc4>
			return result;
		}
		// detect if analogRead was used from an interrupt
		// if so, our analogRead got canceled, so it must
		// be restarted.
		if (!analogReadBusyADC1) goto startADC1;
    1bda:	7813      	ldrb	r3, [r2, #0]
    1bdc:	b91b      	cbnz	r3, 1be6 <analogRead+0xb6>
    1bde:	e7ec      	b.n	1bba <analogRead+0x8a>
    1be0:	782b      	ldrb	r3, [r5, #0]
    1be2:	2b00      	cmp	r3, #0
    1be4:	d0e9      	beq.n	1bba <analogRead+0x8a>
		__enable_irq();
    1be6:	b662      	cpsie	i
		yield();
    1be8:	f002 f888 	bl	3cfc <yield>
	}
	ADC1_SC1A = channel & 0x3F;
	analogReadBusyADC1 = 1;
	__enable_irq();
	while (1) {
		__disable_irq();
    1bec:	b672      	cpsid	i
		if ((ADC1_SC1A & ADC_SC1_COCO)) {
    1bee:	6823      	ldr	r3, [r4, #0]
    1bf0:	061b      	lsls	r3, r3, #24
    1bf2:	d5f5      	bpl.n	1be0 <analogRead+0xb0>
			result = ADC1_RA;
    1bf4:	4b0b      	ldr	r3, [pc, #44]	; (1c24 <analogRead+0xf4>)
    1bf6:	e7c3      	b.n	1b80 <analogRead+0x50>
	//serial_print("startADC1\n");
	// ADC1_CFG2[MUXSEL] bit selects between ADCx_SEn channels a and b.
	if (channel & 0x40) {
		ADC1_CFG2 &= ~ADC_CFG2_MUXSEL;
	} else {
		ADC1_CFG2 |= ADC_CFG2_MUXSEL;
    1bf8:	f043 0310 	orr.w	r3, r3, #16
    1bfc:	f8c8 3000 	str.w	r3, [r8]
    1c00:	e7e2      	b.n	1bc8 <analogRead+0x98>
    1c02:	bf00      	nop
    1c04:	00006920 	.word	0x00006920
    1c08:	1fff1611 	.word	0x1fff1611
    1c0c:	1fff1613 	.word	0x1fff1613
    1c10:	4003b000 	.word	0x4003b000
    1c14:	4003b010 	.word	0x4003b010
    1c18:	1fff1610 	.word	0x1fff1610
    1c1c:	1fff1612 	.word	0x1fff1612
    1c20:	400bb000 	.word	0x400bb000
    1c24:	400bb010 	.word	0x400bb010
    1c28:	400bb00c 	.word	0x400bb00c

00001c2c <analogWriteDAC0>:
typedef int16_t __attribute__((__may_alias__)) aliased_int16_t;

void analogWriteDAC0(int val)
{
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_DAC0;
    1c2c:	4a0a      	ldr	r2, [pc, #40]	; (1c58 <analogWriteDAC0+0x2c>)
	if (analog_reference_internal) {
    1c2e:	490b      	ldr	r1, [pc, #44]	; (1c5c <analogWriteDAC0+0x30>)
typedef int16_t __attribute__((__may_alias__)) aliased_int16_t;

void analogWriteDAC0(int val)
{
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_DAC0;
    1c30:	6813      	ldr	r3, [r2, #0]
    1c32:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    1c36:	6013      	str	r3, [r2, #0]
	if (analog_reference_internal) {
    1c38:	780b      	ldrb	r3, [r1, #0]
    1c3a:	b943      	cbnz	r3, 1c4e <analogWriteDAC0+0x22>
		DAC0_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC0_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
    1c3c:	4b08      	ldr	r3, [pc, #32]	; (1c60 <analogWriteDAC0+0x34>)
    1c3e:	22c0      	movs	r2, #192	; 0xc0
    1c40:	701a      	strb	r2, [r3, #0]
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095

	*(volatile aliased_int16_t *)&(DAC0_DAT0L) = val;
    1c42:	4b08      	ldr	r3, [pc, #32]	; (1c64 <analogWriteDAC0+0x38>)
	if (analog_reference_internal) {
		DAC0_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC0_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095
    1c44:	f380 000c 	usat	r0, #12, r0

	*(volatile aliased_int16_t *)&(DAC0_DAT0L) = val;
    1c48:	b200      	sxth	r0, r0
    1c4a:	8018      	strh	r0, [r3, #0]
    1c4c:	4770      	bx	lr
void analogWriteDAC0(int val)
{
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_DAC0;
	if (analog_reference_internal) {
		DAC0_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
    1c4e:	4b04      	ldr	r3, [pc, #16]	; (1c60 <analogWriteDAC0+0x34>)
    1c50:	2280      	movs	r2, #128	; 0x80
    1c52:	701a      	strb	r2, [r3, #0]
    1c54:	e7f5      	b.n	1c42 <analogWriteDAC0+0x16>
    1c56:	bf00      	nop
    1c58:	4004802c 	.word	0x4004802c
    1c5c:	1fff1614 	.word	0x1fff1614
    1c60:	400cc021 	.word	0x400cc021
    1c64:	400cc000 	.word	0x400cc000

00001c68 <analogWriteDAC1>:


#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
void analogWriteDAC1(int val)
{
	SIM_SCGC2 |= SIM_SCGC2_DAC1;
    1c68:	4a0a      	ldr	r2, [pc, #40]	; (1c94 <analogWriteDAC1+0x2c>)
	if (analog_reference_internal) {
    1c6a:	490b      	ldr	r1, [pc, #44]	; (1c98 <analogWriteDAC1+0x30>)


#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
void analogWriteDAC1(int val)
{
	SIM_SCGC2 |= SIM_SCGC2_DAC1;
    1c6c:	6813      	ldr	r3, [r2, #0]
    1c6e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    1c72:	6013      	str	r3, [r2, #0]
	if (analog_reference_internal) {
    1c74:	780b      	ldrb	r3, [r1, #0]
    1c76:	b943      	cbnz	r3, 1c8a <analogWriteDAC1+0x22>
		DAC1_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC1_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
    1c78:	4b08      	ldr	r3, [pc, #32]	; (1c9c <analogWriteDAC1+0x34>)
    1c7a:	22c0      	movs	r2, #192	; 0xc0
    1c7c:	701a      	strb	r2, [r3, #0]
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095

	*(volatile aliased_int16_t *)&(DAC1_DAT0L) = val;
    1c7e:	4b08      	ldr	r3, [pc, #32]	; (1ca0 <analogWriteDAC1+0x38>)
	if (analog_reference_internal) {
		DAC1_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
	} else {
		DAC1_C0 = DAC_C0_DACEN | DAC_C0_DACRFS; // 3.3V VDDA is DACREF_2
	}
	__asm__ ("usat    %[value], #12, %[value]\n\t" : [value] "+r" (val));  // 0 <= val <= 4095
    1c80:	f380 000c 	usat	r0, #12, r0

	*(volatile aliased_int16_t *)&(DAC1_DAT0L) = val;
    1c84:	b200      	sxth	r0, r0
    1c86:	8018      	strh	r0, [r3, #0]
    1c88:	4770      	bx	lr
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
void analogWriteDAC1(int val)
{
	SIM_SCGC2 |= SIM_SCGC2_DAC1;
	if (analog_reference_internal) {
		DAC1_C0 = DAC_C0_DACEN;  // 1.2V ref is DACREF_1
    1c8a:	4b04      	ldr	r3, [pc, #16]	; (1c9c <analogWriteDAC1+0x34>)
    1c8c:	2280      	movs	r2, #128	; 0x80
    1c8e:	701a      	strb	r2, [r3, #0]
    1c90:	e7f5      	b.n	1c7e <analogWriteDAC1+0x16>
    1c92:	bf00      	nop
    1c94:	4004802c 	.word	0x4004802c
    1c98:	1fff1614 	.word	0x1fff1614
    1c9c:	400cd021 	.word	0x400cd021
    1ca0:	400cd000 	.word	0x400cd000

00001ca4 <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    1ca4:	b508      	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    1ca6:	4c10      	ldr	r4, [pc, #64]	; (1ce8 <fault_isr+0x44>)
    1ca8:	e008      	b.n	1cbc <fault_isr+0x18>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    1caa:	6823      	ldr	r3, [r4, #0]
    1cac:	0559      	lsls	r1, r3, #21
    1cae:	d40d      	bmi.n	1ccc <fault_isr+0x28>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    1cb0:	6823      	ldr	r3, [r4, #0]
    1cb2:	051a      	lsls	r2, r3, #20
    1cb4:	d40f      	bmi.n	1cd6 <fault_isr+0x32>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    1cb6:	6823      	ldr	r3, [r4, #0]
    1cb8:	04db      	lsls	r3, r3, #19
    1cba:	d411      	bmi.n	1ce0 <fault_isr+0x3c>
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    1cbc:	6823      	ldr	r3, [r4, #0]
    1cbe:	0358      	lsls	r0, r3, #13
    1cc0:	d5f3      	bpl.n	1caa <fault_isr+0x6>
    1cc2:	f000 fda1 	bl	2808 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    1cc6:	6823      	ldr	r3, [r4, #0]
    1cc8:	0559      	lsls	r1, r3, #21
    1cca:	d5f1      	bpl.n	1cb0 <fault_isr+0xc>
    1ccc:	f002 f8ae 	bl	3e2c <uart0_status_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    1cd0:	6823      	ldr	r3, [r4, #0]
    1cd2:	051a      	lsls	r2, r3, #20
    1cd4:	d5ef      	bpl.n	1cb6 <fault_isr+0x12>
    1cd6:	f002 f93f 	bl	3f58 <uart1_status_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    1cda:	6823      	ldr	r3, [r4, #0]
    1cdc:	04db      	lsls	r3, r3, #19
    1cde:	d5ed      	bpl.n	1cbc <fault_isr+0x18>
    1ce0:	f002 f9d0 	bl	4084 <uart2_status_isr>
    1ce4:	e7ea      	b.n	1cbc <fault_isr+0x18>
    1ce6:	bf00      	nop
    1ce8:	40048034 	.word	0x40048034

00001cec <unused_isr>:
	}
}

void unused_isr(void)
{
    1cec:	b508      	push	{r3, lr}
	fault_isr();
    1cee:	f7ff ffd9 	bl	1ca4 <fault_isr>
    1cf2:	bf00      	nop

00001cf4 <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    1cf4:	4b01      	ldr	r3, [pc, #4]	; (1cfc <startup_early_hook+0x8>)
    1cf6:	2210      	movs	r2, #16
    1cf8:	801a      	strh	r2, [r3, #0]
    1cfa:	4770      	bx	lr
    1cfc:	40052000 	.word	0x40052000

00001d00 <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    1d00:	4770      	bx	lr
    1d02:	bf00      	nop

00001d04 <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    1d04:	4909      	ldr	r1, [pc, #36]	; (1d2c <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    1d06:	b508      	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    1d08:	680b      	ldr	r3, [r1, #0]
	if (incr != 0) {
    1d0a:	b130      	cbz	r0, 1d1a <_sbrk+0x16>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    1d0c:	466a      	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    1d0e:	4418      	add	r0, r3
    1d10:	f5a2 5200 	sub.w	r2, r2, #8192	; 0x2000
    1d14:	4290      	cmp	r0, r2
    1d16:	d202      	bcs.n	1d1e <_sbrk+0x1a>
			errno = ENOMEM;
			return (void *)-1;
		}
		__brkval = prev + incr;
    1d18:	6008      	str	r0, [r1, #0]
	}
	return prev;
    1d1a:	4618      	mov	r0, r3
}
    1d1c:	bd08      	pop	{r3, pc}

	prev = __brkval;
	if (incr != 0) {
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
		if (prev + incr >= stack - STACK_MARGIN) {
			errno = ENOMEM;
    1d1e:	f004 f8d5 	bl	5ecc <__errno>
    1d22:	230c      	movs	r3, #12
    1d24:	6003      	str	r3, [r0, #0]
			return (void *)-1;
    1d26:	f04f 30ff 	mov.w	r0, #4294967295
    1d2a:	bd08      	pop	{r3, pc}
    1d2c:	1fff081c 	.word	0x1fff081c

00001d30 <__cxa_pure_virtual>:
	while (1);
}

__attribute__((weak)) 
void __cxa_pure_virtual()
{
    1d30:	e7fe      	b.n	1d30 <__cxa_pure_virtual>
    1d32:	bf00      	nop

00001d34 <kinetis_hsrun_disable>:


#if defined(HAS_KINETIS_HSRUN) && F_CPU > 120000000
int kinetis_hsrun_disable(void)
{
	if (SMC_PMSTAT == SMC_PMSTAT_HSRUN) {
    1d34:	4a08      	ldr	r2, [pc, #32]	; (1d58 <kinetis_hsrun_disable+0x24>)
    1d36:	7813      	ldrb	r3, [r2, #0]
    1d38:	2b80      	cmp	r3, #128	; 0x80
    1d3a:	d001      	beq.n	1d40 <kinetis_hsrun_disable+0xc>
		// Then turn off HSRUN mode
		SMC_PMCTRL = SMC_PMCTRL_RUNM(0);
		while (SMC_PMSTAT == SMC_PMSTAT_HSRUN) ; // wait
		return 1;
	}
	return 0;
    1d3c:	2000      	movs	r0, #0
}
    1d3e:	4770      	bx	lr
		#elif F_CPU == 192000000 && F_BUS == 64000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
		#elif F_CPU == 192000000 && F_BUS == 96000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 7); // ok
		#elif F_CPU == 180000000 && F_BUS == 60000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
    1d40:	4906      	ldr	r1, [pc, #24]	; (1d5c <kinetis_hsrun_disable+0x28>)
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 5); // ok
		#else
			return 0;
		#endif
		// Then turn off HSRUN mode
		SMC_PMCTRL = SMC_PMCTRL_RUNM(0);
    1d42:	4b07      	ldr	r3, [pc, #28]	; (1d60 <kinetis_hsrun_disable+0x2c>)
		#elif F_CPU == 192000000 && F_BUS == 64000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
		#elif F_CPU == 192000000 && F_BUS == 96000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 7); // ok
		#elif F_CPU == 180000000 && F_BUS == 60000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(2, 2, 2, 8); // ok
    1d44:	4807      	ldr	r0, [pc, #28]	; (1d64 <kinetis_hsrun_disable+0x30>)
    1d46:	6008      	str	r0, [r1, #0]
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(1, 1, 1, 5); // ok
		#else
			return 0;
		#endif
		// Then turn off HSRUN mode
		SMC_PMCTRL = SMC_PMCTRL_RUNM(0);
    1d48:	2100      	movs	r1, #0
    1d4a:	7019      	strb	r1, [r3, #0]
		while (SMC_PMSTAT == SMC_PMSTAT_HSRUN) ; // wait
    1d4c:	7813      	ldrb	r3, [r2, #0]
    1d4e:	2b80      	cmp	r3, #128	; 0x80
    1d50:	d0fc      	beq.n	1d4c <kinetis_hsrun_disable+0x18>
		return 1;
    1d52:	2001      	movs	r0, #1
    1d54:	4770      	bx	lr
    1d56:	bf00      	nop
    1d58:	4007e003 	.word	0x4007e003
    1d5c:	40048044 	.word	0x40048044
    1d60:	4007e001 	.word	0x4007e001
    1d64:	22280000 	.word	0x22280000

00001d68 <kinetis_hsrun_enable>:
	return 0;
}

int kinetis_hsrun_enable(void)
{
	if (SMC_PMSTAT == SMC_PMSTAT_RUN) {
    1d68:	4a09      	ldr	r2, [pc, #36]	; (1d90 <kinetis_hsrun_enable+0x28>)
    1d6a:	7813      	ldrb	r3, [r2, #0]
    1d6c:	2b01      	cmp	r3, #1
    1d6e:	d001      	beq.n	1d74 <kinetis_hsrun_enable+0xc>
		#else
			return 0;
		#endif
		return 1;
	}
	return 0;
    1d70:	2000      	movs	r0, #0
}
    1d72:	4770      	bx	lr

int kinetis_hsrun_enable(void)
{
	if (SMC_PMSTAT == SMC_PMSTAT_RUN) {
		// Turn HSRUN mode on
		SMC_PMCTRL = SMC_PMCTRL_RUNM(3);
    1d74:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    1d78:	f503 23fc 	add.w	r3, r3, #516096	; 0x7e000
    1d7c:	2160      	movs	r1, #96	; 0x60
    1d7e:	7019      	strb	r1, [r3, #0]
		while (SMC_PMSTAT != SMC_PMSTAT_HSRUN) {;} // wait
    1d80:	7813      	ldrb	r3, [r2, #0]
    1d82:	2b80      	cmp	r3, #128	; 0x80
    1d84:	d1fc      	bne.n	1d80 <kinetis_hsrun_enable+0x18>
		#elif F_CPU == 192000000 && F_BUS == 64000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 2, 0, 6);
		#elif F_CPU == 192000000 && F_BUS == 96000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 1, 0, 6);
		#elif F_CPU == 180000000 && F_BUS == 60000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 2, 0, 6);
    1d86:	4b03      	ldr	r3, [pc, #12]	; (1d94 <kinetis_hsrun_enable+0x2c>)
    1d88:	4a03      	ldr	r2, [pc, #12]	; (1d98 <kinetis_hsrun_enable+0x30>)
    1d8a:	601a      	str	r2, [r3, #0]
		#elif F_CPU == 144000000 && F_BUS == 72000000
			SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIVS(0, 1, 0, 4);
		#else
			return 0;
		#endif
		return 1;
    1d8c:	2001      	movs	r0, #1
    1d8e:	4770      	bx	lr
    1d90:	4007e003 	.word	0x4007e003
    1d94:	40048044 	.word	0x40048044
    1d98:	02060000 	.word	0x02060000

00001d9c <dummy_isr>:
	{((volatile uint8_t *)&CORE_PIN26_PORTREG + (CORE_PIN26_BIT >> 3)), &CORE_PIN26_CONFIG, (1<<(CORE_PIN26_BIT & 7))}
};

#endif

static void dummy_isr() {};
    1d9c:	4770      	bx	lr
    1d9e:	bf00      	nop

00001da0 <digitalWrite.part.1>:



// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
    1da0:	b410      	push	{r4}
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
    1da2:	4b11      	ldr	r3, [pc, #68]	; (1de8 <digitalWrite.part.1+0x48>)
    1da4:	f853 2030 	ldr.w	r2, [r3, r0, lsl #3]
    1da8:	f892 4280 	ldrb.w	r4, [r2, #640]	; 0x280
    1dac:	b134      	cbz	r4, 1dbc <digitalWrite.part.1+0x1c>
		if (val) {
			*portSetRegister(pin) = 1;
    1dae:	2301      	movs	r3, #1
void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
    1db0:	b179      	cbz	r1, 1dd2 <digitalWrite.part.1+0x32>
			*portSetRegister(pin) = 1;
    1db2:	f882 3080 	strb.w	r3, [r2, #128]	; 0x80
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    1db6:	f85d 4b04 	ldr.w	r4, [sp], #4
    1dba:	4770      	bx	lr
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
    1dbc:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
    1dc0:	685b      	ldr	r3, [r3, #4]
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    1dc2:	681a      	ldr	r2, [r3, #0]
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
    1dc4:	b951      	cbnz	r1, 1ddc <digitalWrite.part.1+0x3c>
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
			//*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else {
			// TODO use bitband for atomic read-mod-write
			*config &= ~(PORT_PCR_PE);
    1dc6:	f022 0202 	bic.w	r2, r2, #2
    1dca:	601a      	str	r2, [r3, #0]
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    1dcc:	f85d 4b04 	ldr.w	r4, [sp], #4
    1dd0:	4770      	bx	lr
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
			*portSetRegister(pin) = 1;
		} else {
			*portClearRegister(pin) = 1;
    1dd2:	f882 3100 	strb.w	r3, [r2, #256]	; 0x100
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    1dd6:	f85d 4b04 	ldr.w	r4, [sp], #4
    1dda:	4770      	bx	lr
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    1ddc:	f042 0203 	orr.w	r2, r2, #3
    1de0:	601a      	str	r2, [r3, #0]
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    1de2:	f85d 4b04 	ldr.w	r4, [sp], #4
    1de6:	4770      	bx	lr
    1de8:	00006968 	.word	0x00006968

00001dec <pinMode.part.2>:
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    1dec:	4a1c      	ldr	r2, [pc, #112]	; (1e60 <pinMode.part.2+0x74>)
    1dee:	eb02 03c0 	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    1df2:	2901      	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    1df4:	685b      	ldr	r3, [r3, #4]

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    1df6:	d011      	beq.n	1e1c <pinMode.part.2+0x30>
    1df8:	2904      	cmp	r1, #4
    1dfa:	d01b      	beq.n	1e34 <pinMode.part.2+0x48>
		} else {
		    *config &= ~PORT_PCR_ODE;
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    1dfc:	f852 0030 	ldr.w	r0, [r2, r0, lsl #3]
    1e00:	2200      	movs	r2, #0
    1e02:	f880 2280 	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    1e06:	b129      	cbz	r1, 1e14 <pinMode.part.2+0x28>
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
    1e08:	2902      	cmp	r1, #2
    1e0a:	d020      	beq.n	1e4e <pinMode.part.2+0x62>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else if (mode == INPUT_PULLDOWN) {
    1e0c:	2903      	cmp	r1, #3
    1e0e:	d022      	beq.n	1e56 <pinMode.part.2+0x6a>
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    1e10:	601a      	str	r2, [r3, #0]
    1e12:	4770      	bx	lr
		*portModeRegister(pin) = 0;
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
    1e14:	f44f 7280 	mov.w	r2, #256	; 0x100
    1e18:	601a      	str	r2, [r3, #0]
    1e1a:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    1e1c:	f852 0030 	ldr.w	r0, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    1e20:	f44f 72a2 	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    1e24:	f880 1280 	strb.w	r1, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    1e28:	601a      	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    1e2a:	681a      	ldr	r2, [r3, #0]
    1e2c:	f022 0220 	bic.w	r2, r2, #32
    1e30:	601a      	str	r2, [r3, #0]
    1e32:	4770      	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    1e34:	f852 1030 	ldr.w	r1, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    1e38:	f44f 72a2 	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    1e3c:	2001      	movs	r0, #1
    1e3e:	f881 0280 	strb.w	r0, [r1, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    1e42:	601a      	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    1e44:	681a      	ldr	r2, [r3, #0]
    1e46:	f042 0220 	orr.w	r2, r2, #32
    1e4a:	601a      	str	r2, [r3, #0]
    1e4c:	4770      	bx	lr
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    1e4e:	f240 1203 	movw	r2, #259	; 0x103
    1e52:	601a      	str	r2, [r3, #0]
    1e54:	4770      	bx	lr
		} else if (mode == INPUT_PULLDOWN) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    1e56:	f44f 7281 	mov.w	r2, #258	; 0x102
    1e5a:	601a      	str	r2, [r3, #0]
    1e5c:	4770      	bx	lr
    1e5e:	bf00      	nop
    1e60:	00006968 	.word	0x00006968

00001e64 <attachInterrupt>:
void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
    1e64:	283f      	cmp	r0, #63	; 0x3f
    1e66:	d848      	bhi.n	1efa <attachInterrupt+0x96>
{
	_VectorsRam[irq + 16] = function;
}

void attachInterrupt(uint8_t pin, void (*function)(void), int mode)
{
    1e68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    1e6a:	2a04      	cmp	r2, #4
    1e6c:	d844      	bhi.n	1ef8 <attachInterrupt+0x94>
    1e6e:	e8df f002 	tbb	[pc, r2]
    1e72:	4b48      	.short	0x4b48
    1e74:	034e      	.short	0x034e
    1e76:	45          	.byte	0x45
    1e77:	00          	.byte	0x00
    1e78:	f44f 2610 	mov.w	r6, #589824	; 0x90000
	  case LOW:	mask = 0x08; break;
	  case HIGH:	mask = 0x0C; break;
	  default: return;
	}
	mask = (mask << 16) | 0x01000000;
	config = portConfigRegister(pin);
    1e7c:	4b2b      	ldr	r3, [pc, #172]	; (1f2c <attachInterrupt+0xc8>)
    1e7e:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
    1e82:	460d      	mov	r5, r1
    1e84:	685c      	ldr	r4, [r3, #4]
	if ((*config & 0x00000700) == 0) {
    1e86:	6821      	ldr	r1, [r4, #0]
    1e88:	f411 61e0 	ands.w	r1, r1, #1792	; 0x700
    1e8c:	d048      	beq.n	1f20 <attachInterrupt+0xbc>
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    1e8e:	4b28      	ldr	r3, [pc, #160]	; (1f30 <attachInterrupt+0xcc>)
    1e90:	4a28      	ldr	r2, [pc, #160]	; (1f34 <attachInterrupt+0xd0>)
    1e92:	4929      	ldr	r1, [pc, #164]	; (1f38 <attachInterrupt+0xd4>)
    1e94:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    1e98:	f104 4240 	add.w	r2, r4, #3221225472	; 0xc0000000
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    1e9c:	4827      	ldr	r0, [pc, #156]	; (1f3c <attachInterrupt+0xd8>)
    1e9e:	f8c3 1134 	str.w	r1, [r3, #308]	; 0x134

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    1ea2:	f5a2 2192 	sub.w	r1, r2, #299008	; 0x49000
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    1ea6:	4f26      	ldr	r7, [pc, #152]	; (1f40 <attachInterrupt+0xdc>)
    1ea8:	f8c3 0130 	str.w	r0, [r3, #304]	; 0x130

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    1eac:	297c      	cmp	r1, #124	; 0x7c
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    1eae:	4825      	ldr	r0, [pc, #148]	; (1f44 <attachInterrupt+0xe0>)
    1eb0:	f8c3 7138 	str.w	r7, [r3, #312]	; 0x138
    1eb4:	f8c3 013c 	str.w	r0, [r3, #316]	; 0x13c

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    1eb8:	d92c      	bls.n	1f14 <attachInterrupt+0xb0>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
    1eba:	f5a2 2394 	sub.w	r3, r2, #303104	; 0x4a000
    1ebe:	2b7c      	cmp	r3, #124	; 0x7c
    1ec0:	d92a      	bls.n	1f18 <attachInterrupt+0xb4>
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
    1ec2:	f5a2 2396 	sub.w	r3, r2, #307200	; 0x4b000
    1ec6:	2b7c      	cmp	r3, #124	; 0x7c
    1ec8:	d928      	bls.n	1f1c <attachInterrupt+0xb8>
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
    1eca:	f5a2 2398 	sub.w	r3, r2, #311296	; 0x4c000
    1ece:	2b7c      	cmp	r3, #124	; 0x7c
    1ed0:	d929      	bls.n	1f26 <attachInterrupt+0xc2>
	else if(&PORTE_PCR0 <= config && config <= &PORTE_PCR31) isr_table = isr_table_portE;
    1ed2:	f5a2 229a 	sub.w	r2, r2, #315392	; 0x4d000
    1ed6:	2a7c      	cmp	r2, #124	; 0x7c
    1ed8:	d827      	bhi.n	1f2a <attachInterrupt+0xc6>
    1eda:	481b      	ldr	r0, [pc, #108]	; (1f48 <attachInterrupt+0xe4>)
	attachInterruptVector(IRQ_PORTD, port_D_isr);
	attachInterruptVector(IRQ_PORTE, port_E_isr);
	voidFuncPtr* isr_table = getIsrTable(config);
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
    1edc:	b672      	cpsid	i
	cfg = *config;
    1ede:	6823      	ldr	r3, [r4, #0]
	cfg &= ~0x000F0000;		// disable any previous interrupt
    1ee0:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    1ee4:	f043 7280 	orr.w	r2, r3, #16777216	; 0x1000000
	*config = cfg;
	isr_table[pin_index] = function;	// set the function pointer
    1ee8:	f3c4 0184 	ubfx	r1, r4, #2, #5
	cfg |= mask;
    1eec:	4316      	orrs	r6, r2
	if(!isr_table) return;
	uint32_t pin_index = getPinIndex(config);
	__disable_irq();
	cfg = *config;
	cfg &= ~0x000F0000;		// disable any previous interrupt
	*config = cfg;
    1eee:	6023      	str	r3, [r4, #0]
	isr_table[pin_index] = function;	// set the function pointer
    1ef0:	f840 5021 	str.w	r5, [r0, r1, lsl #2]
	cfg |= mask;
	*config = cfg;			// enable the new interrupt
    1ef4:	6026      	str	r6, [r4, #0]
	__enable_irq();
    1ef6:	b662      	cpsie	i
    1ef8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1efa:	4770      	bx	lr
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    1efc:	f44f 2630 	mov.w	r6, #720896	; 0xb0000
    1f00:	e7bc      	b.n	1e7c <attachInterrupt+0x18>
	  case CHANGE:	mask = 0x0B; break;
	  case RISING:	mask = 0x09; break;
	  case FALLING:	mask = 0x0A; break;
	  case LOW:	mask = 0x08; break;
    1f02:	f44f 2600 	mov.w	r6, #524288	; 0x80000
    1f06:	e7b9      	b.n	1e7c <attachInterrupt+0x18>
	  case HIGH:	mask = 0x0C; break;
    1f08:	f44f 2640 	mov.w	r6, #786432	; 0xc0000
    1f0c:	e7b6      	b.n	1e7c <attachInterrupt+0x18>
{
	volatile uint32_t *config;
	uint32_t cfg, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	switch (mode) {
    1f0e:	f44f 2620 	mov.w	r6, #655360	; 0xa0000
    1f12:	e7b3      	b.n	1e7c <attachInterrupt+0x18>

// The Pin Config Register is used to look up the correct interrupt table
// for the corresponding port.
static inline voidFuncPtr* getIsrTable(volatile uint32_t *config) {
	voidFuncPtr* isr_table = NULL;
	if(&PORTA_PCR0 <= config && config <= &PORTA_PCR31) isr_table = isr_table_portA;
    1f14:	480d      	ldr	r0, [pc, #52]	; (1f4c <attachInterrupt+0xe8>)
    1f16:	e7e1      	b.n	1edc <attachInterrupt+0x78>
	else if(&PORTB_PCR0 <= config && config <= &PORTB_PCR31) isr_table = isr_table_portB;
    1f18:	480d      	ldr	r0, [pc, #52]	; (1f50 <attachInterrupt+0xec>)
    1f1a:	e7df      	b.n	1edc <attachInterrupt+0x78>
	else if(&PORTC_PCR0 <= config && config <= &PORTC_PCR31) isr_table = isr_table_portC;
    1f1c:	480d      	ldr	r0, [pc, #52]	; (1f54 <attachInterrupt+0xf0>)
    1f1e:	e7dd      	b.n	1edc <attachInterrupt+0x78>
    1f20:	f7ff ff64 	bl	1dec <pinMode.part.2>
    1f24:	e7b3      	b.n	1e8e <attachInterrupt+0x2a>
	else if(&PORTD_PCR0 <= config && config <= &PORTD_PCR31) isr_table = isr_table_portD;
    1f26:	480c      	ldr	r0, [pc, #48]	; (1f58 <attachInterrupt+0xf4>)
    1f28:	e7d8      	b.n	1edc <attachInterrupt+0x78>
    1f2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1f2c:	00006968 	.word	0x00006968
    1f30:	1fff0200 	.word	0x1fff0200
    1f34:	1fff07e1 	.word	0x1fff07e1
    1f38:	1fff0789 	.word	0x1fff0789
    1f3c:	1fff07b5 	.word	0x1fff07b5
    1f40:	1fff075d 	.word	0x1fff075d
    1f44:	1fff0731 	.word	0x1fff0731
    1f48:	1fff0968 	.word	0x1fff0968
    1f4c:	1fff0820 	.word	0x1fff0820
    1f50:	1fff0898 	.word	0x1fff0898
    1f54:	1fff08f8 	.word	0x1fff08f8
    1f58:	1fff0928 	.word	0x1fff0928

00001f5c <rtc_set>:
{
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
    1f5c:	b430      	push	{r4, r5}
	RTC_SR = 0;
    1f5e:	4b05      	ldr	r3, [pc, #20]	; (1f74 <rtc_set+0x18>)
	RTC_TPR = 0;
    1f60:	4d05      	ldr	r5, [pc, #20]	; (1f78 <rtc_set+0x1c>)
	RTC_TSR = t;
    1f62:	4c06      	ldr	r4, [pc, #24]	; (1f7c <rtc_set+0x20>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    1f64:	2200      	movs	r2, #0
	RTC_TPR = 0;
	RTC_TSR = t;
	RTC_SR = RTC_SR_TCE;
    1f66:	2110      	movs	r1, #16
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    1f68:	601a      	str	r2, [r3, #0]
	RTC_TPR = 0;
    1f6a:	602a      	str	r2, [r5, #0]
	RTC_TSR = t;
    1f6c:	6020      	str	r0, [r4, #0]
	RTC_SR = RTC_SR_TCE;
    1f6e:	6019      	str	r1, [r3, #0]
}
    1f70:	bc30      	pop	{r4, r5}
    1f72:	4770      	bx	lr
    1f74:	4003d014 	.word	0x4003d014
    1f78:	4003d004 	.word	0x4003d004
    1f7c:	4003d000 	.word	0x4003d000

00001f80 <analogWrite>:
// FTM is clocked by the bus clock, either 24 or 48 MHz
// input capture can be FTM1_CH0, CMP0 or CMP1 or USB start of frame
// 24 MHz with reload 49152 to match Arduino's speed = 488.28125 Hz

void analogWrite(uint8_t pin, int val)
{
    1f80:	b538      	push	{r3, r4, r5, lr}
		}
		analogWriteDAC0(val);
		return;
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
    1f82:	f1a0 0342 	sub.w	r3, r0, #66	; 0x42
    1f86:	2b01      	cmp	r3, #1
// FTM is clocked by the bus clock, either 24 or 48 MHz
// input capture can be FTM1_CH0, CMP0 or CMP1 or USB start of frame
// 24 MHz with reload 49152 to match Arduino's speed = 488.28125 Hz

void analogWrite(uint8_t pin, int val)
{
    1f88:	4604      	mov	r4, r0
		}
		analogWriteDAC0(val);
		return;
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
    1f8a:	d924      	bls.n	1fd6 <analogWrite+0x56>
		return;
	}
#endif

	max = 1 << analog_write_res;
	if (val <= 0) {
    1f8c:	2900      	cmp	r1, #0
    1f8e:	dd7a      	ble.n	2086 <analogWrite+0x106>
		else analogWriteDAC1(val);
		return;
	}
#endif

	max = 1 << analog_write_res;
    1f90:	4b99      	ldr	r3, [pc, #612]	; (21f8 <analogWrite+0x278>)
    1f92:	781b      	ldrb	r3, [r3, #0]
	if (val <= 0) {
		digitalWrite(pin, LOW);
		pinMode(pin, OUTPUT);	// TODO: implement OUTPUT_LOW
		return;
	} else if (val >= max) {
    1f94:	2501      	movs	r5, #1
    1f96:	fa05 f203 	lsl.w	r2, r5, r3
    1f9a:	428a      	cmp	r2, r1
    1f9c:	d802      	bhi.n	1fa4 <analogWrite+0x24>

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    1f9e:	283f      	cmp	r0, #63	; 0x3f
    1fa0:	d92c      	bls.n	1ffc <analogWrite+0x7c>
    1fa2:	bd38      	pop	{r3, r4, r5, pc}
	//serial_phex32(val);
	//serial_print("\n");
	//serial_print("analog_write_res = ");
	//serial_phex(analog_write_res);
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
    1fa4:	1ec2      	subs	r2, r0, #3
    1fa6:	2a01      	cmp	r2, #1
    1fa8:	d930      	bls.n	200c <analogWrite+0x8c>
		cval = ((uint32_t)val * (uint32_t)(FTM1_MOD + 1)) >> analog_write_res;
#if defined(FTM2_CH0_PIN)
	} else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
    1faa:	f1a0 021d 	sub.w	r2, r0, #29
    1fae:	2a01      	cmp	r2, #1
    1fb0:	d978      	bls.n	20a4 <analogWrite+0x124>
		cval = ((uint32_t)val * (uint32_t)(FTM2_MOD + 1)) >> analog_write_res;
#endif
#if defined(FTM3_CH0_PIN)
	} else if (pin == FTM3_CH0_PIN || pin == FTM3_CH1_PIN || pin == FTM3_CH2_PIN
    1fb2:	280e      	cmp	r0, #14
    1fb4:	d95b      	bls.n	206e <analogWrite+0xee>
	  || pin == FTM3_CH3_PIN || pin == FTM3_CH4_PIN || pin == FTM3_CH5_PIN
    1fb6:	f1a4 0223 	sub.w	r2, r4, #35	; 0x23
    1fba:	2a03      	cmp	r2, #3
    1fbc:	d95c      	bls.n	2078 <analogWrite+0xf8>
	  || pin == FTM3_CH6_PIN || pin == FTM3_CH7_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM3_MOD + 1)) >> analog_write_res;
#endif
#if defined(TPM1_CH0_PIN)
	} else if (pin == TPM1_CH0_PIN || pin == TPM1_CH1_PIN) {
    1fbe:	f1a4 0210 	sub.w	r2, r4, #16
    1fc2:	2a01      	cmp	r2, #1
		cval = ((uint32_t)val * (uint32_t)(TPM1_MOD + 1)) >> analog_write_res;
    1fc4:	bf94      	ite	ls
    1fc6:	4a8d      	ldrls	r2, [pc, #564]	; (21fc <analogWrite+0x27c>)
#endif
	} else {
		cval = ((uint32_t)val * (uint32_t)(FTM0_MOD + 1)) >> analog_write_res;
    1fc8:	4a8d      	ldrhi	r2, [pc, #564]	; (2200 <analogWrite+0x280>)
    1fca:	6812      	ldr	r2, [r2, #0]
    1fcc:	fb02 1201 	mla	r2, r2, r1, r1
    1fd0:	fa22 f303 	lsr.w	r3, r2, r3
    1fd4:	e020      	b.n	2018 <analogWrite+0x98>
		analogWriteDAC0(val);
		return;
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
		uint8_t res = analog_write_res;
    1fd6:	4b88      	ldr	r3, [pc, #544]	; (21f8 <analogWrite+0x278>)
    1fd8:	781b      	ldrb	r3, [r3, #0]
		if (res < 12) {
    1fda:	2b0b      	cmp	r3, #11
    1fdc:	d90a      	bls.n	1ff4 <analogWrite+0x74>
			val <<= 12 - res;
		} else if (res > 12) {
    1fde:	2b0c      	cmp	r3, #12
			val >>= res - 12;
    1fe0:	bf1c      	itt	ne
    1fe2:	3b0c      	subne	r3, #12
    1fe4:	4119      	asrne	r1, r3
		}
		if (pin == A21) analogWriteDAC0(val);
    1fe6:	2c42      	cmp	r4, #66	; 0x42
    1fe8:	4608      	mov	r0, r1
    1fea:	d057      	beq.n	209c <analogWrite+0x11c>
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    1fec:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			val <<= 12 - res;
		} else if (res > 12) {
			val >>= res - 12;
		}
		if (pin == A21) analogWriteDAC0(val);
		else analogWriteDAC1(val);
    1ff0:	f7ff be3a 	b.w	1c68 <analogWriteDAC1>
	}
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (pin == A21 || pin == A22) {
		uint8_t res = analog_write_res;
		if (res < 12) {
			val <<= 12 - res;
    1ff4:	f1c3 030c 	rsb	r3, r3, #12
    1ff8:	4099      	lsls	r1, r3
    1ffa:	e7f4      	b.n	1fe6 <analogWrite+0x66>
    1ffc:	4629      	mov	r1, r5
    1ffe:	f7ff fecf 	bl	1da0 <digitalWrite.part.1>
    2002:	4629      	mov	r1, r5
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    2004:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    2008:	f7ff bef0 	b.w	1dec <pinMode.part.2>
	//serial_print("\n");
	//serial_print("analog_write_res = ");
	//serial_phex(analog_write_res);
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM1_MOD + 1)) >> analog_write_res;
    200c:	4a7d      	ldr	r2, [pc, #500]	; (2204 <analogWrite+0x284>)
    200e:	6812      	ldr	r2, [r2, #0]
    2010:	fb02 1201 	mla	r2, r2, r1, r1
    2014:	fa22 f303 	lsr.w	r3, r2, r3
		cval = ((uint32_t)val * (uint32_t)(FTM0_MOD + 1)) >> analog_write_res;
	}
	//serial_print("cval = ");
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
    2018:	1ea2      	subs	r2, r4, #2
    201a:	2a24      	cmp	r2, #36	; 0x24
    201c:	f200 80e3 	bhi.w	21e6 <analogWrite+0x266>
    2020:	e8df f012 	tbh	[pc, r2, lsl #1]
    2024:	00d300da 	.word	0x00d300da
    2028:	00c500cc 	.word	0x00c500cc
    202c:	00b700be 	.word	0x00b700be
    2030:	00a900b0 	.word	0x00a900b0
    2034:	00e100a2 	.word	0x00e100a2
    2038:	00e100e1 	.word	0x00e100e1
    203c:	00e1009b 	.word	0x00e1009b
    2040:	008d0094 	.word	0x008d0094
    2044:	00e100e1 	.word	0x00e100e1
    2048:	007f0086 	.word	0x007f0086
    204c:	00710078 	.word	0x00710078
    2050:	00e100e1 	.word	0x00e100e1
    2054:	00e100e1 	.word	0x00e100e1
    2058:	006a00e1 	.word	0x006a00e1
    205c:	00e10063 	.word	0x00e10063
    2060:	00e100e1 	.word	0x00e100e1
    2064:	005c00e1 	.word	0x005c00e1
    2068:	004e0055 	.word	0x004e0055
    206c:	0047      	.short	0x0047
#if defined(FTM2_CH0_PIN)
	} else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM2_MOD + 1)) >> analog_write_res;
#endif
#if defined(FTM3_CH0_PIN)
	} else if (pin == FTM3_CH0_PIN || pin == FTM3_CH1_PIN || pin == FTM3_CH2_PIN
    206e:	f244 1284 	movw	r2, #16772	; 0x4184
    2072:	40c2      	lsrs	r2, r0
    2074:	07d2      	lsls	r2, r2, #31
    2076:	d59e      	bpl.n	1fb6 <analogWrite+0x36>
	  || pin == FTM3_CH3_PIN || pin == FTM3_CH4_PIN || pin == FTM3_CH5_PIN
	  || pin == FTM3_CH6_PIN || pin == FTM3_CH7_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM3_MOD + 1)) >> analog_write_res;
    2078:	4a63      	ldr	r2, [pc, #396]	; (2208 <analogWrite+0x288>)
    207a:	6812      	ldr	r2, [r2, #0]
    207c:	fb02 1201 	mla	r2, r2, r1, r1
    2080:	fa22 f303 	lsr.w	r3, r2, r3
    2084:	e7c8      	b.n	2018 <analogWrite+0x98>

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    2086:	283f      	cmp	r0, #63	; 0x3f
    2088:	d88b      	bhi.n	1fa2 <analogWrite+0x22>
    208a:	2100      	movs	r1, #0
    208c:	f7ff fe88 	bl	1da0 <digitalWrite.part.1>
    2090:	4620      	mov	r0, r4
    2092:	2101      	movs	r1, #1
#endif
	  default:
		digitalWrite(pin, (val > 127) ? HIGH : LOW);
		pinMode(pin, OUTPUT);
	}
}
    2094:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    2098:	f7ff bea8 	b.w	1dec <pinMode.part.2>
    209c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if (res < 12) {
			val <<= 12 - res;
		} else if (res > 12) {
			val >>= res - 12;
		}
		if (pin == A21) analogWriteDAC0(val);
    20a0:	f7ff bdc4 	b.w	1c2c <analogWriteDAC0>
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM1_MOD + 1)) >> analog_write_res;
#if defined(FTM2_CH0_PIN)
	} else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
		cval = ((uint32_t)val * (uint32_t)(FTM2_MOD + 1)) >> analog_write_res;
    20a4:	4a59      	ldr	r2, [pc, #356]	; (220c <analogWrite+0x28c>)
    20a6:	6812      	ldr	r2, [r2, #0]
    20a8:	fb02 1201 	mla	r2, r2, r1, r1
    20ac:	fa22 f303 	lsr.w	r3, r2, r3
    20b0:	e7b2      	b.n	2018 <analogWrite+0x98>
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH7_PIN
	  case FTM3_CH7_PIN:
		FTM3_C7V = cval;
    20b2:	4957      	ldr	r1, [pc, #348]	; (2210 <analogWrite+0x290>)
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    20b4:	4a57      	ldr	r2, [pc, #348]	; (2214 <analogWrite+0x294>)
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH7_PIN
	  case FTM3_CH7_PIN:
		FTM3_C7V = cval;
    20b6:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    20b8:	f44f 7351 	mov.w	r3, #836	; 0x344
    20bc:	6013      	str	r3, [r2, #0]
		break;
    20be:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH6_PIN
	  case FTM3_CH6_PIN:
		FTM3_C6V = cval;
    20c0:	4955      	ldr	r1, [pc, #340]	; (2218 <analogWrite+0x298>)
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    20c2:	4a56      	ldr	r2, [pc, #344]	; (221c <analogWrite+0x29c>)
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH6_PIN
	  case FTM3_CH6_PIN:
		FTM3_C6V = cval;
    20c4:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH6_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    20c6:	f44f 7351 	mov.w	r3, #836	; 0x344
    20ca:	6013      	str	r3, [r2, #0]
		break;
    20cc:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH5_PIN
	  case FTM3_CH5_PIN:
		FTM3_C5V = cval;
    20ce:	4954      	ldr	r1, [pc, #336]	; (2220 <analogWrite+0x2a0>)
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    20d0:	4a54      	ldr	r2, [pc, #336]	; (2224 <analogWrite+0x2a4>)
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH5_PIN
	  case FTM3_CH5_PIN:
		FTM3_C5V = cval;
    20d2:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH5_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    20d4:	f44f 7351 	mov.w	r3, #836	; 0x344
    20d8:	6013      	str	r3, [r2, #0]
		break;
    20da:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH4_PIN
	  case FTM3_CH4_PIN:
		FTM3_C4V = cval;
    20dc:	4952      	ldr	r1, [pc, #328]	; (2228 <analogWrite+0x2a8>)
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    20de:	4a53      	ldr	r2, [pc, #332]	; (222c <analogWrite+0x2ac>)
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH4_PIN
	  case FTM3_CH4_PIN:
		FTM3_C4V = cval;
    20e0:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH4_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    20e2:	f44f 7351 	mov.w	r3, #836	; 0x344
    20e6:	6013      	str	r3, [r2, #0]
		break;
    20e8:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH1_PIN
	  case FTM2_CH1_PIN: // PTB19, FTM1_CH1
		FTM2_C1V = cval;
    20ea:	4951      	ldr	r1, [pc, #324]	; (2230 <analogWrite+0x2b0>)
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    20ec:	4a51      	ldr	r2, [pc, #324]	; (2234 <analogWrite+0x2b4>)
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH1_PIN
	  case FTM2_CH1_PIN: // PTB19, FTM1_CH1
		FTM2_C1V = cval;
    20ee:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    20f0:	f44f 7351 	mov.w	r3, #836	; 0x344
    20f4:	6013      	str	r3, [r2, #0]
		break;
    20f6:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH0_PIN
	  case FTM2_CH0_PIN: // PTB18, FTM2_CH0
		FTM2_C0V = cval;
    20f8:	494f      	ldr	r1, [pc, #316]	; (2238 <analogWrite+0x2b8>)
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    20fa:	4a50      	ldr	r2, [pc, #320]	; (223c <analogWrite+0x2bc>)
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM2_CH0_PIN
	  case FTM2_CH0_PIN: // PTB18, FTM2_CH0
		FTM2_C0V = cval;
    20fc:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM2_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    20fe:	f44f 7351 	mov.w	r3, #836	; 0x344
    2102:	6013      	str	r3, [r2, #0]
		break;
    2104:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH1_PIN
	  case FTM0_CH1_PIN: // PTC2, FTM0_CH1
		FTM0_C1V = cval;
    2106:	494e      	ldr	r1, [pc, #312]	; (2240 <analogWrite+0x2c0>)
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    2108:	4a4e      	ldr	r2, [pc, #312]	; (2244 <analogWrite+0x2c4>)
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH1_PIN
	  case FTM0_CH1_PIN: // PTC2, FTM0_CH1
		FTM0_C1V = cval;
    210a:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    210c:	f240 4344 	movw	r3, #1092	; 0x444
    2110:	6013      	str	r3, [r2, #0]
		break;
    2112:	bd38      	pop	{r3, r4, r5, pc}
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
#ifdef FTM0_CH0_PIN
	  case FTM0_CH0_PIN: // PTC1, FTM0_CH0
		FTM0_C0V = cval;
    2114:	494c      	ldr	r1, [pc, #304]	; (2248 <analogWrite+0x2c8>)
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    2116:	4a4d      	ldr	r2, [pc, #308]	; (224c <analogWrite+0x2cc>)
	//serial_phex32(cval);
	//serial_print("\n");
	switch (pin) {
#ifdef FTM0_CH0_PIN
	  case FTM0_CH0_PIN: // PTC1, FTM0_CH0
		FTM0_C0V = cval;
    2118:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    211a:	f240 4344 	movw	r3, #1092	; 0x444
    211e:	6013      	str	r3, [r2, #0]
		break;
    2120:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH6_PIN
	  case FTM0_CH6_PIN: // PTD6, FTM0_CH6
		FTM0_C6V = cval;
    2122:	494b      	ldr	r1, [pc, #300]	; (2250 <analogWrite+0x2d0>)
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    2124:	4a4b      	ldr	r2, [pc, #300]	; (2254 <analogWrite+0x2d4>)
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH6_PIN
	  case FTM0_CH6_PIN: // PTD6, FTM0_CH6
		FTM0_C6V = cval;
    2126:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    2128:	f240 4344 	movw	r3, #1092	; 0x444
    212c:	6013      	str	r3, [r2, #0]
		break;
    212e:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH5_PIN
	  case FTM0_CH5_PIN: // PTD5, FTM0_CH5
		FTM0_C5V = cval;
    2130:	4949      	ldr	r1, [pc, #292]	; (2258 <analogWrite+0x2d8>)
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    2132:	4a4a      	ldr	r2, [pc, #296]	; (225c <analogWrite+0x2dc>)
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH5_PIN
	  case FTM0_CH5_PIN: // PTD5, FTM0_CH5
		FTM0_C5V = cval;
    2134:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH5_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    2136:	f240 4344 	movw	r3, #1092	; 0x444
    213a:	6013      	str	r3, [r2, #0]
		break;
    213c:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH1_PIN
	  case TPM1_CH1_PIN:
		TPM1_C1V = cval;
    213e:	4948      	ldr	r1, [pc, #288]	; (2260 <analogWrite+0x2e0>)
		FTM_PINCFG(TPM1_CH1_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    2140:	4a48      	ldr	r2, [pc, #288]	; (2264 <analogWrite+0x2e4>)
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH1_PIN
	  case TPM1_CH1_PIN:
		TPM1_C1V = cval;
    2142:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(TPM1_CH1_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    2144:	f240 6344 	movw	r3, #1604	; 0x644
    2148:	6013      	str	r3, [r2, #0]
		break;
    214a:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH0_PIN
	  case TPM1_CH0_PIN:
		TPM1_C0V = cval;
    214c:	4946      	ldr	r1, [pc, #280]	; (2268 <analogWrite+0x2e8>)
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    214e:	4a47      	ldr	r2, [pc, #284]	; (226c <analogWrite+0x2ec>)
		FTM_PINCFG(FTM3_CH7_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef TPM1_CH0_PIN
	  case TPM1_CH0_PIN:
		TPM1_C0V = cval;
    2150:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(TPM1_CH0_PIN) = PORT_PCR_MUX(6) | PORT_PCR_DSE | PORT_PCR_SRE;
    2152:	f240 6344 	movw	r3, #1604	; 0x644
    2156:	6013      	str	r3, [r2, #0]
		break;
    2158:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH1_PIN
	  case FTM3_CH1_PIN:
		FTM3_C1V = cval;
    215a:	4945      	ldr	r1, [pc, #276]	; (2270 <analogWrite+0x2f0>)
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    215c:	4a45      	ldr	r2, [pc, #276]	; (2274 <analogWrite+0x2f4>)
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH1_PIN
	  case FTM3_CH1_PIN:
		FTM3_C1V = cval;
    215e:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    2160:	f240 4344 	movw	r3, #1092	; 0x444
    2164:	6013      	str	r3, [r2, #0]
		break;
    2166:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH3_PIN
	  case FTM0_CH3_PIN: // PTC4, FTM0_CH3
		FTM0_C3V = cval;
    2168:	4943      	ldr	r1, [pc, #268]	; (2278 <analogWrite+0x2f8>)
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    216a:	4a44      	ldr	r2, [pc, #272]	; (227c <analogWrite+0x2fc>)
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH3_PIN
	  case FTM0_CH3_PIN: // PTC4, FTM0_CH3
		FTM0_C3V = cval;
    216c:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    216e:	f240 4344 	movw	r3, #1092	; 0x444
    2172:	6013      	str	r3, [r2, #0]
		break;
    2174:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH2_PIN
	  case FTM0_CH2_PIN: // PTC3, FTM0_CH2
		FTM0_C2V = cval;
    2176:	4942      	ldr	r1, [pc, #264]	; (2280 <analogWrite+0x300>)
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    2178:	4a42      	ldr	r2, [pc, #264]	; (2284 <analogWrite+0x304>)
		FTM_PINCFG(FTM0_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH2_PIN
	  case FTM0_CH2_PIN: // PTC3, FTM0_CH2
		FTM0_C2V = cval;
    217a:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    217c:	f240 4344 	movw	r3, #1092	; 0x444
    2180:	6013      	str	r3, [r2, #0]
		break;
    2182:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH3_PIN
	  case FTM3_CH3_PIN:
		FTM3_C3V = cval;
    2184:	4940      	ldr	r1, [pc, #256]	; (2288 <analogWrite+0x308>)
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    2186:	4a41      	ldr	r2, [pc, #260]	; (228c <analogWrite+0x30c>)
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH3_PIN
	  case FTM3_CH3_PIN:
		FTM3_C3V = cval;
    2188:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    218a:	f240 4344 	movw	r3, #1092	; 0x444
    218e:	6013      	str	r3, [r2, #0]
		break;
    2190:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH2_PIN
	  case FTM3_CH2_PIN:
		FTM3_C2V = cval;
    2192:	493f      	ldr	r1, [pc, #252]	; (2290 <analogWrite+0x310>)
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    2194:	4a3f      	ldr	r2, [pc, #252]	; (2294 <analogWrite+0x314>)
		FTM_PINCFG(FTM3_CH1_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH2_PIN
	  case FTM3_CH2_PIN:
		FTM3_C2V = cval;
    2196:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH2_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    2198:	f240 4344 	movw	r3, #1092	; 0x444
    219c:	6013      	str	r3, [r2, #0]
		break;
    219e:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH4_PIN
	  case FTM0_CH4_PIN: // PTD4, FTM0_CH4
		FTM0_C4V = cval;
    21a0:	493d      	ldr	r1, [pc, #244]	; (2298 <analogWrite+0x318>)
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    21a2:	4a3e      	ldr	r2, [pc, #248]	; (229c <analogWrite+0x31c>)
		FTM_PINCFG(FTM0_CH3_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH4_PIN
	  case FTM0_CH4_PIN: // PTD4, FTM0_CH4
		FTM0_C4V = cval;
    21a4:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH4_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    21a6:	f240 4344 	movw	r3, #1092	; 0x444
    21aa:	6013      	str	r3, [r2, #0]
		break;
    21ac:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH7_PIN
	  case FTM0_CH7_PIN: // PTD7, FTM0_CH7
		FTM0_C7V = cval;
    21ae:	493c      	ldr	r1, [pc, #240]	; (22a0 <analogWrite+0x320>)
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    21b0:	4a3c      	ldr	r2, [pc, #240]	; (22a4 <analogWrite+0x324>)
		FTM_PINCFG(FTM0_CH6_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM0_CH7_PIN
	  case FTM0_CH7_PIN: // PTD7, FTM0_CH7
		FTM0_C7V = cval;
    21b2:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    21b4:	f240 4344 	movw	r3, #1092	; 0x444
    21b8:	6013      	str	r3, [r2, #0]
		break;
    21ba:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH1_PIN
	  case FTM1_CH1_PIN: // PTA13, FTM1_CH1
		FTM1_C1V = cval;
    21bc:	493a      	ldr	r1, [pc, #232]	; (22a8 <analogWrite+0x328>)
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    21be:	4a3b      	ldr	r2, [pc, #236]	; (22ac <analogWrite+0x32c>)
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH1_PIN
	  case FTM1_CH1_PIN: // PTA13, FTM1_CH1
		FTM1_C1V = cval;
    21c0:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM1_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    21c2:	f44f 7351 	mov.w	r3, #836	; 0x344
    21c6:	6013      	str	r3, [r2, #0]
		break;
    21c8:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH0_PIN
	  case FTM1_CH0_PIN: // PTA12, FTM1_CH0
		FTM1_C0V = cval;
    21ca:	4939      	ldr	r1, [pc, #228]	; (22b0 <analogWrite+0x330>)
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    21cc:	4a39      	ldr	r2, [pc, #228]	; (22b4 <analogWrite+0x334>)
		FTM_PINCFG(FTM0_CH7_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM1_CH0_PIN
	  case FTM1_CH0_PIN: // PTA12, FTM1_CH0
		FTM1_C0V = cval;
    21ce:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM1_CH0_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
    21d0:	f44f 7351 	mov.w	r3, #836	; 0x344
    21d4:	6013      	str	r3, [r2, #0]
		break;
    21d6:	bd38      	pop	{r3, r4, r5, pc}
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH0_PIN
	  case FTM3_CH0_PIN:
		FTM3_C0V = cval;
    21d8:	4937      	ldr	r1, [pc, #220]	; (22b8 <analogWrite+0x338>)
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    21da:	4a38      	ldr	r2, [pc, #224]	; (22bc <analogWrite+0x33c>)
		FTM_PINCFG(FTM2_CH1_PIN) = PORT_PCR_MUX(3) | PORT_PCR_DSE | PORT_PCR_SRE;
		break;
#endif
#ifdef FTM3_CH0_PIN
	  case FTM3_CH0_PIN:
		FTM3_C0V = cval;
    21dc:	600b      	str	r3, [r1, #0]
		FTM_PINCFG(FTM3_CH0_PIN) = PORT_PCR_MUX(4) | PORT_PCR_DSE | PORT_PCR_SRE;
    21de:	f240 4344 	movw	r3, #1092	; 0x444
    21e2:	6013      	str	r3, [r2, #0]
		break;
    21e4:	bd38      	pop	{r3, r4, r5, pc}

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    21e6:	2c3f      	cmp	r4, #63	; 0x3f
    21e8:	f63f aedb 	bhi.w	1fa2 <analogWrite+0x22>
    21ec:	297f      	cmp	r1, #127	; 0x7f
    21ee:	bfd4      	ite	le
    21f0:	2100      	movle	r1, #0
    21f2:	2101      	movgt	r1, #1
    21f4:	4620      	mov	r0, r4
    21f6:	e749      	b.n	208c <analogWrite+0x10c>
    21f8:	1fff09d4 	.word	0x1fff09d4
    21fc:	400c9008 	.word	0x400c9008
    2200:	40038008 	.word	0x40038008
    2204:	40039008 	.word	0x40039008
    2208:	400b9008 	.word	0x400b9008
    220c:	400b8008 	.word	0x400b8008
    2210:	400b9048 	.word	0x400b9048
    2214:	4004b02c 	.word	0x4004b02c
    2218:	400b9040 	.word	0x400b9040
    221c:	4004b028 	.word	0x4004b028
    2220:	400b9038 	.word	0x400b9038
    2224:	4004b024 	.word	0x4004b024
    2228:	400b9030 	.word	0x400b9030
    222c:	4004b020 	.word	0x4004b020
    2230:	400b8018 	.word	0x400b8018
    2234:	4004a04c 	.word	0x4004a04c
    2238:	400b8010 	.word	0x400b8010
    223c:	4004a048 	.word	0x4004a048
    2240:	40038018 	.word	0x40038018
    2244:	4004b008 	.word	0x4004b008
    2248:	40038010 	.word	0x40038010
    224c:	4004b004 	.word	0x4004b004
    2250:	40038040 	.word	0x40038040
    2254:	4004c018 	.word	0x4004c018
    2258:	40038038 	.word	0x40038038
    225c:	4004c014 	.word	0x4004c014
    2260:	400c9018 	.word	0x400c9018
    2264:	4004a004 	.word	0x4004a004
    2268:	400c9010 	.word	0x400c9010
    226c:	4004a000 	.word	0x4004a000
    2270:	400b9018 	.word	0x400b9018
    2274:	4004c004 	.word	0x4004c004
    2278:	40038028 	.word	0x40038028
    227c:	4004b010 	.word	0x4004b010
    2280:	40038020 	.word	0x40038020
    2284:	4004b00c 	.word	0x4004b00c
    2288:	400b9028 	.word	0x400b9028
    228c:	4004c00c 	.word	0x4004c00c
    2290:	400b9020 	.word	0x400b9020
    2294:	4004c008 	.word	0x4004c008
    2298:	40038030 	.word	0x40038030
    229c:	4004c010 	.word	0x4004c010
    22a0:	40038048 	.word	0x40038048
    22a4:	4004c01c 	.word	0x4004c01c
    22a8:	40039018 	.word	0x40039018
    22ac:	40049034 	.word	0x40049034
    22b0:	40039010 	.word	0x40039010
    22b4:	40049030 	.word	0x40049030
    22b8:	400b9010 	.word	0x400b9010
    22bc:	4004c000 	.word	0x4004c000

000022c0 <analogWriteRes>:


uint32_t analogWriteRes(uint32_t bits)
{
	uint32_t prior_res;
	if (bits < 1) {
    22c0:	b138      	cbz	r0, 22d2 <analogWriteRes+0x12>
    22c2:	2810      	cmp	r0, #16
    22c4:	bf28      	it	cs
    22c6:	2010      	movcs	r0, #16
		bits = 1;
	} else if (bits > 16) {
		bits = 16;
	}
	prior_res = analog_write_res;
    22c8:	4a04      	ldr	r2, [pc, #16]	; (22dc <analogWriteRes+0x1c>)
    22ca:	b2c3      	uxtb	r3, r0
    22cc:	7810      	ldrb	r0, [r2, #0]
	analog_write_res = bits;
    22ce:	7013      	strb	r3, [r2, #0]
	return prior_res;
}
    22d0:	4770      	bx	lr
	if (bits < 1) {
		bits = 1;
	} else if (bits > 16) {
		bits = 16;
	}
	prior_res = analog_write_res;
    22d2:	4a02      	ldr	r2, [pc, #8]	; (22dc <analogWriteRes+0x1c>)
    22d4:	2301      	movs	r3, #1
    22d6:	7810      	ldrb	r0, [r2, #0]
	analog_write_res = bits;
    22d8:	7013      	strb	r3, [r2, #0]
	return prior_res;
}
    22da:	4770      	bx	lr
    22dc:	1fff09d4 	.word	0x1fff09d4

000022e0 <analogWriteFrequency>:
	//serial_print(", freq = ");
	//serial_phex32((uint32_t)frequency);
	//serial_print("\n");

#ifdef TPM1_CH0_PIN
	if (pin == TPM1_CH0_PIN || pin == TPM1_CH1_PIN) {
    22e0:	f1a0 0110 	sub.w	r1, r0, #16
    22e4:	b2c9      	uxtb	r1, r1
    22e6:	2901      	cmp	r1, #1
	return prior_res;
}


void analogWriteFrequency(uint8_t pin, float frequency)
{
    22e8:	b470      	push	{r4, r5, r6}
	//serial_print(", freq = ");
	//serial_phex32((uint32_t)frequency);
	//serial_print("\n");

#ifdef TPM1_CH0_PIN
	if (pin == TPM1_CH0_PIN || pin == TPM1_CH1_PIN) {
    22ea:	d95b      	bls.n	23a4 <analogWriteFrequency+0xc4>
#if defined(__MKL26Z64__)
	// Teensy LC does not support slow clock source (ftmClockSource = 2)
	ftmClockSource = 1; 	// Use default F_TIMER clock source
	ftmClock = F_TIMER;	// Set variable for the actual timer clock frequency
#else
	if (frequency < (float)(F_TIMER >> 7) / 65536.0f) {
    22ec:	eddf 7a3b 	vldr	s15, [pc, #236]	; 23dc <analogWriteFrequency+0xfc>
		// frequency is too low for working with F_TIMER:
		ftmClockSource = 2; 	// Use alternative 31250Hz clock source
		ftmClock = 31250;   	// Set variable for the actual timer clock frequency
	} else {
		ftmClockSource = 1; 	// Use default F_TIMER clock source
    22f0:	4a3b      	ldr	r2, [pc, #236]	; (23e0 <analogWriteFrequency+0x100>)
    22f2:	eeb4 0ae7 	vcmpe.f32	s0, s15
    22f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    22fa:	f647 2312 	movw	r3, #31250	; 0x7a12
    22fe:	bf46      	itte	mi
    2300:	461a      	movmi	r2, r3
    2302:	2502      	movmi	r5, #2
    2304:	2501      	movpl	r5, #1
#endif

	
	for (prescale = 0; prescale < 7; prescale++) {
		minfreq = (float)(ftmClock >> prescale) / 65536.0f;	//Use ftmClock instead of F_TIMER
		if (frequency >= minfreq) break;
    2306:	eddf 6a37 	vldr	s13, [pc, #220]	; 23e4 <analogWriteFrequency+0x104>
		ftmClock = F_TIMER;	// Set variable for the actual timer clock frequency
	}
#endif

	
	for (prescale = 0; prescale < 7; prescale++) {
    230a:	2300      	movs	r3, #0
		minfreq = (float)(ftmClock >> prescale) / 65536.0f;	//Use ftmClock instead of F_TIMER
    230c:	fa22 f403 	lsr.w	r4, r2, r3
    2310:	ee07 4a90 	vmov	s15, r4
    2314:	eef8 7ae7 	vcvt.f32.s32	s15, s15
		if (frequency >= minfreq) break;
    2318:	ee27 7aa6 	vmul.f32	s14, s15, s13
    231c:	eeb4 0ac7 	vcmpe.f32	s0, s14
    2320:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    2324:	da07      	bge.n	2336 <analogWriteFrequency+0x56>
		ftmClock = F_TIMER;	// Set variable for the actual timer clock frequency
	}
#endif

	
	for (prescale = 0; prescale < 7; prescale++) {
    2326:	3301      	adds	r3, #1
    2328:	2b07      	cmp	r3, #7
    232a:	d1ef      	bne.n	230c <analogWriteFrequency+0x2c>
    232c:	09d2      	lsrs	r2, r2, #7
    232e:	ee07 2a90 	vmov	s15, r2
    2332:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	//serial_phex32(ftmClock >> prescale);
	//serial_print("\n");
	//serial_print("prescale = ");
	//serial_phex(prescale);
	//serial_print("\n");
	mod = (float)(ftmClock >> prescale) / frequency - 0.5f;	//Use ftmClock instead of F_TIMER
    2336:	ee87 7a80 	vdiv.f32	s14, s15, s0
    233a:	f64f 74ff 	movw	r4, #65535	; 0xffff
	if (mod > 65535) mod = 65535;
	//serial_print("mod = ");
	//serial_phex32(mod);
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
    233e:	1ec2      	subs	r2, r0, #3
	//serial_phex32(ftmClock >> prescale);
	//serial_print("\n");
	//serial_print("prescale = ");
	//serial_phex(prescale);
	//serial_print("\n");
	mod = (float)(ftmClock >> prescale) / frequency - 0.5f;	//Use ftmClock instead of F_TIMER
    2340:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    2344:	ee77 7a67 	vsub.f32	s15, s14, s15
    2348:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    234c:	ee17 6a90 	vmov	r6, s15
    2350:	42a6      	cmp	r6, r4
    2352:	bf28      	it	cs
    2354:	4626      	movcs	r6, r4
	if (mod > 65535) mod = 65535;
	//serial_print("mod = ");
	//serial_phex32(mod);
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
    2356:	2a01      	cmp	r2, #1
    2358:	4634      	mov	r4, r6
    235a:	d937      	bls.n	23cc <analogWriteFrequency+0xec>
		FTM1_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);	//Use ftmClockSource instead of 1
	} else if (pin == FTM0_CH0_PIN || pin == FTM0_CH1_PIN
	  || pin == FTM0_CH2_PIN || pin == FTM0_CH3_PIN
	  || pin == FTM0_CH4_PIN || pin == FTM0_CH5_PIN
#ifdef FTM0_CH6_PIN
	  || pin == FTM0_CH6_PIN || pin == FTM0_CH7_PIN
    235c:	2817      	cmp	r0, #23
    235e:	d90e      	bls.n	237e <analogWriteFrequency+0x9e>
		FTM0_CNT = 0;
		FTM0_MOD = mod;
		FTM0_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);	//Use ftmClockSource instead of 1
	}
#ifdef FTM2_CH0_PIN
	  else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
    2360:	f1a0 021d 	sub.w	r2, r0, #29
    2364:	2a01      	cmp	r2, #1
    2366:	d935      	bls.n	23d4 <analogWriteFrequency+0xf4>
		FTM2_MOD = mod;
		FTM2_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);	//Use ftmClockSource instead of 1
	}
#endif
#ifdef FTM3_CH0_PIN
	  else if (pin == FTM3_CH0_PIN || pin == FTM3_CH1_PIN
    2368:	280e      	cmp	r0, #14
    236a:	d91e      	bls.n	23aa <analogWriteFrequency+0xca>
	  || pin == FTM3_CH2_PIN || pin == FTM3_CH3_PIN
	  || pin == FTM3_CH4_PIN || pin == FTM3_CH5_PIN
    236c:	3823      	subs	r0, #35	; 0x23
    236e:	2803      	cmp	r0, #3
    2370:	d920      	bls.n	23b4 <analogWriteFrequency+0xd4>
		FTM3_MOD = mod;
		FTM3_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);	//Use the new ftmClockSource instead of 1
	}
#endif
#ifdef TPM1_CH0_PIN
	  else if (pin == TPM1_CH0_PIN || pin == TPM1_CH1_PIN) {
    2372:	2901      	cmp	r1, #1
    2374:	d814      	bhi.n	23a0 <analogWriteFrequency+0xc0>
		TPM1_SC = 0;
    2376:	4a1c      	ldr	r2, [pc, #112]	; (23e8 <analogWriteFrequency+0x108>)
		TPM1_CNT = 0;
    2378:	4e1c      	ldr	r6, [pc, #112]	; (23ec <analogWriteFrequency+0x10c>)
		TPM1_MOD = mod;
    237a:	481d      	ldr	r0, [pc, #116]	; (23f0 <analogWriteFrequency+0x110>)
    237c:	e01d      	b.n	23ba <analogWriteFrequency+0xda>
		FTM1_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);	//Use ftmClockSource instead of 1
	} else if (pin == FTM0_CH0_PIN || pin == FTM0_CH1_PIN
	  || pin == FTM0_CH2_PIN || pin == FTM0_CH3_PIN
	  || pin == FTM0_CH4_PIN || pin == FTM0_CH5_PIN
#ifdef FTM0_CH6_PIN
	  || pin == FTM0_CH6_PIN || pin == FTM0_CH7_PIN
    237e:	4a1d      	ldr	r2, [pc, #116]	; (23f4 <analogWriteFrequency+0x114>)
    2380:	40c2      	lsrs	r2, r0
    2382:	f002 0201 	and.w	r2, r2, #1
    2386:	f082 0601 	eor.w	r6, r2, #1
    238a:	2a00      	cmp	r2, #0
    238c:	d0e8      	beq.n	2360 <analogWriteFrequency+0x80>
#endif
	  ) {
		FTM0_SC = 0;
    238e:	4a1a      	ldr	r2, [pc, #104]	; (23f8 <analogWriteFrequency+0x118>)
		FTM0_CNT = 0;
    2390:	481a      	ldr	r0, [pc, #104]	; (23fc <analogWriteFrequency+0x11c>)
		FTM0_MOD = mod;
    2392:	491b      	ldr	r1, [pc, #108]	; (2400 <analogWriteFrequency+0x120>)
	  || pin == FTM0_CH4_PIN || pin == FTM0_CH5_PIN
#ifdef FTM0_CH6_PIN
	  || pin == FTM0_CH6_PIN || pin == FTM0_CH7_PIN
#endif
	  ) {
		FTM0_SC = 0;
    2394:	6016      	str	r6, [r2, #0]
		FTM0_CNT = 0;
		FTM0_MOD = mod;
		FTM0_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);	//Use ftmClockSource instead of 1
    2396:	ea43 03c5 	orr.w	r3, r3, r5, lsl #3
#ifdef FTM0_CH6_PIN
	  || pin == FTM0_CH6_PIN || pin == FTM0_CH7_PIN
#endif
	  ) {
		FTM0_SC = 0;
		FTM0_CNT = 0;
    239a:	6006      	str	r6, [r0, #0]
		FTM0_MOD = mod;
    239c:	600c      	str	r4, [r1, #0]
		FTM0_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);	//Use ftmClockSource instead of 1
    239e:	6013      	str	r3, [r2, #0]
		TPM1_CNT = 0;
		TPM1_MOD = mod;
		TPM1_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);
	}
#endif
}
    23a0:	bc70      	pop	{r4, r5, r6}
    23a2:	4770      	bx	lr
	//serial_print("\n");

#ifdef TPM1_CH0_PIN
	if (pin == TPM1_CH0_PIN || pin == TPM1_CH1_PIN) {
		ftmClockSource = 1;
		ftmClock = 16000000;
    23a4:	4a17      	ldr	r2, [pc, #92]	; (2404 <analogWriteFrequency+0x124>)
	//serial_phex32((uint32_t)frequency);
	//serial_print("\n");

#ifdef TPM1_CH0_PIN
	if (pin == TPM1_CH0_PIN || pin == TPM1_CH1_PIN) {
		ftmClockSource = 1;
    23a6:	2501      	movs	r5, #1
    23a8:	e7ad      	b.n	2306 <analogWriteFrequency+0x26>
		FTM2_MOD = mod;
		FTM2_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);	//Use ftmClockSource instead of 1
	}
#endif
#ifdef FTM3_CH0_PIN
	  else if (pin == FTM3_CH0_PIN || pin == FTM3_CH1_PIN
    23aa:	f244 1284 	movw	r2, #16772	; 0x4184
    23ae:	40c2      	lsrs	r2, r0
    23b0:	07d2      	lsls	r2, r2, #31
    23b2:	d5db      	bpl.n	236c <analogWriteFrequency+0x8c>
	  || pin == FTM3_CH2_PIN || pin == FTM3_CH3_PIN
	  || pin == FTM3_CH4_PIN || pin == FTM3_CH5_PIN
	  || pin == FTM3_CH6_PIN || pin == FTM3_CH7_PIN) {
		FTM3_SC = 0;
    23b4:	4a14      	ldr	r2, [pc, #80]	; (2408 <analogWriteFrequency+0x128>)
		FTM3_CNT = 0;
    23b6:	4e15      	ldr	r6, [pc, #84]	; (240c <analogWriteFrequency+0x12c>)
		FTM3_MOD = mod;
    23b8:	4815      	ldr	r0, [pc, #84]	; (2410 <analogWriteFrequency+0x130>)
#ifdef TPM1_CH0_PIN
	  else if (pin == TPM1_CH0_PIN || pin == TPM1_CH1_PIN) {
		TPM1_SC = 0;
		TPM1_CNT = 0;
		TPM1_MOD = mod;
		TPM1_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);
    23ba:	ea43 03c5 	orr.w	r3, r3, r5, lsl #3
		FTM3_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);	//Use the new ftmClockSource instead of 1
	}
#endif
#ifdef TPM1_CH0_PIN
	  else if (pin == TPM1_CH0_PIN || pin == TPM1_CH1_PIN) {
		TPM1_SC = 0;
    23be:	2100      	movs	r1, #0
    23c0:	6011      	str	r1, [r2, #0]
		TPM1_CNT = 0;
    23c2:	6031      	str	r1, [r6, #0]
		TPM1_MOD = mod;
    23c4:	6004      	str	r4, [r0, #0]
		TPM1_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);
    23c6:	6013      	str	r3, [r2, #0]
	}
#endif
}
    23c8:	bc70      	pop	{r4, r5, r6}
    23ca:	4770      	bx	lr
	if (mod > 65535) mod = 65535;
	//serial_print("mod = ");
	//serial_phex32(mod);
	//serial_print("\n");
	if (pin == FTM1_CH0_PIN || pin == FTM1_CH1_PIN) {
		FTM1_SC = 0;
    23cc:	4a11      	ldr	r2, [pc, #68]	; (2414 <analogWriteFrequency+0x134>)
		FTM1_CNT = 0;
    23ce:	4e12      	ldr	r6, [pc, #72]	; (2418 <analogWriteFrequency+0x138>)
		FTM1_MOD = mod;
    23d0:	4812      	ldr	r0, [pc, #72]	; (241c <analogWriteFrequency+0x13c>)
    23d2:	e7f2      	b.n	23ba <analogWriteFrequency+0xda>
		FTM0_MOD = mod;
		FTM0_SC = FTM_SC_CLKS(ftmClockSource) | FTM_SC_PS(prescale);	//Use ftmClockSource instead of 1
	}
#ifdef FTM2_CH0_PIN
	  else if (pin == FTM2_CH0_PIN || pin == FTM2_CH1_PIN) {
		FTM2_SC = 0;
    23d4:	4a12      	ldr	r2, [pc, #72]	; (2420 <analogWriteFrequency+0x140>)
		FTM2_CNT = 0;
    23d6:	4e13      	ldr	r6, [pc, #76]	; (2424 <analogWriteFrequency+0x144>)
		FTM2_MOD = mod;
    23d8:	4813      	ldr	r0, [pc, #76]	; (2428 <analogWriteFrequency+0x148>)
    23da:	e7ee      	b.n	23ba <analogWriteFrequency+0xda>
    23dc:	40e4e1c0 	.word	0x40e4e1c0
    23e0:	03938700 	.word	0x03938700
    23e4:	37800000 	.word	0x37800000
    23e8:	400c9000 	.word	0x400c9000
    23ec:	400c9004 	.word	0x400c9004
    23f0:	400c9008 	.word	0x400c9008
    23f4:	00f00660 	.word	0x00f00660
    23f8:	40038000 	.word	0x40038000
    23fc:	40038004 	.word	0x40038004
    2400:	40038008 	.word	0x40038008
    2404:	00f42400 	.word	0x00f42400
    2408:	400b9000 	.word	0x400b9000
    240c:	400b9004 	.word	0x400b9004
    2410:	400b9008 	.word	0x400b9008
    2414:	40039000 	.word	0x40039000
    2418:	40039004 	.word	0x40039004
    241c:	40039008 	.word	0x40039008
    2420:	400b8000 	.word	0x400b8000
    2424:	400b8004 	.word	0x400b8004
    2428:	400b8008 	.word	0x400b8008

0000242c <digitalWrite>:

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    242c:	283f      	cmp	r0, #63	; 0x3f
    242e:	d801      	bhi.n	2434 <digitalWrite+0x8>
    2430:	f7ff bcb6 	b.w	1da0 <digitalWrite.part.1>
    2434:	4770      	bx	lr
    2436:	bf00      	nop

00002438 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    2438:	283f      	cmp	r0, #63	; 0x3f
    243a:	d801      	bhi.n	2440 <pinMode+0x8>
    243c:	f7ff bcd6 	b.w	1dec <pinMode.part.2>
    2440:	4770      	bx	lr
    2442:	bf00      	nop

00002444 <delay>:
#endif
	return count * 1000 + current / (F_CPU / 1000000);
}

void delay(uint32_t ms)
{
    2444:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    2448:	4605      	mov	r5, r0

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    244a:	b672      	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    244c:	4f22      	ldr	r7, [pc, #136]	; (24d8 <delay+0x94>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    244e:	4b23      	ldr	r3, [pc, #140]	; (24dc <delay+0x98>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    2450:	4a23      	ldr	r2, [pc, #140]	; (24e0 <delay+0x9c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    2452:	681b      	ldr	r3, [r3, #0]
	count = systick_millis_count;
    2454:	683c      	ldr	r4, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    2456:	6812      	ldr	r2, [r2, #0]
	__enable_irq();
    2458:	b662      	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    245a:	0152      	lsls	r2, r2, #5
    245c:	d502      	bpl.n	2464 <delay+0x20>
    245e:	2b32      	cmp	r3, #50	; 0x32
    2460:	bf88      	it	hi
    2462:	3401      	addhi	r4, #1

void delay(uint32_t ms)
{
	uint32_t start = micros();

	if (ms > 0) {
    2464:	b3b5      	cbz	r5, 24d4 <delay+0x90>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    2466:	f5c3 332f 	rsb	r3, r3, #179200	; 0x2bc00
    246a:	f203 331f 	addw	r3, r3, #799	; 0x31f
    246e:	4e1d      	ldr	r6, [pc, #116]	; (24e4 <delay+0xa0>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    2470:	f8df 9068 	ldr.w	r9, [pc, #104]	; 24dc <delay+0x98>
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    2474:	f8df 8068 	ldr.w	r8, [pc, #104]	; 24e0 <delay+0x9c>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    2478:	089b      	lsrs	r3, r3, #2
    247a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    247e:	fba6 1303 	umull	r1, r3, r6, r3
    2482:	fb02 f404 	mul.w	r4, r2, r4
    2486:	eb04 0493 	add.w	r4, r4, r3, lsr #2

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    248a:	b672      	cpsid	i
	current = SYST_CVR;
    248c:	f8d9 1000 	ldr.w	r1, [r9]
	count = systick_millis_count;
    2490:	683a      	ldr	r2, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    2492:	f8d8 e000 	ldr.w	lr, [r8]
	__enable_irq();
    2496:	b662      	cpsie	i
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    2498:	f5c1 332f 	rsb	r3, r1, #179200	; 0x2bc00
    249c:	f203 331f 	addw	r3, r3, #799	; 0x31f
    24a0:	089b      	lsrs	r3, r3, #2
    24a2:	fba6 0303 	umull	r0, r3, r6, r3
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    24a6:	f01e 6f80 	tst.w	lr, #67108864	; 0x4000000
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    24aa:	ebc4 0393 	rsb	r3, r4, r3, lsr #2
    24ae:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    24b2:	d002      	beq.n	24ba <delay+0x76>
    24b4:	2932      	cmp	r1, #50	; 0x32
    24b6:	bf88      	it	hi
    24b8:	3201      	addhi	r2, #1
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    24ba:	fb00 3302 	mla	r3, r0, r2, r3
    24be:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    24c2:	d304      	bcc.n	24ce <delay+0x8a>
				ms--;
				if (ms == 0) return;
    24c4:	3d01      	subs	r5, #1
    24c6:	d005      	beq.n	24d4 <delay+0x90>
				start += 1000;
    24c8:	f504 747a 	add.w	r4, r4, #1000	; 0x3e8
    24cc:	e7dd      	b.n	248a <delay+0x46>
			}
			yield();
    24ce:	f001 fc15 	bl	3cfc <yield>
		}
    24d2:	e7da      	b.n	248a <delay+0x46>
    24d4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    24d8:	1fff1618 	.word	0x1fff1618
    24dc:	e000e018 	.word	0xe000e018
    24e0:	e000ed04 	.word	0xe000ed04
    24e4:	16c16c17 	.word	0x16c16c17

000024e8 <_init_Teensyduino_internal_>:
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    24e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    24ea:	4b4e      	ldr	r3, [pc, #312]	; (2624 <_init_Teensyduino_internal_+0x13c>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    24ec:	484e      	ldr	r0, [pc, #312]	; (2628 <_init_Teensyduino_internal_+0x140>)
	FTM0_MOD = DEFAULT_FTM_MOD;
    24ee:	f8df c15c 	ldr.w	ip, [pc, #348]	; 264c <_init_Teensyduino_internal_+0x164>
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
    24f2:	4c4e      	ldr	r4, [pc, #312]	; (262c <_init_Teensyduino_internal_+0x144>)
	FTM0_C2SC = 0x28;
    24f4:	494e      	ldr	r1, [pc, #312]	; (2630 <_init_Teensyduino_internal_+0x148>)
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    24f6:	f8df e158 	ldr.w	lr, [pc, #344]	; 2650 <_init_Teensyduino_internal_+0x168>
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
    24fa:	4e4e      	ldr	r6, [pc, #312]	; (2634 <_init_Teensyduino_internal_+0x14c>)
	FTM0_C4SC = 0x28;
    24fc:	4d4e      	ldr	r5, [pc, #312]	; (2638 <_init_Teensyduino_internal_+0x150>)
	FTM0_C5SC = 0x28;
    24fe:	4f4f      	ldr	r7, [pc, #316]	; (263c <_init_Teensyduino_internal_+0x154>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    2500:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    2504:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    2506:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    250a:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    250c:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
    2510:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    2512:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    2516:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    2518:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    251c:	601a      	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    251e:	2200      	movs	r2, #0
    2520:	6002      	str	r2, [r0, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    2522:	2328      	movs	r3, #40	; 0x28
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
    2524:	f64e 70ff 	movw	r0, #61439	; 0xefff
    2528:	f8cc 0000 	str.w	r0, [ip]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    252c:	f8ce 3000 	str.w	r3, [lr]
	FTM0_C1SC = 0x28;
    2530:	6023      	str	r3, [r4, #0]
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    2532:	f50e 2e01 	add.w	lr, lr, #528384	; 0x81000
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    2536:	600b      	str	r3, [r1, #0]
	FTM0_C3SC = 0x28;
    2538:	6033      	str	r3, [r6, #0]
	FTM0_C4SC = 0x28;
    253a:	602b      	str	r3, [r5, #0]
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    253c:	f506 2600 	add.w	r6, r6, #524288	; 0x80000
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
    2540:	603b      	str	r3, [r7, #0]
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
    2542:	f505 2500 	add.w	r5, r5, #524288	; 0x80000
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    2546:	62a3      	str	r3, [r4, #40]	; 0x28
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
    2548:	f507 2700 	add.w	r7, r7, #524288	; 0x80000
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
    254c:	628b      	str	r3, [r1, #40]	; 0x28
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
    254e:	f504 2401 	add.w	r4, r4, #528384	; 0x81000
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
    2552:	f501 2101 	add.w	r1, r1, #528384	; 0x81000
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    2556:	f606 76e8 	addw	r6, r6, #4072	; 0xfe8
	FTM3_C1SC = 0x28;
    255a:	f605 75e8 	addw	r5, r5, #4072	; 0xfe8
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
    255e:	f507 677f 	add.w	r7, r7, #4080	; 0xff0
	FTM3_C4SC = 0x28;
    2562:	3110      	adds	r1, #16
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    2564:	f10e 0e10 	add.w	lr, lr, #16
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
    2568:	3420      	adds	r4, #32
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    256a:	6033      	str	r3, [r6, #0]
	FTM3_C1SC = 0x28;
    256c:	602b      	str	r3, [r5, #0]
	FTM3_C2SC = 0x28;
    256e:	f8ce 3000 	str.w	r3, [lr]
	FTM3_C3SC = 0x28;
    2572:	603b      	str	r3, [r7, #0]
	FTM3_C4SC = 0x28;
    2574:	600b      	str	r3, [r1, #0]
	FTM3_C5SC = 0x28;
    2576:	6023      	str	r3, [r4, #0]
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    2578:	4c31      	ldr	r4, [pc, #196]	; (2640 <_init_Teensyduino_internal_+0x158>)
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
    257a:	61bb      	str	r3, [r7, #24]
	FTM3_C7SC = 0x28;
    257c:	618b      	str	r3, [r1, #24]
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    257e:	2109      	movs	r1, #9
    2580:	6021      	str	r1, [r4, #0]
	FTM1_CNT = 0;
    2582:	f5a7 2700 	sub.w	r7, r7, #524288	; 0x80000
	FTM1_MOD = DEFAULT_FTM_MOD;
    2586:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
    258a:	3f20      	subs	r7, #32
	FTM1_MOD = DEFAULT_FTM_MOD;
    258c:	3408      	adds	r4, #8
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
    258e:	603a      	str	r2, [r7, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
    2590:	6020      	str	r0, [r4, #0]
	FTM1_C0SC = 0x28;
    2592:	60bb      	str	r3, [r7, #8]
	FTM1_C1SC = 0x28;
    2594:	60e3      	str	r3, [r4, #12]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    2596:	f847 1c04 	str.w	r1, [r7, #-4]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    259a:	f504 24fd 	add.w	r4, r4, #518144	; 0x7e800
	FTM2_MOD = DEFAULT_FTM_MOD;
    259e:	f507 27fe 	add.w	r7, r7, #520192	; 0x7f000
    25a2:	3704      	adds	r7, #4
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    25a4:	f204 74fc 	addw	r4, r4, #2044	; 0x7fc
    25a8:	6022      	str	r2, [r4, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    25aa:	6038      	str	r0, [r7, #0]
	FTM2_C0SC = 0x28;
    25ac:	60a3      	str	r3, [r4, #8]
	FTM2_C1SC = 0x28;
    25ae:	60fb      	str	r3, [r7, #12]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    25b0:	f844 1c04 	str.w	r1, [r4, #-4]
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
	FTM2_C0SC = 0x28;
    25b4:	3408      	adds	r4, #8
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
    25b6:	f604 74fc 	addw	r4, r4, #4092	; 0xffc
	FTM2_C0SC = 0x28;
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
    25ba:	f8c7 2ffc 	str.w	r2, [r7, #4092]	; 0xffc
	FTM3_MOD = DEFAULT_FTM_MOD;
    25be:	6020      	str	r0, [r4, #0]
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    25c0:	f5a4 24e1 	sub.w	r4, r4, #460800	; 0x70800
    25c4:	f2a4 74dc 	subw	r4, r4, #2012	; 0x7dc
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
	FTM3_C0SC = 0x28;
    25c8:	6033      	str	r3, [r6, #0]
	FTM3_C1SC = 0x28;
    25ca:	602b      	str	r3, [r5, #0]
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    25cc:	f8c7 1ff8 	str.w	r1, [r7, #4088]	; 0xff8
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    25d0:	6821      	ldr	r1, [r4, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    25d2:	481c      	ldr	r0, [pc, #112]	; (2644 <_init_Teensyduino_internal_+0x15c>)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    25d4:	f441 7100 	orr.w	r1, r1, #512	; 0x200
    25d8:	6021      	str	r1, [r4, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    25da:	6801      	ldr	r1, [r0, #0]
	TPM1_CNT = 0;
	TPM1_MOD = 32767;
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    25dc:	4c1a      	ldr	r4, [pc, #104]	; (2648 <_init_Teensyduino_internal_+0x160>)
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
	TPM1_CNT = 0;
    25de:	f50e 4e7f 	add.w	lr, lr, #65280	; 0xff00
    25e2:	f10e 0ee8 	add.w	lr, lr, #232	; 0xe8
	TPM1_MOD = 32767;
    25e6:	f507 3788 	add.w	r7, r7, #69632	; 0x11000
	TPM1_C0SC = 0x28;
    25ea:	f506 3680 	add.w	r6, r6, #65536	; 0x10000
	TPM1_C1SC = 0x28;
    25ee:	f505 3580 	add.w	r5, r5, #65536	; 0x10000
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    25f2:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
    25f6:	6001      	str	r1, [r0, #0]
	TPM1_CNT = 0;
    25f8:	f8ce 2000 	str.w	r2, [lr]
	TPM1_MOD = 32767;
    25fc:	f647 71ff 	movw	r1, #32767	; 0x7fff
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    2600:	2208      	movs	r2, #8
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
	TPM1_CNT = 0;
	TPM1_MOD = 32767;
    2602:	6039      	str	r1, [r7, #0]
	TPM1_C0SC = 0x28;
    2604:	6033      	str	r3, [r6, #0]
	TPM1_C1SC = 0x28;
    2606:	602b      	str	r3, [r5, #0]
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    2608:	6022      	str	r2, [r4, #0]
#endif
	analog_init();
    260a:	f7ff f9af 	bl	196c <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    260e:	2019      	movs	r0, #25
    2610:	f7ff ff18 	bl	2444 <delay>
	usb_init();
    2614:	f000 fe60 	bl	32d8 <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    2618:	f240 1013 	movw	r0, #275	; 0x113
}
    261c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    2620:	f7ff bf10 	b.w	2444 <delay>
    2624:	e000e104 	.word	0xe000e104
    2628:	40038004 	.word	0x40038004
    262c:	40038014 	.word	0x40038014
    2630:	4003801c 	.word	0x4003801c
    2634:	40038024 	.word	0x40038024
    2638:	4003802c 	.word	0x4003802c
    263c:	40038034 	.word	0x40038034
    2640:	40038000 	.word	0x40038000
    2644:	40048004 	.word	0x40048004
    2648:	400c9000 	.word	0x400c9000
    264c:	40038008 	.word	0x40038008
    2650:	4003800c 	.word	0x4003800c

00002654 <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    2654:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    2656:	2b03      	cmp	r3, #3
    2658:	d814      	bhi.n	2684 <usb_rx+0x30>
	__disable_irq();
    265a:	b672      	cpsid	i
	ret = rx_first[endpoint];
    265c:	490a      	ldr	r1, [pc, #40]	; (2688 <usb_rx+0x34>)
    265e:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
	if (ret) {
    2662:	b168      	cbz	r0, 2680 <usb_rx+0x2c>




usb_packet_t *usb_rx(uint32_t endpoint)
{
    2664:	b470      	push	{r4, r5, r6}
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
    2666:	4c09      	ldr	r4, [pc, #36]	; (268c <usb_rx+0x38>)
    2668:	8805      	ldrh	r5, [r0, #0]
    266a:	f834 2013 	ldrh.w	r2, [r4, r3, lsl #1]
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
    266e:	6846      	ldr	r6, [r0, #4]
    2670:	f841 6023 	str.w	r6, [r1, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    2674:	1b52      	subs	r2, r2, r5
    2676:	f824 2013 	strh.w	r2, [r4, r3, lsl #1]
	}
	__enable_irq();
    267a:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    267c:	bc70      	pop	{r4, r5, r6}
    267e:	4770      	bx	lr
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
	}
	__enable_irq();
    2680:	b662      	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    2682:	4770      	bx	lr

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    2684:	2000      	movs	r0, #0
    2686:	4770      	bx	lr
    2688:	1fff1674 	.word	0x1fff1674
    268c:	1fff1a6c 	.word	0x1fff1a6c

00002690 <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    2690:	3801      	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    2692:	2803      	cmp	r0, #3
    2694:	d80b      	bhi.n	26ae <usb_tx_packet_count+0x1e>
	__disable_irq();
    2696:	b672      	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    2698:	4b07      	ldr	r3, [pc, #28]	; (26b8 <usb_tx_packet_count+0x28>)
    269a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    269e:	b143      	cbz	r3, 26b2 <usb_tx_packet_count+0x22>
    26a0:	2000      	movs	r0, #0
    26a2:	685b      	ldr	r3, [r3, #4]
    26a4:	3001      	adds	r0, #1
    26a6:	2b00      	cmp	r3, #0
    26a8:	d1fb      	bne.n	26a2 <usb_tx_packet_count+0x12>
	__enable_irq();
    26aa:	b662      	cpsie	i
	return count;
    26ac:	4770      	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    26ae:	2000      	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    26b0:	4770      	bx	lr
}

uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    26b2:	4618      	mov	r0, r3
    26b4:	e7f9      	b.n	26aa <usb_tx_packet_count+0x1a>
    26b6:	bf00      	nop
    26b8:	1fff16c8 	.word	0x1fff16c8

000026bc <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    26bc:	b430      	push	{r4, r5}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    26be:	b672      	cpsid	i
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    26c0:	4a2b      	ldr	r2, [pc, #172]	; (2770 <usb_rx_memory+0xb4>)
    26c2:	7813      	ldrb	r3, [r2, #0]
    26c4:	071d      	lsls	r5, r3, #28
    26c6:	d506      	bpl.n	26d6 <usb_rx_memory+0x1a>
			if (table[index(i, RX, EVEN)].desc == 0) {
    26c8:	4b2a      	ldr	r3, [pc, #168]	; (2774 <usb_rx_memory+0xb8>)
    26ca:	6a19      	ldr	r1, [r3, #32]
    26cc:	2900      	cmp	r1, #0
    26ce:	d036      	beq.n	273e <usb_rx_memory+0x82>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    26d0:	6a99      	ldr	r1, [r3, #40]	; 0x28
    26d2:	2900      	cmp	r1, #0
    26d4:	d041      	beq.n	275a <usb_rx_memory+0x9e>
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    26d6:	7853      	ldrb	r3, [r2, #1]
    26d8:	071c      	lsls	r4, r3, #28
    26da:	d506      	bpl.n	26ea <usb_rx_memory+0x2e>
			if (table[index(i, RX, EVEN)].desc == 0) {
    26dc:	4b25      	ldr	r3, [pc, #148]	; (2774 <usb_rx_memory+0xb8>)
    26de:	6c19      	ldr	r1, [r3, #64]	; 0x40
    26e0:	2900      	cmp	r1, #0
    26e2:	d03e      	beq.n	2762 <usb_rx_memory+0xa6>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    26e4:	6c99      	ldr	r1, [r3, #72]	; 0x48
    26e6:	2900      	cmp	r1, #0
    26e8:	d039      	beq.n	275e <usb_rx_memory+0xa2>
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    26ea:	7893      	ldrb	r3, [r2, #2]
    26ec:	0719      	lsls	r1, r3, #28
    26ee:	d505      	bpl.n	26fc <usb_rx_memory+0x40>
			if (table[index(i, RX, EVEN)].desc == 0) {
    26f0:	4b20      	ldr	r3, [pc, #128]	; (2774 <usb_rx_memory+0xb8>)
    26f2:	6e19      	ldr	r1, [r3, #96]	; 0x60
    26f4:	2900      	cmp	r1, #0
    26f6:	d036      	beq.n	2766 <usb_rx_memory+0xaa>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    26f8:	6e99      	ldr	r1, [r3, #104]	; 0x68
    26fa:	b189      	cbz	r1, 2720 <usb_rx_memory+0x64>
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    26fc:	78d3      	ldrb	r3, [r2, #3]
    26fe:	071b      	lsls	r3, r3, #28
    2700:	d507      	bpl.n	2712 <usb_rx_memory+0x56>
			if (table[index(i, RX, EVEN)].desc == 0) {
    2702:	4b1c      	ldr	r3, [pc, #112]	; (2774 <usb_rx_memory+0xb8>)
    2704:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
    2708:	b37a      	cbz	r2, 276a <usb_rx_memory+0xae>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    270a:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    270e:	2111      	movs	r1, #17
    2710:	b13a      	cbz	r2, 2722 <usb_rx_memory+0x66>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    2712:	b662      	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    2714:	4b18      	ldr	r3, [pc, #96]	; (2778 <usb_rx_memory+0xbc>)
    2716:	2200      	movs	r2, #0
    2718:	701a      	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    271a:	bc30      	pop	{r4, r5}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    271c:	f000 be7c 	b.w	3418 <usb_free>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    2720:	210d      	movs	r1, #13
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    2722:	4c15      	ldr	r4, [pc, #84]	; (2778 <usb_rx_memory+0xbc>)
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    2724:	4d15      	ldr	r5, [pc, #84]	; (277c <usb_rx_memory+0xc0>)
				usb_rx_memory_needed--;
    2726:	7822      	ldrb	r2, [r4, #0]
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    2728:	f843 5031 	str.w	r5, [r3, r1, lsl #3]
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    272c:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    2730:	3008      	adds	r0, #8
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    2732:	3a01      	subs	r2, #1
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    2734:	6058      	str	r0, [r3, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    2736:	7022      	strb	r2, [r4, #0]
				__enable_irq();
    2738:	b662      	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    273a:	bc30      	pop	{r4, r5}
    273c:	4770      	bx	lr
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
    273e:	2204      	movs	r2, #4
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    2740:	4c0d      	ldr	r4, [pc, #52]	; (2778 <usb_rx_memory+0xbc>)
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    2742:	4d0f      	ldr	r5, [pc, #60]	; (2780 <usb_rx_memory+0xc4>)
				usb_rx_memory_needed--;
    2744:	7821      	ldrb	r1, [r4, #0]
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    2746:	f843 5032 	str.w	r5, [r3, r2, lsl #3]
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    274a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    274e:	3008      	adds	r0, #8
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    2750:	1e4a      	subs	r2, r1, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    2752:	6058      	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    2754:	7022      	strb	r2, [r4, #0]
				__enable_irq();
    2756:	b662      	cpsie	i
				//serial_phex(i);
				//serial_print(",even\n");
				return;
    2758:	e7ef      	b.n	273a <usb_rx_memory+0x7e>
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    275a:	2105      	movs	r1, #5
    275c:	e7e1      	b.n	2722 <usb_rx_memory+0x66>
    275e:	2109      	movs	r1, #9
    2760:	e7df      	b.n	2722 <usb_rx_memory+0x66>
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
    2762:	2208      	movs	r2, #8
    2764:	e7ec      	b.n	2740 <usb_rx_memory+0x84>
    2766:	220c      	movs	r2, #12
    2768:	e7ea      	b.n	2740 <usb_rx_memory+0x84>
    276a:	2210      	movs	r2, #16
    276c:	e7e8      	b.n	2740 <usb_rx_memory+0x84>
    276e:	bf00      	nop
    2770:	00006ba0 	.word	0x00006ba0
    2774:	1fff0000 	.word	0x1fff0000
    2778:	1fff16f1 	.word	0x1fff16f1
    277c:	004000c8 	.word	0x004000c8
    2780:	00400088 	.word	0x00400088

00002784 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    2784:	1e43      	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    2786:	2b03      	cmp	r3, #3
    2788:	d81d      	bhi.n	27c6 <usb_tx+0x42>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    278a:	4a1b      	ldr	r2, [pc, #108]	; (27f8 <usb_tx+0x74>)
    278c:	0140      	lsls	r0, r0, #5
    278e:	f040 0010 	orr.w	r0, r0, #16

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    2792:	b430      	push	{r4, r5}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    2794:	4410      	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    2796:	b672      	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    2798:	4c18      	ldr	r4, [pc, #96]	; (27fc <usb_tx+0x78>)
    279a:	5ce2      	ldrb	r2, [r4, r3]
    279c:	2a03      	cmp	r2, #3
    279e:	d81b      	bhi.n	27d8 <usb_tx+0x54>
    27a0:	e8df f002 	tbb	[pc, r2]
    27a4:	17151202 	.word	0x17151202
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    27a8:	2203      	movs	r2, #3
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    27aa:	880d      	ldrh	r5, [r1, #0]
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    27ac:	54e2      	strb	r2, [r4, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    27ae:	f010 0f08 	tst.w	r0, #8
    27b2:	bf14      	ite	ne
    27b4:	23c8      	movne	r3, #200	; 0xc8
    27b6:	2388      	moveq	r3, #136	; 0x88
    27b8:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    27bc:	3108      	adds	r1, #8
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    27be:	6003      	str	r3, [r0, #0]
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    27c0:	6041      	str	r1, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
	__enable_irq();
    27c2:	b662      	cpsie	i
}
    27c4:	bc30      	pop	{r4, r5}
    27c6:	4770      	bx	lr
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    27c8:	3008      	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    27ca:	2202      	movs	r2, #2
		break;
    27cc:	e7ed      	b.n	27aa <usb_tx+0x26>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    27ce:	2205      	movs	r2, #5
    27d0:	e7eb      	b.n	27aa <usb_tx+0x26>
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    27d2:	3008      	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    27d4:	2204      	movs	r2, #4
		break;
    27d6:	e7e8      	b.n	27aa <usb_tx+0x26>
	  default:
		if (tx_first[endpoint] == NULL) {
    27d8:	4a09      	ldr	r2, [pc, #36]	; (2800 <usb_tx+0x7c>)
    27da:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    27de:	b138      	cbz	r0, 27f0 <usb_tx+0x6c>
			tx_first[endpoint] = packet;
		} else {
			tx_last[endpoint]->next = packet;
    27e0:	4a08      	ldr	r2, [pc, #32]	; (2804 <usb_tx+0x80>)
    27e2:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    27e6:	6041      	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    27e8:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		__enable_irq();
    27ec:	b662      	cpsie	i
		return;
    27ee:	e7e9      	b.n	27c4 <usb_tx+0x40>
		b++;
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
		break;
	  default:
		if (tx_first[endpoint] == NULL) {
			tx_first[endpoint] = packet;
    27f0:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    27f4:	4a03      	ldr	r2, [pc, #12]	; (2804 <usb_tx+0x80>)
    27f6:	e7f7      	b.n	27e8 <usb_tx+0x64>
    27f8:	1fff0000 	.word	0x1fff0000
    27fc:	1fff1700 	.word	0x1fff1700
    2800:	1fff16c8 	.word	0x1fff16c8
    2804:	1fff16d8 	.word	0x1fff16d8

00002808 <usb_isr>:
}



void usb_isr(void)
{
    2808:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    280c:	f8df b30c 	ldr.w	fp, [pc, #780]	; 2b1c <usb_isr+0x314>
		USB0_ISTAT = USB_ISTAT_SOFTOK;
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
		uint8_t endpoint;
		stat = USB0_STAT;
    2810:	f8df a30c 	ldr.w	sl, [pc, #780]	; 2b20 <usb_isr+0x318>
}



void usb_isr(void)
{
    2814:	b087      	sub	sp, #28
    2816:	e044      	b.n	28a2 <usb_isr+0x9a>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    2818:	4fab      	ldr	r7, [pc, #684]	; (2ac8 <usb_isr+0x2c0>)
    281a:	ea4f 0893 	mov.w	r8, r3, lsr #2
    281e:	eb07 09c8 	add.w	r9, r7, r8, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    2822:	3e01      	subs	r6, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    2824:	f8d9 2004 	ldr.w	r2, [r9, #4]
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    2828:	f003 0308 	and.w	r3, r3, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    282c:	b2f6      	uxtb	r6, r6
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    282e:	f1a2 0008 	sub.w	r0, r2, #8
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    2832:	f003 04ff 	and.w	r4, r3, #255	; 0xff
    2836:	2b00      	cmp	r3, #0
    2838:	f040 8102 	bne.w	2a40 <usb_isr+0x238>
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    283c:	f857 3038 	ldr.w	r3, [r7, r8, lsl #3]
    2840:	0c1b      	lsrs	r3, r3, #16
    2842:	b299      	uxth	r1, r3
    2844:	f822 1c08 	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    2848:	2b00      	cmp	r3, #0
    284a:	f000 80f0 	beq.w	2a2e <usb_isr+0x226>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    284e:	4b9f      	ldr	r3, [pc, #636]	; (2acc <usb_isr+0x2c4>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    2850:	f822 4c06 	strh.w	r4, [r2, #-6]
					packet->next = NULL;
    2854:	f842 4c04 	str.w	r4, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    2858:	f853 2026 	ldr.w	r2, [r3, r6, lsl #2]
    285c:	2a00      	cmp	r2, #0
    285e:	f000 82c5 	beq.w	2dec <usb_isr+0x5e4>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    2862:	4d9b      	ldr	r5, [pc, #620]	; (2ad0 <usb_isr+0x2c8>)
    2864:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
    2868:	6058      	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    286a:	4c9a      	ldr	r4, [pc, #616]	; (2ad4 <usb_isr+0x2cc>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    286c:	f845 0026 	str.w	r0, [r5, r6, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    2870:	f834 3016 	ldrh.w	r3, [r4, r6, lsl #1]
    2874:	4419      	add	r1, r3
    2876:	f824 1016 	strh.w	r1, [r4, r6, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    287a:	f000 fdad 	bl	33d8 <usb_malloc>
					if (packet) {
    287e:	2800      	cmp	r0, #0
    2880:	f000 82ad 	beq.w	2dde <usb_isr+0x5d6>
						b->addr = packet->buf;
						b->desc = BDT_DESC(64,
    2884:	4a94      	ldr	r2, [pc, #592]	; (2ad8 <usb_isr+0x2d0>)
    2886:	4b95      	ldr	r3, [pc, #596]	; (2adc <usb_isr+0x2d4>)
    2888:	f019 0f08 	tst.w	r9, #8
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    288c:	f100 0008 	add.w	r0, r0, #8
						b->desc = BDT_DESC(64,
    2890:	bf18      	it	ne
    2892:	4613      	movne	r3, r2
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    2894:	f8c9 0004 	str.w	r0, [r9, #4]
						b->desc = BDT_DESC(64,
    2898:	f847 3038 	str.w	r3, [r7, r8, lsl #3]
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    289c:	2308      	movs	r3, #8
    289e:	f88b 3000 	strb.w	r3, [fp]
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    28a2:	f89b 4000 	ldrb.w	r4, [fp]
    28a6:	b2e4      	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    28a8:	0761      	lsls	r1, r4, #29
    28aa:	d51a      	bpl.n	28e2 <usb_isr+0xda>
		if (usb_configuration) {
    28ac:	4b8c      	ldr	r3, [pc, #560]	; (2ae0 <usb_isr+0x2d8>)
    28ae:	781b      	ldrb	r3, [r3, #0]
    28b0:	b1a3      	cbz	r3, 28dc <usb_isr+0xd4>
			t = usb_reboot_timer;
    28b2:	498c      	ldr	r1, [pc, #560]	; (2ae4 <usb_isr+0x2dc>)
    28b4:	780a      	ldrb	r2, [r1, #0]
			if (t) {
    28b6:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    28ba:	b122      	cbz	r2, 28c6 <usb_isr+0xbe>
				usb_reboot_timer = --t;
    28bc:	3b01      	subs	r3, #1
    28be:	b2db      	uxtb	r3, r3
    28c0:	700b      	strb	r3, [r1, #0]
				if (!t) _reboot_Teensyduino_();
    28c2:	b903      	cbnz	r3, 28c6 <usb_isr+0xbe>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    28c4:	be00      	bkpt	0x0000
			if (t) {
				usb_reboot_timer = --t;
				if (!t) _reboot_Teensyduino_();
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    28c6:	4988      	ldr	r1, [pc, #544]	; (2ae8 <usb_isr+0x2e0>)
    28c8:	780a      	ldrb	r2, [r1, #0]
			if (t) {
    28ca:	f002 03ff 	and.w	r3, r2, #255	; 0xff
    28ce:	b12a      	cbz	r2, 28dc <usb_isr+0xd4>
				usb_cdc_transmit_flush_timer = --t;
    28d0:	3b01      	subs	r3, #1
    28d2:	b2db      	uxtb	r3, r3
    28d4:	700b      	strb	r3, [r1, #0]
				if (t == 0) usb_serial_flush_callback();
    28d6:	2b00      	cmp	r3, #0
    28d8:	f000 8257 	beq.w	2d8a <usb_isr+0x582>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    28dc:	2304      	movs	r3, #4
    28de:	f88b 3000 	strb.w	r3, [fp]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    28e2:	f004 0308 	and.w	r3, r4, #8
    28e6:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    28ea:	2b00      	cmp	r3, #0
    28ec:	f000 80cc 	beq.w	2a88 <usb_isr+0x280>
		uint8_t endpoint;
		stat = USB0_STAT;
    28f0:	f89a 3000 	ldrb.w	r3, [sl]
    28f4:	b2db      	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    28f6:	091e      	lsrs	r6, r3, #4
    28f8:	d18e      	bne.n	2818 <usb_isr+0x10>
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    28fa:	089c      	lsrs	r4, r3, #2
    28fc:	f8df 91c8 	ldr.w	r9, [pc, #456]	; 2ac8 <usb_isr+0x2c0>
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    2900:	f859 2034 	ldr.w	r2, [r9, r4, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    2904:	eb09 01c4 	add.w	r1, r9, r4, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    2908:	f3c2 0283 	ubfx	r2, r2, #2, #4
    290c:	3a01      	subs	r2, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    290e:	6849      	ldr	r1, [r1, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    2910:	2a0c      	cmp	r2, #12
    2912:	f200 8088 	bhi.w	2a26 <usb_isr+0x21e>
    2916:	e8df f002 	tbb	[pc, r2]
    291a:	7c7c      	.short	0x7c7c
    291c:	86868686 	.word	0x86868686
    2920:	86478686 	.word	0x86478686
    2924:	8686      	.short	0x8686
    2926:	07          	.byte	0x07
    2927:	00          	.byte	0x00
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    2928:	6808      	ldr	r0, [r1, #0]
    292a:	4d70      	ldr	r5, [pc, #448]	; (2aec <usb_isr+0x2e4>)
		setup.word2 = *(uint32_t *)(buf + 4);
    292c:	684a      	ldr	r2, [r1, #4]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    292e:	4f70      	ldr	r7, [pc, #448]	; (2af0 <usb_isr+0x2e8>)
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    2930:	4e70      	ldr	r6, [pc, #448]	; (2af4 <usb_isr+0x2ec>)
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    2932:	6028      	str	r0, [r5, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    2934:	b281      	uxth	r1, r0
    2936:	f240 6081 	movw	r0, #1665	; 0x681
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    293a:	4b67      	ldr	r3, [pc, #412]	; (2ad8 <usb_isr+0x2d0>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    293c:	606a      	str	r2, [r5, #4]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    293e:	f04f 0e01 	mov.w	lr, #1
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    2942:	2200      	movs	r2, #0
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    2944:	4281      	cmp	r1, r0
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    2946:	f849 3034 	str.w	r3, [r9, r4, lsl #3]
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    294a:	603a      	str	r2, [r7, #0]
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    294c:	f8c9 2010 	str.w	r2, [r9, #16]
		table[index(0, TX, ODD)].desc = 0;
    2950:	f8c9 2018 	str.w	r2, [r9, #24]
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    2954:	f886 e000 	strb.w	lr, [r6]
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    2958:	4c5b      	ldr	r4, [pc, #364]	; (2ac8 <usb_isr+0x2c0>)
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    295a:	f200 80e3 	bhi.w	2b24 <usb_isr+0x31c>
    295e:	f5b1 6fd0 	cmp.w	r1, #1664	; 0x680
    2962:	f080 8346 	bcs.w	2ff2 <usb_isr+0x7ea>
    2966:	f5b1 7f81 	cmp.w	r1, #258	; 0x102
    296a:	f000 82fc 	beq.w	2f66 <usb_isr+0x75e>
    296e:	f200 828d 	bhi.w	2e8c <usb_isr+0x684>
    2972:	2980      	cmp	r1, #128	; 0x80
    2974:	f000 8377 	beq.w	3066 <usb_isr+0x85e>
    2978:	2982      	cmp	r1, #130	; 0x82
    297a:	f040 82fa 	bne.w	2f72 <usb_isr+0x76a>
    297e:	88a9      	ldrh	r1, [r5, #4]
    2980:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    2984:	2904      	cmp	r1, #4
    2986:	f200 82f4 	bhi.w	2f72 <usb_isr+0x76a>
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    298a:	485b      	ldr	r0, [pc, #364]	; (2af8 <usb_isr+0x2f0>)
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    298c:	4c5b      	ldr	r4, [pc, #364]	; (2afc <usb_isr+0x2f4>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    298e:	0089      	lsls	r1, r1, #2
    2990:	4408      	add	r0, r1
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    2992:	7022      	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    2994:	7062      	strb	r2, [r4, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    2996:	7802      	ldrb	r2, [r0, #0]
    2998:	0793      	lsls	r3, r2, #30
    299a:	f140 8458 	bpl.w	324e <usb_isr+0xa46>
    299e:	f884 e000 	strb.w	lr, [r4]
		data = reply_buffer;
		datalen = 2;
    29a2:	f04f 0e02 	mov.w	lr, #2
    29a6:	e342      	b.n	302e <usb_isr+0x826>
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    29a8:	4f51      	ldr	r7, [pc, #324]	; (2af0 <usb_isr+0x2e8>)
    29aa:	683a      	ldr	r2, [r7, #0]
		if (data) {
    29ac:	b332      	cbz	r2, 29fc <usb_isr+0x1f4>
			size = ep0_tx_len;
    29ae:	4b54      	ldr	r3, [pc, #336]	; (2b00 <usb_isr+0x2f8>)
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    29b0:	4e50      	ldr	r6, [pc, #320]	; (2af4 <usb_isr+0x2ec>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    29b2:	4954      	ldr	r1, [pc, #336]	; (2b04 <usb_isr+0x2fc>)
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
    29b4:	8818      	ldrh	r0, [r3, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    29b6:	7834      	ldrb	r4, [r6, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    29b8:	780d      	ldrb	r5, [r1, #0]
    29ba:	2840      	cmp	r0, #64	; 0x40
    29bc:	4686      	mov	lr, r0
    29be:	f045 0802 	orr.w	r8, r5, #2
    29c2:	bf28      	it	cs
    29c4:	f04f 0e40 	movcs.w	lr, #64	; 0x40
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    29c8:	2c00      	cmp	r4, #0
	ep0_tx_data_toggle ^= 1;
    29ca:	f084 0401 	eor.w	r4, r4, #1
    29ce:	7034      	strb	r4, [r6, #0]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    29d0:	ebce 0000 	rsb	r0, lr, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    29d4:	bf0c      	ite	eq
    29d6:	2488      	moveq	r4, #136	; 0x88
    29d8:	24c8      	movne	r4, #200	; 0xc8
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    29da:	eb09 06c8 	add.w	r6, r9, r8, lsl #3
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    29de:	b280      	uxth	r0, r0
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    29e0:	f085 0501 	eor.w	r5, r5, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    29e4:	ea44 440e 	orr.w	r4, r4, lr, lsl #16
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    29e8:	6072      	str	r2, [r6, #4]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    29ea:	8018      	strh	r0, [r3, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    29ec:	f849 4038 	str.w	r4, [r9, r8, lsl #3]
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    29f0:	4472      	add	r2, lr
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    29f2:	700d      	strb	r5, [r1, #0]
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    29f4:	2800      	cmp	r0, #0
    29f6:	f000 8145 	beq.w	2c84 <usb_isr+0x47c>
    29fa:	603a      	str	r2, [r7, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    29fc:	4b3b      	ldr	r3, [pc, #236]	; (2aec <usb_isr+0x2e4>)
    29fe:	881a      	ldrh	r2, [r3, #0]
    2a00:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
    2a04:	d10f      	bne.n	2a26 <usb_isr+0x21e>
			setup.bRequest = 0;
    2a06:	2100      	movs	r1, #0
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    2a08:	789a      	ldrb	r2, [r3, #2]
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
			setup.bRequest = 0;
    2a0a:	7059      	strb	r1, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    2a0c:	4b3e      	ldr	r3, [pc, #248]	; (2b08 <usb_isr+0x300>)
    2a0e:	701a      	strb	r2, [r3, #0]
    2a10:	e009      	b.n	2a26 <usb_isr+0x21e>
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
#ifdef CDC_STATUS_INTERFACE
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    2a12:	4a36      	ldr	r2, [pc, #216]	; (2aec <usb_isr+0x2e4>)
    2a14:	8810      	ldrh	r0, [r2, #0]
    2a16:	f242 0221 	movw	r2, #8225	; 0x2021
    2a1a:	4290      	cmp	r0, r2
    2a1c:	f000 8137 	beq.w	2c8e <usb_isr+0x486>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    2a20:	4a2d      	ldr	r2, [pc, #180]	; (2ad8 <usb_isr+0x2d0>)
    2a22:	f849 2034 	str.w	r2, [r9, r4, lsl #3]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    2a26:	4a39      	ldr	r2, [pc, #228]	; (2b0c <usb_isr+0x304>)
    2a28:	2301      	movs	r3, #1
    2a2a:	7013      	strb	r3, [r2, #0]
    2a2c:	e736      	b.n	289c <usb_isr+0x94>
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    2a2e:	4a2a      	ldr	r2, [pc, #168]	; (2ad8 <usb_isr+0x2d0>)
    2a30:	4b2a      	ldr	r3, [pc, #168]	; (2adc <usb_isr+0x2d4>)
    2a32:	f019 0f08 	tst.w	r9, #8
    2a36:	bf18      	it	ne
    2a38:	4613      	movne	r3, r2
    2a3a:	f847 3038 	str.w	r3, [r7, r8, lsl #3]
    2a3e:	e72d      	b.n	289c <usb_isr+0x94>
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
    2a40:	f000 fcea 	bl	3418 <usb_free>
				packet = tx_first[endpoint];
    2a44:	4a32      	ldr	r2, [pc, #200]	; (2b10 <usb_isr+0x308>)
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    2a46:	4933      	ldr	r1, [pc, #204]	; (2b14 <usb_isr+0x30c>)
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
    2a48:	f852 3026 	ldr.w	r3, [r2, r6, lsl #2]
				if (packet) {
    2a4c:	2b00      	cmp	r3, #0
    2a4e:	f000 81d1 	beq.w	2df4 <usb_isr+0x5ec>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    2a52:	6858      	ldr	r0, [r3, #4]
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    2a54:	5d8c      	ldrb	r4, [r1, r6]
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    2a56:	f842 0026 	str.w	r0, [r2, r6, lsl #2]
					b->addr = packet->buf;
    2a5a:	f103 0208 	add.w	r2, r3, #8
    2a5e:	f8c9 2004 	str.w	r2, [r9, #4]
					switch (tx_state[endpoint]) {
    2a62:	2c03      	cmp	r4, #3
    2a64:	d805      	bhi.n	2a72 <usb_isr+0x26a>
    2a66:	e8df f004 	tbb	[pc, r4]
    2a6a:	022c      	.short	0x022c
    2a6c:	2629      	.short	0x2629
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    2a6e:	2202      	movs	r2, #2
    2a70:	558a      	strb	r2, [r1, r6]
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    2a72:	881a      	ldrh	r2, [r3, #0]
    2a74:	f019 0f08 	tst.w	r9, #8
    2a78:	bf0c      	ite	eq
    2a7a:	2388      	moveq	r3, #136	; 0x88
    2a7c:	23c8      	movne	r3, #200	; 0xc8
    2a7e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    2a82:	f847 3038 	str.w	r3, [r7, r8, lsl #3]
    2a86:	e709      	b.n	289c <usb_isr+0x94>
		goto restart;
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    2a88:	07e0      	lsls	r0, r4, #31
    2a8a:	f100 8181 	bmi.w	2d90 <usb_isr+0x588>
		USB0_CTL = USB_CTL_USBENSOFEN;
		return;
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    2a8e:	0621      	lsls	r1, r4, #24
    2a90:	f100 81f2 	bmi.w	2e78 <usb_isr+0x670>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    2a94:	07a2      	lsls	r2, r4, #30
    2a96:	d506      	bpl.n	2aa6 <usb_isr+0x29e>
		uint8_t err = USB0_ERRSTAT;
    2a98:	4a1f      	ldr	r2, [pc, #124]	; (2b18 <usb_isr+0x310>)
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    2a9a:	4920      	ldr	r1, [pc, #128]	; (2b1c <usb_isr+0x314>)
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    2a9c:	7813      	ldrb	r3, [r2, #0]
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    2a9e:	2002      	movs	r0, #2
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    2aa0:	b2db      	uxtb	r3, r3
		USB0_ERRSTAT = err;
    2aa2:	7013      	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    2aa4:	7008      	strb	r0, [r1, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    2aa6:	06e3      	lsls	r3, r4, #27
    2aa8:	d502      	bpl.n	2ab0 <usb_isr+0x2a8>
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    2aaa:	4b1c      	ldr	r3, [pc, #112]	; (2b1c <usb_isr+0x314>)
    2aac:	2210      	movs	r2, #16
    2aae:	701a      	strb	r2, [r3, #0]
	}

}
    2ab0:	b007      	add	sp, #28
    2ab2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    2ab6:	2204      	movs	r2, #4
    2ab8:	558a      	strb	r2, [r1, r6]
						break;
    2aba:	e7da      	b.n	2a72 <usb_isr+0x26a>
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    2abc:	2205      	movs	r2, #5
    2abe:	558a      	strb	r2, [r1, r6]
						break;
    2ac0:	e7d7      	b.n	2a72 <usb_isr+0x26a>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    2ac2:	2203      	movs	r2, #3
    2ac4:	558a      	strb	r2, [r1, r6]
						break;
    2ac6:	e7d4      	b.n	2a72 <usb_isr+0x26a>
    2ac8:	1fff0000 	.word	0x1fff0000
    2acc:	1fff1674 	.word	0x1fff1674
    2ad0:	1fff1620 	.word	0x1fff1620
    2ad4:	1fff1a6c 	.word	0x1fff1a6c
    2ad8:	004000c8 	.word	0x004000c8
    2adc:	00400088 	.word	0x00400088
    2ae0:	1fff16fc 	.word	0x1fff16fc
    2ae4:	1fff1685 	.word	0x1fff1685
    2ae8:	1fff1704 	.word	0x1fff1704
    2aec:	1fff16e8 	.word	0x1fff16e8
    2af0:	1fff161c 	.word	0x1fff161c
    2af4:	1fff1684 	.word	0x1fff1684
    2af8:	400720c0 	.word	0x400720c0
    2afc:	1fff16f4 	.word	0x1fff16f4
    2b00:	1fff1630 	.word	0x1fff1630
    2b04:	1fff16f0 	.word	0x1fff16f0
    2b08:	40072098 	.word	0x40072098
    2b0c:	40072094 	.word	0x40072094
    2b10:	1fff16c8 	.word	0x1fff16c8
    2b14:	1fff1700 	.word	0x1fff1700
    2b18:	40072088 	.word	0x40072088
    2b1c:	40072080 	.word	0x40072080
    2b20:	40072090 	.word	0x40072090
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    2b24:	f242 0021 	movw	r0, #8225	; 0x2021
    2b28:	4281      	cmp	r1, r0
    2b2a:	f000 812a 	beq.w	2d82 <usb_isr+0x57a>
    2b2e:	f200 80d8 	bhi.w	2ce2 <usb_isr+0x4da>
    2b32:	f5b1 6f08 	cmp.w	r1, #2176	; 0x880
    2b36:	f000 8276 	beq.w	3026 <usb_isr+0x81e>
    2b3a:	f5b1 6f10 	cmp.w	r1, #2304	; 0x900
    2b3e:	f040 8218 	bne.w	2f72 <usb_isr+0x76a>
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    2b42:	6a22      	ldr	r2, [r4, #32]
	switch (setup.wRequestAndType) {
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    2b44:	49b3      	ldr	r1, [pc, #716]	; (2e14 <usb_isr+0x60c>)
    2b46:	78a8      	ldrb	r0, [r5, #2]
    2b48:	7008      	strb	r0, [r1, #0]
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    2b4a:	0612      	lsls	r2, r2, #24
    2b4c:	f100 833a 	bmi.w	31c4 <usb_isr+0x9bc>
    2b50:	f8d9 2028 	ldr.w	r2, [r9, #40]	; 0x28
    2b54:	49b0      	ldr	r1, [pc, #704]	; (2e18 <usb_isr+0x610>)
    2b56:	0613      	lsls	r3, r2, #24
    2b58:	f100 830c 	bmi.w	3174 <usb_isr+0x96c>
    2b5c:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
    2b60:	49ad      	ldr	r1, [pc, #692]	; (2e18 <usb_isr+0x610>)
    2b62:	0615      	lsls	r5, r2, #24
    2b64:	f100 8301 	bmi.w	316a <usb_isr+0x962>
    2b68:	f8d9 2038 	ldr.w	r2, [r9, #56]	; 0x38
    2b6c:	49aa      	ldr	r1, [pc, #680]	; (2e18 <usb_isr+0x610>)
    2b6e:	0614      	lsls	r4, r2, #24
    2b70:	f100 82f6 	bmi.w	3160 <usb_isr+0x958>
    2b74:	f8d9 2040 	ldr.w	r2, [r9, #64]	; 0x40
    2b78:	49a7      	ldr	r1, [pc, #668]	; (2e18 <usb_isr+0x610>)
    2b7a:	0610      	lsls	r0, r2, #24
    2b7c:	f100 834a 	bmi.w	3214 <usb_isr+0xa0c>
    2b80:	f8d9 2048 	ldr.w	r2, [r9, #72]	; 0x48
    2b84:	49a4      	ldr	r1, [pc, #656]	; (2e18 <usb_isr+0x610>)
    2b86:	0612      	lsls	r2, r2, #24
    2b88:	f100 833f 	bmi.w	320a <usb_isr+0xa02>
    2b8c:	f8d9 2050 	ldr.w	r2, [r9, #80]	; 0x50
    2b90:	49a1      	ldr	r1, [pc, #644]	; (2e18 <usb_isr+0x610>)
    2b92:	0613      	lsls	r3, r2, #24
    2b94:	f100 8334 	bmi.w	3200 <usb_isr+0x9f8>
    2b98:	f8d9 2058 	ldr.w	r2, [r9, #88]	; 0x58
    2b9c:	499e      	ldr	r1, [pc, #632]	; (2e18 <usb_isr+0x610>)
    2b9e:	0615      	lsls	r5, r2, #24
    2ba0:	f100 8329 	bmi.w	31f6 <usb_isr+0x9ee>
    2ba4:	f8d9 2060 	ldr.w	r2, [r9, #96]	; 0x60
    2ba8:	499b      	ldr	r1, [pc, #620]	; (2e18 <usb_isr+0x610>)
    2baa:	0614      	lsls	r4, r2, #24
    2bac:	f100 831e 	bmi.w	31ec <usb_isr+0x9e4>
    2bb0:	f8d9 2068 	ldr.w	r2, [r9, #104]	; 0x68
    2bb4:	4998      	ldr	r1, [pc, #608]	; (2e18 <usb_isr+0x610>)
    2bb6:	0610      	lsls	r0, r2, #24
    2bb8:	f100 8313 	bmi.w	31e2 <usb_isr+0x9da>
    2bbc:	f8d9 2070 	ldr.w	r2, [r9, #112]	; 0x70
    2bc0:	4995      	ldr	r1, [pc, #596]	; (2e18 <usb_isr+0x610>)
    2bc2:	0612      	lsls	r2, r2, #24
    2bc4:	f100 8308 	bmi.w	31d8 <usb_isr+0x9d0>
    2bc8:	f8d9 2078 	ldr.w	r2, [r9, #120]	; 0x78
    2bcc:	4992      	ldr	r1, [pc, #584]	; (2e18 <usb_isr+0x610>)
    2bce:	0613      	lsls	r3, r2, #24
    2bd0:	f100 82fd 	bmi.w	31ce <usb_isr+0x9c6>
    2bd4:	f8d9 2080 	ldr.w	r2, [r9, #128]	; 0x80
    2bd8:	498f      	ldr	r1, [pc, #572]	; (2e18 <usb_isr+0x610>)
    2bda:	0615      	lsls	r5, r2, #24
    2bdc:	f100 8331 	bmi.w	3242 <usb_isr+0xa3a>
    2be0:	f8d9 2088 	ldr.w	r2, [r9, #136]	; 0x88
    2be4:	498c      	ldr	r1, [pc, #560]	; (2e18 <usb_isr+0x610>)
    2be6:	0614      	lsls	r4, r2, #24
    2be8:	f100 8325 	bmi.w	3236 <usb_isr+0xa2e>
    2bec:	f8d9 2090 	ldr.w	r2, [r9, #144]	; 0x90
    2bf0:	4989      	ldr	r1, [pc, #548]	; (2e18 <usb_isr+0x610>)
    2bf2:	0610      	lsls	r0, r2, #24
    2bf4:	f100 8319 	bmi.w	322a <usb_isr+0xa22>
    2bf8:	f8d9 2098 	ldr.w	r2, [r9, #152]	; 0x98
    2bfc:	4986      	ldr	r1, [pc, #536]	; (2e18 <usb_isr+0x610>)
    2bfe:	0612      	lsls	r2, r2, #24
    2c00:	f100 830d 	bmi.w	321e <usb_isr+0xa16>
    2c04:	4885      	ldr	r0, [pc, #532]	; (2e1c <usb_isr+0x614>)
    2c06:	4a86      	ldr	r2, [pc, #536]	; (2e20 <usb_isr+0x618>)
    2c08:	4986      	ldr	r1, [pc, #536]	; (2e24 <usb_isr+0x61c>)
    2c0a:	9001      	str	r0, [sp, #4]
    2c0c:	4886      	ldr	r0, [pc, #536]	; (2e28 <usb_isr+0x620>)
    2c0e:	4d87      	ldr	r5, [pc, #540]	; (2e2c <usb_isr+0x624>)
    2c10:	4c87      	ldr	r4, [pc, #540]	; (2e30 <usb_isr+0x628>)
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    2c12:	9704      	str	r7, [sp, #16]
}



void usb_isr(void)
{
    2c14:	2300      	movs	r3, #0
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    2c16:	9605      	str	r6, [sp, #20]
    2c18:	9502      	str	r5, [sp, #8]
    2c1a:	4680      	mov	r8, r0
    2c1c:	460f      	mov	r7, r1
    2c1e:	4616      	mov	r6, r2
    2c20:	461d      	mov	r5, r3
    2c22:	9403      	str	r4, [sp, #12]
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    2c24:	6830      	ldr	r0, [r6, #0]
			while (p) {
    2c26:	b128      	cbz	r0, 2c34 <usb_isr+0x42c>
				n = p->next;
    2c28:	6844      	ldr	r4, [r0, #4]
				usb_free(p);
    2c2a:	f000 fbf5 	bl	3418 <usb_free>
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
			while (p) {
    2c2e:	4620      	mov	r0, r4
    2c30:	2c00      	cmp	r4, #0
    2c32:	d1f9      	bne.n	2c28 <usb_isr+0x420>
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    2c34:	2300      	movs	r3, #0
    2c36:	6033      	str	r3, [r6, #0]
			rx_last[i] = NULL;
    2c38:	9b02      	ldr	r3, [sp, #8]
			p = tx_first[i];
    2c3a:	6838      	ldr	r0, [r7, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
    2c3c:	461a      	mov	r2, r3
    2c3e:	2300      	movs	r3, #0
    2c40:	f842 3025 	str.w	r3, [r2, r5, lsl #2]
			p = tx_first[i];
			while (p) {
    2c44:	b128      	cbz	r0, 2c52 <usb_isr+0x44a>
				n = p->next;
    2c46:	6844      	ldr	r4, [r0, #4]
				usb_free(p);
    2c48:	f000 fbe6 	bl	3418 <usb_free>
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
			p = tx_first[i];
			while (p) {
    2c4c:	4620      	mov	r0, r4
    2c4e:	2c00      	cmp	r4, #0
    2c50:	d1f9      	bne.n	2c46 <usb_isr+0x43e>
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    2c52:	2200      	movs	r2, #0
    2c54:	603a      	str	r2, [r7, #0]
			tx_last[i] = NULL;
    2c56:	9a01      	ldr	r2, [sp, #4]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    2c58:	f898 3000 	ldrb.w	r3, [r8]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    2c5c:	4611      	mov	r1, r2
    2c5e:	2200      	movs	r2, #0
    2c60:	f841 2b04 	str.w	r2, [r1], #4
			usb_rx_byte_count_data[i] = 0;
    2c64:	9a03      	ldr	r2, [sp, #12]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    2c66:	9101      	str	r1, [sp, #4]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    2c68:	3b02      	subs	r3, #2
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    2c6a:	f04f 0100 	mov.w	r1, #0
    2c6e:	f822 1015 	strh.w	r1, [r2, r5, lsl #1]
			switch (tx_state[i]) {
    2c72:	2b03      	cmp	r3, #3
    2c74:	f200 812b 	bhi.w	2ece <usb_isr+0x6c6>
    2c78:	e8df f013 	tbh	[pc, r3, lsl #1]
    2c7c:	01250170 	.word	0x01250170
    2c80:	01250170 	.word	0x01250170
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    2c84:	f1be 0f40 	cmp.w	lr, #64	; 0x40
    2c88:	bf18      	it	ne
    2c8a:	2200      	movne	r2, #0
    2c8c:	e6b5      	b.n	29fa <usb_isr+0x1f2>
			int i;
			uint8_t *dst = (uint8_t *)usb_cdc_line_coding;
			//serial_print("set line coding ");
			for (i=0; i<7; i++) {
				//serial_phex(*buf);
				*dst++ = *buf++;
    2c8e:	4a69      	ldr	r2, [pc, #420]	; (2e34 <usb_isr+0x62c>)
    2c90:	780d      	ldrb	r5, [r1, #0]
    2c92:	7848      	ldrb	r0, [r1, #1]
    2c94:	7015      	strb	r5, [r2, #0]
    2c96:	7050      	strb	r0, [r2, #1]
    2c98:	788d      	ldrb	r5, [r1, #2]
    2c9a:	78c8      	ldrb	r0, [r1, #3]
    2c9c:	7095      	strb	r5, [r2, #2]
    2c9e:	70d0      	strb	r0, [r2, #3]
			}
			//serial_phex32(usb_cdc_line_coding[0]);
			//serial_print("\n");
			if (usb_cdc_line_coding[0] == 134) usb_reboot_timer = 15;
    2ca0:	6810      	ldr	r0, [r2, #0]
			int i;
			uint8_t *dst = (uint8_t *)usb_cdc_line_coding;
			//serial_print("set line coding ");
			for (i=0; i<7; i++) {
				//serial_phex(*buf);
				*dst++ = *buf++;
    2ca2:	790d      	ldrb	r5, [r1, #4]
    2ca4:	7115      	strb	r5, [r2, #4]
			}
			//serial_phex32(usb_cdc_line_coding[0]);
			//serial_print("\n");
			if (usb_cdc_line_coding[0] == 134) usb_reboot_timer = 15;
    2ca6:	2886      	cmp	r0, #134	; 0x86
			int i;
			uint8_t *dst = (uint8_t *)usb_cdc_line_coding;
			//serial_print("set line coding ");
			for (i=0; i<7; i++) {
				//serial_phex(*buf);
				*dst++ = *buf++;
    2ca8:	794d      	ldrb	r5, [r1, #5]
    2caa:	7989      	ldrb	r1, [r1, #6]
    2cac:	7155      	strb	r5, [r2, #5]
    2cae:	7191      	strb	r1, [r2, #6]
			}
			//serial_phex32(usb_cdc_line_coding[0]);
			//serial_print("\n");
			if (usb_cdc_line_coding[0] == 134) usb_reboot_timer = 15;
    2cb0:	f000 819b 	beq.w	2fea <usb_isr+0x7e2>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    2cb4:	4960      	ldr	r1, [pc, #384]	; (2e38 <usb_isr+0x630>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2cb6:	4e61      	ldr	r6, [pc, #388]	; (2e3c <usb_isr+0x634>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    2cb8:	780a      	ldrb	r2, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2cba:	7830      	ldrb	r0, [r6, #0]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    2cbc:	f082 0501 	eor.w	r5, r2, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2cc0:	2800      	cmp	r0, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    2cc2:	f042 0202 	orr.w	r2, r2, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    2cc6:	700d      	strb	r5, [r1, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2cc8:	bf0c      	ite	eq
    2cca:	2188      	moveq	r1, #136	; 0x88
    2ccc:	21c8      	movne	r1, #200	; 0xc8
    2cce:	f849 1032 	str.w	r1, [r9, r2, lsl #3]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    2cd2:	eb09 02c2 	add.w	r2, r9, r2, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    2cd6:	f080 0001 	eor.w	r0, r0, #1
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    2cda:	2100      	movs	r1, #0
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    2cdc:	7030      	strb	r0, [r6, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    2cde:	6051      	str	r1, [r2, #4]
    2ce0:	e69e      	b.n	2a20 <usb_isr+0x218>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    2ce2:	f242 2021 	movw	r0, #8737	; 0x2221
    2ce6:	4281      	cmp	r1, r0
    2ce8:	f040 81cb 	bne.w	3082 <usb_isr+0x87a>
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		usb_cdc_line_rtsdtr_millis = systick_millis_count;
    2cec:	4b54      	ldr	r3, [pc, #336]	; (2e40 <usb_isr+0x638>)
    2cee:	4c55      	ldr	r4, [pc, #340]	; (2e44 <usb_isr+0x63c>)
		usb_cdc_line_rtsdtr = setup.wValue;
    2cf0:	4955      	ldr	r1, [pc, #340]	; (2e48 <usb_isr+0x640>)
    2cf2:	78a8      	ldrb	r0, [r5, #2]
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		usb_cdc_line_rtsdtr_millis = systick_millis_count;
    2cf4:	681d      	ldr	r5, [r3, #0]
    2cf6:	6025      	str	r5, [r4, #0]
		usb_cdc_line_rtsdtr = setup.wValue;
    2cf8:	f8cd e004 	str.w	lr, [sp, #4]
    2cfc:	7008      	strb	r0, [r1, #0]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    2cfe:	2000      	movs	r0, #0
    2d00:	9002      	str	r0, [sp, #8]
    2d02:	4680      	mov	r8, r0
    2d04:	4684      	mov	ip, r0
    2d06:	4604      	mov	r4, r0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    2d08:	494b      	ldr	r1, [pc, #300]	; (2e38 <usb_isr+0x630>)
    2d0a:	780d      	ldrb	r5, [r1, #0]
    2d0c:	f045 0e02 	orr.w	lr, r5, #2
    2d10:	eb09 03ce 	add.w	r3, r9, lr, lsl #3
    2d14:	9303      	str	r3, [sp, #12]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2d16:	9b01      	ldr	r3, [sp, #4]
    2d18:	2b00      	cmp	r3, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    2d1a:	9b03      	ldr	r3, [sp, #12]
    2d1c:	605c      	str	r4, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2d1e:	bf0c      	ite	eq
    2d20:	2488      	moveq	r4, #136	; 0x88
    2d22:	24c8      	movne	r4, #200	; 0xc8
    2d24:	ea44 0308 	orr.w	r3, r4, r8
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    2d28:	f085 0401 	eor.w	r4, r5, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2d2c:	f849 303e 	str.w	r3, [r9, lr, lsl #3]
	ep0_tx_data_toggle ^= 1;
    2d30:	7032      	strb	r2, [r6, #0]
	ep0_tx_bdt_bank ^= 1;
    2d32:	700c      	strb	r4, [r1, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2d34:	f8df e0e0 	ldr.w	lr, [pc, #224]	; 2e18 <usb_isr+0x610>
	ep0_tx_data_toggle ^= 1;
    2d38:	4b40      	ldr	r3, [pc, #256]	; (2e3c <usb_isr+0x634>)
	ep0_tx_bdt_bank ^= 1;
    2d3a:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 2e38 <usb_isr+0x630>
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    2d3e:	2800      	cmp	r0, #0
    2d40:	f040 811e 	bne.w	2f80 <usb_isr+0x778>
    2d44:	f1bc 0f40 	cmp.w	ip, #64	; 0x40
    2d48:	d11b      	bne.n	2d82 <usb_isr+0x57a>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    2d4a:	f044 0c02 	orr.w	ip, r4, #2
    2d4e:	eb09 03cc 	add.w	r3, r9, ip, lsl #3
    2d52:	9c02      	ldr	r4, [sp, #8]
    2d54:	f8df e0c0 	ldr.w	lr, [pc, #192]	; 2e18 <usb_isr+0x610>
    2d58:	605c      	str	r4, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2d5a:	2a00      	cmp	r2, #0
    2d5c:	f040 8126 	bne.w	2fac <usb_isr+0x7a4>
    2d60:	0402      	lsls	r2, r0, #16
    2d62:	f042 0288 	orr.w	r2, r2, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    2d66:	f89d 3004 	ldrb.w	r3, [sp, #4]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2d6a:	f84e 203c 	str.w	r2, [lr, ip, lsl #3]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    2d6e:	4404      	add	r4, r0
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    2d70:	7033      	strb	r3, [r6, #0]
	ep0_tx_bdt_bank ^= 1;
    2d72:	700d      	strb	r5, [r1, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    2d74:	4623      	mov	r3, r4
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    2d76:	2840      	cmp	r0, #64	; 0x40
    2d78:	d103      	bne.n	2d82 <usb_isr+0x57a>
    2d7a:	2000      	movs	r0, #0

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    2d7c:	4a33      	ldr	r2, [pc, #204]	; (2e4c <usb_isr+0x644>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    2d7e:	603b      	str	r3, [r7, #0]
	ep0_tx_len = datalen;
    2d80:	8010      	strh	r0, [r2, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    2d82:	4a33      	ldr	r2, [pc, #204]	; (2e50 <usb_isr+0x648>)
    2d84:	2301      	movs	r3, #1
    2d86:	7013      	strb	r3, [r2, #0]
    2d88:	e64d      	b.n	2a26 <usb_isr+0x21e>
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
			if (t) {
				usb_cdc_transmit_flush_timer = --t;
				if (t == 0) usb_serial_flush_callback();
    2d8a:	f000 fcb1 	bl	36f0 <usb_serial_flush_callback>
    2d8e:	e5a5      	b.n	28dc <usb_isr+0xd4>
		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    2d90:	4b21      	ldr	r3, [pc, #132]	; (2e18 <usb_isr+0x610>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    2d92:	482f      	ldr	r0, [pc, #188]	; (2e50 <usb_isr+0x648>)
		ep0_tx_bdt_bank = 0;
    2d94:	4928      	ldr	r1, [pc, #160]	; (2e38 <usb_isr+0x630>)
		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
    2d96:	611a      	str	r2, [r3, #16]

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    2d98:	f04f 0e02 	mov.w	lr, #2
    2d9c:	f880 e000 	strb.w	lr, [r0]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    2da0:	4f2c      	ldr	r7, [pc, #176]	; (2e54 <usb_isr+0x64c>)
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    2da2:	700a      	strb	r2, [r1, #0]

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    2da4:	492c      	ldr	r1, [pc, #176]	; (2e58 <usb_isr+0x650>)
    2da6:	6019      	str	r1, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    2da8:	6099      	str	r1, [r3, #8]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    2daa:	4e2c      	ldr	r6, [pc, #176]	; (2e5c <usb_isr+0x654>)
		USB0_ISTAT = 0xFF;
    2dac:	4d2c      	ldr	r5, [pc, #176]	; (2e60 <usb_isr+0x658>)

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    2dae:	4c2d      	ldr	r4, [pc, #180]	; (2e64 <usb_isr+0x65c>)
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    2db0:	619a      	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    2db2:	210d      	movs	r1, #13
    2db4:	7039      	strb	r1, [r7, #0]

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    2db6:	21ff      	movs	r1, #255	; 0xff
    2db8:	7031      	strb	r1, [r6, #0]

		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
    2dba:	f8df e0b8 	ldr.w	lr, [pc, #184]	; 2e74 <usb_isr+0x66c>
		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
		USB0_ISTAT = 0xFF;
    2dbe:	7029      	strb	r1, [r5, #0]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    2dc0:	7022      	strb	r2, [r4, #0]
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    2dc2:	4d29      	ldr	r5, [pc, #164]	; (2e68 <usb_isr+0x660>)
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    2dc4:	4a29      	ldr	r2, [pc, #164]	; (2e6c <usb_isr+0x664>)

		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
    2dc6:	f88e 1000 	strb.w	r1, [lr]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    2dca:	279f      	movs	r7, #159	; 0x9f
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    2dcc:	2401      	movs	r4, #1
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    2dce:	f806 7c04 	strb.w	r7, [r6, #-4]
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    2dd2:	605d      	str	r5, [r3, #4]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    2dd4:	7004      	strb	r4, [r0, #0]

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    2dd6:	60da      	str	r2, [r3, #12]
	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
	}

}
    2dd8:	b007      	add	sp, #28
    2dda:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    2dde:	4a24      	ldr	r2, [pc, #144]	; (2e70 <usb_isr+0x668>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    2de0:	f847 0038 	str.w	r0, [r7, r8, lsl #3]
						usb_rx_memory_needed++;
    2de4:	7813      	ldrb	r3, [r2, #0]
    2de6:	3301      	adds	r3, #1
    2de8:	7013      	strb	r3, [r2, #0]
    2dea:	e557      	b.n	289c <usb_isr+0x94>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    2dec:	f843 0026 	str.w	r0, [r3, r6, lsl #2]
    2df0:	4d0e      	ldr	r5, [pc, #56]	; (2e2c <usb_isr+0x624>)
    2df2:	e53a      	b.n	286a <usb_isr+0x62>
					}
					b->desc = BDT_DESC(packet->len,
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    2df4:	5d8b      	ldrb	r3, [r1, r6]
    2df6:	2b03      	cmp	r3, #3
    2df8:	f200 80f0 	bhi.w	2fdc <usb_isr+0x7d4>
    2dfc:	a201      	add	r2, pc, #4	; (adr r2, 2e04 <usb_isr+0x5fc>)
    2dfe:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    2e02:	bf00      	nop
    2e04:	0000289d 	.word	0x0000289d
    2e08:	0000289d 	.word	0x0000289d
    2e0c:	00002ec1 	.word	0x00002ec1
    2e10:	00002ebb 	.word	0x00002ebb
    2e14:	1fff16fc 	.word	0x1fff16fc
    2e18:	1fff0000 	.word	0x1fff0000
    2e1c:	1fff16d8 	.word	0x1fff16d8
    2e20:	1fff1674 	.word	0x1fff1674
    2e24:	1fff16c8 	.word	0x1fff16c8
    2e28:	1fff1700 	.word	0x1fff1700
    2e2c:	1fff1620 	.word	0x1fff1620
    2e30:	1fff1a6c 	.word	0x1fff1a6c
    2e34:	1fff1a74 	.word	0x1fff1a74
    2e38:	1fff16f0 	.word	0x1fff16f0
    2e3c:	1fff1684 	.word	0x1fff1684
    2e40:	1fff1618 	.word	0x1fff1618
    2e44:	1fff1a7c 	.word	0x1fff1a7c
    2e48:	1fff1714 	.word	0x1fff1714
    2e4c:	1fff1630 	.word	0x1fff1630
    2e50:	40072094 	.word	0x40072094
    2e54:	400720c0 	.word	0x400720c0
    2e58:	00400088 	.word	0x00400088
    2e5c:	40072088 	.word	0x40072088
    2e60:	40072080 	.word	0x40072080
    2e64:	40072098 	.word	0x40072098
    2e68:	1fff1634 	.word	0x1fff1634
    2e6c:	1fff1688 	.word	0x1fff1688
    2e70:	1fff16f1 	.word	0x1fff16f1
    2e74:	4007208c 	.word	0x4007208c
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    2e78:	49c1      	ldr	r1, [pc, #772]	; (3180 <usb_isr+0x978>)
		USB0_ISTAT = USB_ISTAT_STALL;
    2e7a:	4bc2      	ldr	r3, [pc, #776]	; (3184 <usb_isr+0x97c>)
    2e7c:	2280      	movs	r2, #128	; 0x80
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    2e7e:	200d      	movs	r0, #13
    2e80:	7008      	strb	r0, [r1, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    2e82:	701a      	strb	r2, [r3, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    2e84:	07a2      	lsls	r2, r4, #30
    2e86:	f57f ae0e 	bpl.w	2aa6 <usb_isr+0x29e>
    2e8a:	e605      	b.n	2a98 <usb_isr+0x290>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    2e8c:	f240 3202 	movw	r2, #770	; 0x302
    2e90:	4291      	cmp	r1, r2
    2e92:	f040 80ee 	bne.w	3072 <usb_isr+0x86a>
    2e96:	88a9      	ldrh	r1, [r5, #4]
    2e98:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    2e9c:	2904      	cmp	r1, #4
    2e9e:	d868      	bhi.n	2f72 <usb_isr+0x76a>
    2ea0:	886a      	ldrh	r2, [r5, #2]
    2ea2:	2a00      	cmp	r2, #0
    2ea4:	d165      	bne.n	2f72 <usb_isr+0x76a>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    2ea6:	48b6      	ldr	r0, [pc, #728]	; (3180 <usb_isr+0x978>)
    2ea8:	f8cd e004 	str.w	lr, [sp, #4]
    2eac:	0089      	lsls	r1, r1, #2
    2eae:	4408      	add	r0, r1
    2eb0:	7801      	ldrb	r1, [r0, #0]
    2eb2:	f041 0102 	orr.w	r1, r1, #2
    2eb6:	7001      	strb	r1, [r0, #0]
    2eb8:	e721      	b.n	2cfe <usb_isr+0x4f6>
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    2eba:	2301      	movs	r3, #1
    2ebc:	558b      	strb	r3, [r1, r6]
						break;
    2ebe:	e4ed      	b.n	289c <usb_isr+0x94>
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    2ec0:	2300      	movs	r3, #0
    2ec2:	558b      	strb	r3, [r1, r6]
						break;
    2ec4:	e4ea      	b.n	289c <usb_isr+0x94>
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    2ec6:	f04f 0301 	mov.w	r3, #1
    2eca:	f888 3000 	strb.w	r3, [r8]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    2ece:	3501      	adds	r5, #1
    2ed0:	2d04      	cmp	r5, #4
    2ed2:	f106 0604 	add.w	r6, r6, #4
    2ed6:	f107 0704 	add.w	r7, r7, #4
    2eda:	f108 0801 	add.w	r8, r8, #1
    2ede:	f47f aea1 	bne.w	2c24 <usb_isr+0x41c>
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    2ee2:	4ca9      	ldr	r4, [pc, #676]	; (3188 <usb_isr+0x980>)
			*reg = epconf;
    2ee4:	4ba9      	ldr	r3, [pc, #676]	; (318c <usb_isr+0x984>)
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    2ee6:	7822      	ldrb	r2, [r4, #0]
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    2ee8:	4da9      	ldr	r5, [pc, #676]	; (3190 <usb_isr+0x988>)
    2eea:	9f04      	ldr	r7, [sp, #16]
    2eec:	9e05      	ldr	r6, [sp, #20]
    2eee:	2100      	movs	r1, #0
    2ef0:	7029      	strb	r1, [r5, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
			*reg = epconf;
    2ef2:	701a      	strb	r2, [r3, #0]
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    2ef4:	0713      	lsls	r3, r2, #28
    2ef6:	f100 8105 	bmi.w	3104 <usb_isr+0x8fc>
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    2efa:	7862      	ldrb	r2, [r4, #1]
			*reg = epconf;
    2efc:	49a5      	ldr	r1, [pc, #660]	; (3194 <usb_isr+0x98c>)
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    2efe:	f8df 82a0 	ldr.w	r8, [pc, #672]	; 31a0 <usb_isr+0x998>
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
			*reg = epconf;
    2f02:	700a      	strb	r2, [r1, #0]
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    2f04:	0710      	lsls	r0, r2, #28
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    2f06:	f04f 0100 	mov.w	r1, #0
    2f0a:	f8c9 1030 	str.w	r1, [r9, #48]	; 0x30
			table[index(i, TX, ODD)].desc = 0;
    2f0e:	f8c9 1038 	str.w	r1, [r9, #56]	; 0x38
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    2f12:	f100 80e0 	bmi.w	30d6 <usb_isr+0x8ce>
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
			*reg = epconf;
    2f16:	49a0      	ldr	r1, [pc, #640]	; (3198 <usb_isr+0x990>)
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    2f18:	78a2      	ldrb	r2, [r4, #2]
			*reg = epconf;
    2f1a:	700a      	strb	r2, [r1, #0]
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    2f1c:	2100      	movs	r1, #0
    2f1e:	f8c9 1050 	str.w	r1, [r9, #80]	; 0x50
			table[index(i, TX, ODD)].desc = 0;
    2f22:	f8c9 1058 	str.w	r1, [r9, #88]	; 0x58
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    2f26:	0711      	lsls	r1, r2, #28
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    2f28:	f8df 8274 	ldr.w	r8, [pc, #628]	; 31a0 <usb_isr+0x998>
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    2f2c:	f100 8101 	bmi.w	3132 <usb_isr+0x92a>
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    2f30:	78e2      	ldrb	r2, [r4, #3]
			*reg = epconf;
    2f32:	499a      	ldr	r1, [pc, #616]	; (319c <usb_isr+0x994>)
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    2f34:	4c9a      	ldr	r4, [pc, #616]	; (31a0 <usb_isr+0x998>)
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
			*reg = epconf;
    2f36:	700a      	strb	r2, [r1, #0]
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    2f38:	2100      	movs	r1, #0
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    2f3a:	0712      	lsls	r2, r2, #28
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    2f3c:	f8c9 1070 	str.w	r1, [r9, #112]	; 0x70
			table[index(i, TX, ODD)].desc = 0;
    2f40:	f8c9 1078 	str.w	r1, [r9, #120]	; 0x78
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    2f44:	f100 80b0 	bmi.w	30a8 <usb_isr+0x8a0>
    2f48:	7833      	ldrb	r3, [r6, #0]
    2f4a:	9301      	str	r3, [sp, #4]
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    2f4c:	2100      	movs	r1, #0
    2f4e:	f083 0201 	eor.w	r2, r3, #1
    2f52:	f8c9 1090 	str.w	r1, [r9, #144]	; 0x90
			table[index(i, TX, ODD)].desc = 0;
    2f56:	f8c9 1098 	str.w	r1, [r9, #152]	; 0x98
    2f5a:	e6d0      	b.n	2cfe <usb_isr+0x4f6>
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    2f5c:	f04f 0300 	mov.w	r3, #0
    2f60:	f888 3000 	strb.w	r3, [r8]
    2f64:	e7b3      	b.n	2ece <usb_isr+0x6c6>
    2f66:	88a9      	ldrh	r1, [r5, #4]
    2f68:	f001 017f 	and.w	r1, r1, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    2f6c:	2904      	cmp	r1, #4
    2f6e:	f240 808d 	bls.w	308c <usb_isr+0x884>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    2f72:	4a83      	ldr	r2, [pc, #524]	; (3180 <usb_isr+0x978>)
    2f74:	230f      	movs	r3, #15
    2f76:	7013      	strb	r3, [r2, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    2f78:	4a8a      	ldr	r2, [pc, #552]	; (31a4 <usb_isr+0x99c>)
    2f7a:	2301      	movs	r3, #1
    2f7c:	7013      	strb	r3, [r2, #0]
    2f7e:	e552      	b.n	2a26 <usb_isr+0x21e>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
    2f80:	2840      	cmp	r0, #64	; 0x40
    2f82:	f67f aee2 	bls.w	2d4a <usb_isr+0x542>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    2f86:	f044 0402 	orr.w	r4, r4, #2
    2f8a:	eb0e 01c4 	add.w	r1, lr, r4, lsl #3
    2f8e:	9e02      	ldr	r6, [sp, #8]
    2f90:	604e      	str	r6, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2f92:	b1ba      	cbz	r2, 2fc4 <usb_isr+0x7bc>
	ep0_tx_data_toggle ^= 1;
    2f94:	f89d 1004 	ldrb.w	r1, [sp, #4]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2f98:	4a83      	ldr	r2, [pc, #524]	; (31a8 <usb_isr+0x9a0>)
	ep0_tx_data_toggle ^= 1;
    2f9a:	7019      	strb	r1, [r3, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    2f9c:	4633      	mov	r3, r6
    2f9e:	3840      	subs	r0, #64	; 0x40
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    2fa0:	f888 5000 	strb.w	r5, [r8]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    2fa4:	3340      	adds	r3, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2fa6:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
    2faa:	e6e7      	b.n	2d7c <usb_isr+0x574>
	ep0_tx_data_toggle ^= 1;
    2fac:	f89d 3004 	ldrb.w	r3, [sp, #4]
    2fb0:	7033      	strb	r3, [r6, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2fb2:	0402      	lsls	r2, r0, #16
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    2fb4:	9b02      	ldr	r3, [sp, #8]
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    2fb6:	700d      	strb	r5, [r1, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2fb8:	f042 02c8 	orr.w	r2, r2, #200	; 0xc8
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    2fbc:	4403      	add	r3, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2fbe:	f84e 203c 	str.w	r2, [lr, ip, lsl #3]
    2fc2:	e6d8      	b.n	2d76 <usb_isr+0x56e>
	ep0_tx_data_toggle ^= 1;
    2fc4:	f89d 1004 	ldrb.w	r1, [sp, #4]
    2fc8:	7019      	strb	r1, [r3, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    2fca:	9b02      	ldr	r3, [sp, #8]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2fcc:	4a77      	ldr	r2, [pc, #476]	; (31ac <usb_isr+0x9a4>)
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    2fce:	f888 5000 	strb.w	r5, [r8]
    2fd2:	3840      	subs	r0, #64	; 0x40
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    2fd4:	3340      	adds	r3, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    2fd6:	f84e 2034 	str.w	r2, [lr, r4, lsl #3]
    2fda:	e6cf      	b.n	2d7c <usb_isr+0x574>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    2fdc:	f019 0f08 	tst.w	r9, #8
    2fe0:	bf0c      	ite	eq
    2fe2:	2302      	moveq	r3, #2
    2fe4:	2303      	movne	r3, #3
    2fe6:	558b      	strb	r3, [r1, r6]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    2fe8:	e458      	b.n	289c <usb_isr+0x94>
				//serial_phex(*buf);
				*dst++ = *buf++;
			}
			//serial_phex32(usb_cdc_line_coding[0]);
			//serial_print("\n");
			if (usb_cdc_line_coding[0] == 134) usb_reboot_timer = 15;
    2fea:	4a71      	ldr	r2, [pc, #452]	; (31b0 <usb_isr+0x9a8>)
    2fec:	210f      	movs	r1, #15
    2fee:	7011      	strb	r1, [r2, #0]
    2ff0:	e660      	b.n	2cb4 <usb_isr+0x4ac>
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    2ff2:	4a70      	ldr	r2, [pc, #448]	; (31b4 <usb_isr+0x9ac>)
    2ff4:	6854      	ldr	r4, [r2, #4]
    2ff6:	2c00      	cmp	r4, #0
    2ff8:	d0bb      	beq.n	2f72 <usb_isr+0x76a>
    2ffa:	8868      	ldrh	r0, [r5, #2]
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    2ffc:	f8b5 e004 	ldrh.w	lr, [r5, #4]
    3000:	e003      	b.n	300a <usb_isr+0x802>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    3002:	320c      	adds	r2, #12
			if (list->addr == NULL) break;
    3004:	6854      	ldr	r4, [r2, #4]
    3006:	2c00      	cmp	r4, #0
    3008:	d0b3      	beq.n	2f72 <usb_isr+0x76a>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    300a:	8813      	ldrh	r3, [r2, #0]
    300c:	4283      	cmp	r3, r0
    300e:	d1f8      	bne.n	3002 <usb_isr+0x7fa>
    3010:	8853      	ldrh	r3, [r2, #2]
    3012:	4573      	cmp	r3, lr
    3014:	d1f5      	bne.n	3002 <usb_isr+0x7fa>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    3016:	0a00      	lsrs	r0, r0, #8
    3018:	2803      	cmp	r0, #3
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    301a:	bf0c      	ite	eq
    301c:	f894 e000 	ldrbeq.w	lr, [r4]
				} else {
					datalen = list->length;
    3020:	f8b2 e008 	ldrhne.w	lr, [r2, #8]
    3024:	e003      	b.n	302e <usb_isr+0x826>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    3026:	4a64      	ldr	r2, [pc, #400]	; (31b8 <usb_isr+0x9b0>)
    3028:	4c64      	ldr	r4, [pc, #400]	; (31bc <usb_isr+0x9b4>)
    302a:	7812      	ldrb	r2, [r2, #0]
    302c:	7022      	strb	r2, [r4, #0]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    302e:	88e8      	ldrh	r0, [r5, #6]
    3030:	4570      	cmp	r0, lr
    3032:	f080 813f 	bcs.w	32b4 <usb_isr+0xaac>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    3036:	4962      	ldr	r1, [pc, #392]	; (31c0 <usb_isr+0x9b8>)
    3038:	780d      	ldrb	r5, [r1, #0]
    303a:	2840      	cmp	r0, #64	; 0x40
    303c:	4684      	mov	ip, r0
    303e:	f045 0e02 	orr.w	lr, r5, #2
    3042:	bf28      	it	cs
    3044:	f04f 0c40 	movcs.w	ip, #64	; 0x40
    3048:	eb04 030c 	add.w	r3, r4, ip
    304c:	eb09 02ce 	add.w	r2, r9, lr, lsl #3
    3050:	9302      	str	r3, [sp, #8]
    3052:	2301      	movs	r3, #1
    3054:	6054      	str	r4, [r2, #4]
    3056:	ebcc 0000 	rsb	r0, ip, r0
    305a:	ea4f 480c 	mov.w	r8, ip, lsl #16
    305e:	2200      	movs	r2, #0
    3060:	9301      	str	r3, [sp, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    3062:	24c8      	movs	r4, #200	; 0xc8
    3064:	e65e      	b.n	2d24 <usb_isr+0x51c>
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    3066:	4c55      	ldr	r4, [pc, #340]	; (31bc <usb_isr+0x9b4>)
		reply_buffer[1] = 0;
		datalen = 2;
    3068:	f04f 0e02 	mov.w	lr, #2
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    306c:	7022      	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    306e:	7062      	strb	r2, [r4, #1]
    3070:	e7dd      	b.n	302e <usb_isr+0x826>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    3072:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
    3076:	f47f af7c 	bne.w	2f72 <usb_isr+0x76a>
    307a:	2301      	movs	r3, #1
    307c:	2200      	movs	r2, #0
    307e:	9301      	str	r3, [sp, #4]
    3080:	e63d      	b.n	2cfe <usb_isr+0x4f6>
    3082:	f242 3221 	movw	r2, #8993	; 0x2321
    3086:	4291      	cmp	r1, r2
    3088:	d0f7      	beq.n	307a <usb_isr+0x872>
    308a:	e772      	b.n	2f72 <usb_isr+0x76a>
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    308c:	886a      	ldrh	r2, [r5, #2]
    308e:	2a00      	cmp	r2, #0
    3090:	f47f af6f 	bne.w	2f72 <usb_isr+0x76a>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    3094:	483a      	ldr	r0, [pc, #232]	; (3180 <usb_isr+0x978>)
    3096:	f8cd e004 	str.w	lr, [sp, #4]
    309a:	0089      	lsls	r1, r1, #2
    309c:	4408      	add	r0, r1
    309e:	7801      	ldrb	r1, [r0, #0]
    30a0:	f021 0102 	bic.w	r1, r1, #2
    30a4:	7001      	strb	r1, [r0, #0]
    30a6:	e62a      	b.n	2cfe <usb_isr+0x4f6>
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
    30a8:	f000 f996 	bl	33d8 <usb_malloc>
				if (p) {
    30ac:	2800      	cmp	r0, #0
    30ae:	f000 80ef 	beq.w	3290 <usb_isr+0xa88>
					table[index(i, RX, EVEN)].addr = p->buf;
    30b2:	3008      	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    30b4:	4a3d      	ldr	r2, [pc, #244]	; (31ac <usb_isr+0x9a4>)
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
    30b6:	f8c4 0084 	str.w	r0, [r4, #132]	; 0x84
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    30ba:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    30be:	f000 f98b 	bl	33d8 <usb_malloc>
				if (p) {
    30c2:	2800      	cmp	r0, #0
    30c4:	f000 80de 	beq.w	3284 <usb_isr+0xa7c>
					table[index(i, RX, ODD)].addr = p->buf;
    30c8:	3008      	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    30ca:	4a37      	ldr	r2, [pc, #220]	; (31a8 <usb_isr+0x9a0>)
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    30cc:	f8c9 008c 	str.w	r0, [r9, #140]	; 0x8c
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    30d0:	f8c9 2088 	str.w	r2, [r9, #136]	; 0x88
    30d4:	e738      	b.n	2f48 <usb_isr+0x740>
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
    30d6:	f000 f97f 	bl	33d8 <usb_malloc>
				if (p) {
    30da:	2800      	cmp	r0, #0
    30dc:	f000 80c0 	beq.w	3260 <usb_isr+0xa58>
					table[index(i, RX, EVEN)].addr = p->buf;
    30e0:	3008      	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    30e2:	4a32      	ldr	r2, [pc, #200]	; (31ac <usb_isr+0x9a4>)
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
    30e4:	f8c8 0044 	str.w	r0, [r8, #68]	; 0x44
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    30e8:	f8c8 2040 	str.w	r2, [r8, #64]	; 0x40
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    30ec:	f000 f974 	bl	33d8 <usb_malloc>
				if (p) {
    30f0:	2800      	cmp	r0, #0
    30f2:	f000 80af 	beq.w	3254 <usb_isr+0xa4c>
					table[index(i, RX, ODD)].addr = p->buf;
    30f6:	3008      	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    30f8:	4a2b      	ldr	r2, [pc, #172]	; (31a8 <usb_isr+0x9a0>)
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    30fa:	f8c9 004c 	str.w	r0, [r9, #76]	; 0x4c
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    30fe:	f8c9 2048 	str.w	r2, [r9, #72]	; 0x48
    3102:	e708      	b.n	2f16 <usb_isr+0x70e>
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
    3104:	f000 f968 	bl	33d8 <usb_malloc>
				if (p) {
    3108:	2800      	cmp	r0, #0
    310a:	f000 80cd 	beq.w	32a8 <usb_isr+0xaa0>
					table[index(i, RX, EVEN)].addr = p->buf;
    310e:	3008      	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    3110:	4a26      	ldr	r2, [pc, #152]	; (31ac <usb_isr+0x9a4>)
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
    3112:	f8c9 0024 	str.w	r0, [r9, #36]	; 0x24
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    3116:	f8c9 2020 	str.w	r2, [r9, #32]
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    311a:	f000 f95d 	bl	33d8 <usb_malloc>
				if (p) {
    311e:	2800      	cmp	r0, #0
    3120:	f000 80bc 	beq.w	329c <usb_isr+0xa94>
					table[index(i, RX, ODD)].addr = p->buf;
    3124:	3008      	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    3126:	4a20      	ldr	r2, [pc, #128]	; (31a8 <usb_isr+0x9a0>)
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    3128:	f8c9 002c 	str.w	r0, [r9, #44]	; 0x2c
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    312c:	f8c9 2028 	str.w	r2, [r9, #40]	; 0x28
    3130:	e6e3      	b.n	2efa <usb_isr+0x6f2>
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
    3132:	f000 f951 	bl	33d8 <usb_malloc>
				if (p) {
    3136:	2800      	cmp	r0, #0
    3138:	f000 809e 	beq.w	3278 <usb_isr+0xa70>
					table[index(i, RX, EVEN)].addr = p->buf;
    313c:	3008      	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    313e:	4a1b      	ldr	r2, [pc, #108]	; (31ac <usb_isr+0x9a4>)
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
    3140:	f8c8 0064 	str.w	r0, [r8, #100]	; 0x64
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    3144:	f8c8 2060 	str.w	r2, [r8, #96]	; 0x60
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    3148:	f000 f946 	bl	33d8 <usb_malloc>
				if (p) {
    314c:	2800      	cmp	r0, #0
    314e:	f000 808d 	beq.w	326c <usb_isr+0xa64>
					table[index(i, RX, ODD)].addr = p->buf;
    3152:	3008      	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    3154:	4a14      	ldr	r2, [pc, #80]	; (31a8 <usb_isr+0x9a0>)
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    3156:	f8c9 006c 	str.w	r0, [r9, #108]	; 0x6c
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    315a:	f8c9 2068 	str.w	r2, [r9, #104]	; 0x68
    315e:	e6e7      	b.n	2f30 <usb_isr+0x728>
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    3160:	6bc8      	ldr	r0, [r1, #60]	; 0x3c
    3162:	3808      	subs	r0, #8
    3164:	f000 f958 	bl	3418 <usb_free>
    3168:	e504      	b.n	2b74 <usb_isr+0x36c>
    316a:	6b48      	ldr	r0, [r1, #52]	; 0x34
    316c:	3808      	subs	r0, #8
    316e:	f000 f953 	bl	3418 <usb_free>
    3172:	e4f9      	b.n	2b68 <usb_isr+0x360>
    3174:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
    3176:	3808      	subs	r0, #8
    3178:	f000 f94e 	bl	3418 <usb_free>
    317c:	e4ee      	b.n	2b5c <usb_isr+0x354>
    317e:	bf00      	nop
    3180:	400720c0 	.word	0x400720c0
    3184:	40072080 	.word	0x40072080
    3188:	00006ba0 	.word	0x00006ba0
    318c:	400720c4 	.word	0x400720c4
    3190:	1fff16f1 	.word	0x1fff16f1
    3194:	400720c8 	.word	0x400720c8
    3198:	400720cc 	.word	0x400720cc
    319c:	400720d0 	.word	0x400720d0
    31a0:	1fff0000 	.word	0x1fff0000
    31a4:	40072094 	.word	0x40072094
    31a8:	004000c8 	.word	0x004000c8
    31ac:	00400088 	.word	0x00400088
    31b0:	1fff1685 	.word	0x1fff1685
    31b4:	00006ba4 	.word	0x00006ba4
    31b8:	1fff16fc 	.word	0x1fff16fc
    31bc:	1fff16f4 	.word	0x1fff16f4
    31c0:	1fff16f0 	.word	0x1fff16f0
    31c4:	6a60      	ldr	r0, [r4, #36]	; 0x24
    31c6:	3808      	subs	r0, #8
    31c8:	f000 f926 	bl	3418 <usb_free>
    31cc:	e4c0      	b.n	2b50 <usb_isr+0x348>
    31ce:	6fc8      	ldr	r0, [r1, #124]	; 0x7c
    31d0:	3808      	subs	r0, #8
    31d2:	f000 f921 	bl	3418 <usb_free>
    31d6:	e4fd      	b.n	2bd4 <usb_isr+0x3cc>
    31d8:	6f48      	ldr	r0, [r1, #116]	; 0x74
    31da:	3808      	subs	r0, #8
    31dc:	f000 f91c 	bl	3418 <usb_free>
    31e0:	e4f2      	b.n	2bc8 <usb_isr+0x3c0>
    31e2:	6ec8      	ldr	r0, [r1, #108]	; 0x6c
    31e4:	3808      	subs	r0, #8
    31e6:	f000 f917 	bl	3418 <usb_free>
    31ea:	e4e7      	b.n	2bbc <usb_isr+0x3b4>
    31ec:	6e48      	ldr	r0, [r1, #100]	; 0x64
    31ee:	3808      	subs	r0, #8
    31f0:	f000 f912 	bl	3418 <usb_free>
    31f4:	e4dc      	b.n	2bb0 <usb_isr+0x3a8>
    31f6:	6dc8      	ldr	r0, [r1, #92]	; 0x5c
    31f8:	3808      	subs	r0, #8
    31fa:	f000 f90d 	bl	3418 <usb_free>
    31fe:	e4d1      	b.n	2ba4 <usb_isr+0x39c>
    3200:	6d48      	ldr	r0, [r1, #84]	; 0x54
    3202:	3808      	subs	r0, #8
    3204:	f000 f908 	bl	3418 <usb_free>
    3208:	e4c6      	b.n	2b98 <usb_isr+0x390>
    320a:	6cc8      	ldr	r0, [r1, #76]	; 0x4c
    320c:	3808      	subs	r0, #8
    320e:	f000 f903 	bl	3418 <usb_free>
    3212:	e4bb      	b.n	2b8c <usb_isr+0x384>
    3214:	6c48      	ldr	r0, [r1, #68]	; 0x44
    3216:	3808      	subs	r0, #8
    3218:	f000 f8fe 	bl	3418 <usb_free>
    321c:	e4b0      	b.n	2b80 <usb_isr+0x378>
    321e:	f8d1 009c 	ldr.w	r0, [r1, #156]	; 0x9c
    3222:	3808      	subs	r0, #8
    3224:	f000 f8f8 	bl	3418 <usb_free>
    3228:	e4ec      	b.n	2c04 <usb_isr+0x3fc>
    322a:	f8d1 0094 	ldr.w	r0, [r1, #148]	; 0x94
    322e:	3808      	subs	r0, #8
    3230:	f000 f8f2 	bl	3418 <usb_free>
    3234:	e4e0      	b.n	2bf8 <usb_isr+0x3f0>
    3236:	f8d1 008c 	ldr.w	r0, [r1, #140]	; 0x8c
    323a:	3808      	subs	r0, #8
    323c:	f000 f8ec 	bl	3418 <usb_free>
    3240:	e4d4      	b.n	2bec <usb_isr+0x3e4>
    3242:	f8d1 0084 	ldr.w	r0, [r1, #132]	; 0x84
    3246:	3808      	subs	r0, #8
    3248:	f000 f8e6 	bl	3418 <usb_free>
    324c:	e4c8      	b.n	2be0 <usb_isr+0x3d8>
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    324e:	f04f 0e02 	mov.w	lr, #2
    3252:	e6ec      	b.n	302e <usb_isr+0x826>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    3254:	782a      	ldrb	r2, [r5, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    3256:	f8c9 0048 	str.w	r0, [r9, #72]	; 0x48
					usb_rx_memory_needed++;
    325a:	3201      	adds	r2, #1
    325c:	702a      	strb	r2, [r5, #0]
    325e:	e65a      	b.n	2f16 <usb_isr+0x70e>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    3260:	782a      	ldrb	r2, [r5, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    3262:	f8c8 0040 	str.w	r0, [r8, #64]	; 0x40
					usb_rx_memory_needed++;
    3266:	3201      	adds	r2, #1
    3268:	702a      	strb	r2, [r5, #0]
    326a:	e73f      	b.n	30ec <usb_isr+0x8e4>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    326c:	782a      	ldrb	r2, [r5, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    326e:	f8c9 0068 	str.w	r0, [r9, #104]	; 0x68
					usb_rx_memory_needed++;
    3272:	3201      	adds	r2, #1
    3274:	702a      	strb	r2, [r5, #0]
    3276:	e65b      	b.n	2f30 <usb_isr+0x728>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    3278:	782a      	ldrb	r2, [r5, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    327a:	f8c8 0060 	str.w	r0, [r8, #96]	; 0x60
					usb_rx_memory_needed++;
    327e:	3201      	adds	r2, #1
    3280:	702a      	strb	r2, [r5, #0]
    3282:	e761      	b.n	3148 <usb_isr+0x940>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    3284:	782a      	ldrb	r2, [r5, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    3286:	f8c9 0088 	str.w	r0, [r9, #136]	; 0x88
					usb_rx_memory_needed++;
    328a:	3201      	adds	r2, #1
    328c:	702a      	strb	r2, [r5, #0]
    328e:	e65b      	b.n	2f48 <usb_isr+0x740>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    3290:	782a      	ldrb	r2, [r5, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    3292:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
					usb_rx_memory_needed++;
    3296:	3201      	adds	r2, #1
    3298:	702a      	strb	r2, [r5, #0]
    329a:	e710      	b.n	30be <usb_isr+0x8b6>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    329c:	782a      	ldrb	r2, [r5, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    329e:	f8c9 0028 	str.w	r0, [r9, #40]	; 0x28
					usb_rx_memory_needed++;
    32a2:	3201      	adds	r2, #1
    32a4:	702a      	strb	r2, [r5, #0]
    32a6:	e628      	b.n	2efa <usb_isr+0x6f2>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    32a8:	782a      	ldrb	r2, [r5, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    32aa:	f8c9 0020 	str.w	r0, [r9, #32]
					usb_rx_memory_needed++;
    32ae:	3201      	adds	r2, #1
    32b0:	702a      	strb	r2, [r5, #0]
    32b2:	e732      	b.n	311a <usb_isr+0x912>
    32b4:	f1be 0f40 	cmp.w	lr, #64	; 0x40
    32b8:	46f4      	mov	ip, lr
    32ba:	bf28      	it	cs
    32bc:	f04f 0c40 	movcs.w	ip, #64	; 0x40
    32c0:	eb04 030c 	add.w	r3, r4, ip
    32c4:	9302      	str	r3, [sp, #8]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    32c6:	2301      	movs	r3, #1
    32c8:	ebcc 000e 	rsb	r0, ip, lr
    32cc:	ea4f 480c 	mov.w	r8, ip, lsl #16
    32d0:	2200      	movs	r2, #0
    32d2:	9301      	str	r3, [sp, #4]
    32d4:	e518      	b.n	2d08 <usb_isr+0x500>
    32d6:	bf00      	nop

000032d8 <usb_init>:
}



void usb_init(void)
{
    32d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    32dc:	f001 f8b8 	bl	4450 <usb_init_serialnumber>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    32e0:	4c31      	ldr	r4, [pc, #196]	; (33a8 <usb_init+0xd0>)
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    32e2:	4b32      	ldr	r3, [pc, #200]	; (33ac <usb_init+0xd4>)

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    32e4:	4832      	ldr	r0, [pc, #200]	; (33b0 <usb_init+0xd8>)
#endif
#if F_CPU == 180000000 || F_CPU == 216000000 || F_CPU == 256000000
	// if using IRC48M, turn on the USB clock recovery hardware
	USB0_CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN | USB_CLK_RECOVER_IRC_EN_REG_EN;
    32e6:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 33cc <usb_init+0xf4>
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    32ea:	4e32      	ldr	r6, [pc, #200]	; (33b4 <usb_init+0xdc>)
	MPU_RGDAAC0 |= 0x03000000;
#endif
#if F_CPU == 180000000 || F_CPU == 216000000 || F_CPU == 256000000
	// if using IRC48M, turn on the USB clock recovery hardware
	USB0_CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN | USB_CLK_RECOVER_IRC_EN_REG_EN;
	USB0_CLK_RECOVER_CTRL = USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN |
    32ec:	f8df c0e0 	ldr.w	ip, [pc, #224]	; 33d0 <usb_init+0xf8>
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    32f0:	4f31      	ldr	r7, [pc, #196]	; (33b8 <usb_init+0xe0>)
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    32f2:	4d32      	ldr	r5, [pc, #200]	; (33bc <usb_init+0xe4>)

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    32f4:	f8df e0dc 	ldr.w	lr, [pc, #220]	; 33d4 <usb_init+0xfc>
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    32f8:	2200      	movs	r2, #0
    32fa:	601a      	str	r2, [r3, #0]
		table[i].addr = 0;
    32fc:	605a      	str	r2, [r3, #4]
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    32fe:	609a      	str	r2, [r3, #8]
		table[i].addr = 0;
    3300:	60da      	str	r2, [r3, #12]
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    3302:	611a      	str	r2, [r3, #16]
		table[i].addr = 0;
    3304:	615a      	str	r2, [r3, #20]
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    3306:	619a      	str	r2, [r3, #24]
		table[i].addr = 0;
    3308:	61da      	str	r2, [r3, #28]
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    330a:	621a      	str	r2, [r3, #32]
		table[i].addr = 0;
    330c:	625a      	str	r2, [r3, #36]	; 0x24
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    330e:	629a      	str	r2, [r3, #40]	; 0x28
		table[i].addr = 0;
    3310:	62da      	str	r2, [r3, #44]	; 0x2c
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    3312:	631a      	str	r2, [r3, #48]	; 0x30
		table[i].addr = 0;
    3314:	635a      	str	r2, [r3, #52]	; 0x34
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    3316:	639a      	str	r2, [r3, #56]	; 0x38
		table[i].addr = 0;
    3318:	63da      	str	r2, [r3, #60]	; 0x3c
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    331a:	641a      	str	r2, [r3, #64]	; 0x40
		table[i].addr = 0;
    331c:	645a      	str	r2, [r3, #68]	; 0x44
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    331e:	649a      	str	r2, [r3, #72]	; 0x48
		table[i].addr = 0;
    3320:	64da      	str	r2, [r3, #76]	; 0x4c
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    3322:	651a      	str	r2, [r3, #80]	; 0x50
		table[i].addr = 0;
    3324:	655a      	str	r2, [r3, #84]	; 0x54
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    3326:	659a      	str	r2, [r3, #88]	; 0x58
		table[i].addr = 0;
    3328:	65da      	str	r2, [r3, #92]	; 0x5c
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    332a:	661a      	str	r2, [r3, #96]	; 0x60
		table[i].addr = 0;
    332c:	665a      	str	r2, [r3, #100]	; 0x64
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    332e:	669a      	str	r2, [r3, #104]	; 0x68
		table[i].addr = 0;
    3330:	66da      	str	r2, [r3, #108]	; 0x6c
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    3332:	671a      	str	r2, [r3, #112]	; 0x70
		table[i].addr = 0;
    3334:	675a      	str	r2, [r3, #116]	; 0x74
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    3336:	679a      	str	r2, [r3, #120]	; 0x78
		table[i].addr = 0;
    3338:	67da      	str	r2, [r3, #124]	; 0x7c
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    333a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    333e:	6821      	ldr	r1, [r4, #0]

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
		table[i].addr = 0;
    3340:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    3344:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
    3348:	6021      	str	r1, [r4, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    334a:	6801      	ldr	r1, [r0, #0]
    334c:	f041 7140 	orr.w	r1, r1, #50331648	; 0x3000000
    3350:	6001      	str	r1, [r0, #0]
#endif
#if F_CPU == 180000000 || F_CPU == 216000000 || F_CPU == 256000000
	// if using IRC48M, turn on the USB clock recovery hardware
	USB0_CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN | USB_CLK_RECOVER_IRC_EN_REG_EN;
    3352:	2103      	movs	r1, #3
    3354:	f888 1000 	strb.w	r1, [r8]
	USB0_CLK_RECOVER_CTRL = USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN |
    3358:	20a0      	movs	r0, #160	; 0xa0
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    335a:	f3c3 2107 	ubfx	r1, r3, #8, #8
	MPU_RGDAAC0 |= 0x03000000;
#endif
#if F_CPU == 180000000 || F_CPU == 216000000 || F_CPU == 256000000
	// if using IRC48M, turn on the USB clock recovery hardware
	USB0_CLK_RECOVER_IRC_EN = USB_CLK_RECOVER_IRC_EN_IRC_EN | USB_CLK_RECOVER_IRC_EN_REG_EN;
	USB0_CLK_RECOVER_CTRL = USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN |
    335e:	f88c 0000 	strb.w	r0, [ip]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    3362:	f504 3428 	add.w	r4, r4, #172032	; 0x2a000
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    3366:	7031      	strb	r1, [r6, #0]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    3368:	f3c3 4007 	ubfx	r0, r3, #16, #8
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    336c:	4914      	ldr	r1, [pc, #80]	; (33c0 <usb_init+0xe8>)
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    336e:	7038      	strb	r0, [r7, #0]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    3370:	0e1b      	lsrs	r3, r3, #24
    3372:	702b      	strb	r3, [r5, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    3374:	34cc      	adds	r4, #204	; 0xcc
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    3376:	23ff      	movs	r3, #255	; 0xff
    3378:	f88e 3000 	strb.w	r3, [lr]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    337c:	4d11      	ldr	r5, [pc, #68]	; (33c4 <usb_init+0xec>)
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    337e:	f80c 3cb8 	strb.w	r3, [ip, #-184]
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    3382:	4811      	ldr	r0, [pc, #68]	; (33c8 <usb_init+0xf0>)
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    3384:	700b      	strb	r3, [r1, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    3386:	2301      	movs	r3, #1
    3388:	f806 3c08 	strb.w	r3, [r6, #-8]
	USB0_USBCTRL = 0;
    338c:	7022      	strb	r2, [r4, #0]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    338e:	2670      	movs	r6, #112	; 0x70
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    3390:	f44f 1400 	mov.w	r4, #2097152	; 0x200000

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    3394:	2210      	movs	r2, #16
	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    3396:	f807 3c2c 	strb.w	r3, [r7, #-44]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    339a:	702e      	strb	r6, [r5, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    339c:	6004      	str	r4, [r0, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    339e:	f881 20f8 	strb.w	r2, [r1, #248]	; 0xf8
    33a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    33a6:	bf00      	nop
    33a8:	40048034 	.word	0x40048034
    33ac:	1fff0000 	.word	0x1fff0000
    33b0:	4000d800 	.word	0x4000d800
    33b4:	4007209c 	.word	0x4007209c
    33b8:	400720b0 	.word	0x400720b0
    33bc:	400720b4 	.word	0x400720b4
    33c0:	40072010 	.word	0x40072010
    33c4:	e000e435 	.word	0xe000e435
    33c8:	e000e104 	.word	0xe000e104
    33cc:	40072144 	.word	0x40072144
    33d0:	40072140 	.word	0x40072140
    33d4:	40072080 	.word	0x40072080

000033d8 <usb_malloc>:
usb_packet_t * usb_malloc(void)
{
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    33d8:	b672      	cpsid	i
	avail = usb_buffer_available;
    33da:	480d      	ldr	r0, [pc, #52]	; (3410 <usb_malloc+0x38>)
    33dc:	6802      	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    33de:	fab2 f382 	clz	r3, r2
	if (n >= NUM_USB_BUFFERS) {
    33e2:	2b0b      	cmp	r3, #11
    33e4:	dc10      	bgt.n	3408 <usb_malloc+0x30>
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    33e6:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    33ea:	40d9      	lsrs	r1, r3
    33ec:	ea22 0201 	bic.w	r2, r2, r1
    33f0:	6002      	str	r2, [r0, #0]
	__enable_irq();
    33f2:	b662      	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    33f4:	4807      	ldr	r0, [pc, #28]	; (3414 <usb_malloc+0x3c>)
    33f6:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
    33fa:	00db      	lsls	r3, r3, #3
    33fc:	18c2      	adds	r2, r0, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    33fe:	2100      	movs	r1, #0
    3400:	50c1      	str	r1, [r0, r3]
	*(uint32_t *)(p + 4) = 0;
	return (usb_packet_t *)p;
    3402:	4610      	mov	r0, r2
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
	*(uint32_t *)(p + 4) = 0;
    3404:	6051      	str	r1, [r2, #4]
	return (usb_packet_t *)p;
}
    3406:	4770      	bx	lr

	__disable_irq();
	avail = usb_buffer_available;
	n = __builtin_clz(avail); // clz = count leading zeros
	if (n >= NUM_USB_BUFFERS) {
		__enable_irq();
    3408:	b662      	cpsie	i
		return NULL;
    340a:	2000      	movs	r0, #0
    340c:	4770      	bx	lr
    340e:	bf00      	nop
    3410:	1fff09d8 	.word	0x1fff09d8
    3414:	1fff03d0 	.word	0x1fff03d0

00003418 <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    3418:	4b0d      	ldr	r3, [pc, #52]	; (3450 <usb_free+0x38>)
    341a:	4a0e      	ldr	r2, [pc, #56]	; (3454 <usb_free+0x3c>)
    341c:	1ac3      	subs	r3, r0, r3
    341e:	fba2 2303 	umull	r2, r3, r2, r3
    3422:	091b      	lsrs	r3, r3, #4
	if (n >= NUM_USB_BUFFERS) return;
    3424:	2b0b      	cmp	r3, #11
    3426:	d80c      	bhi.n	3442 <usb_free+0x2a>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    3428:	4a0b      	ldr	r2, [pc, #44]	; (3458 <usb_free+0x40>)
    342a:	7812      	ldrb	r2, [r2, #0]
    342c:	b952      	cbnz	r2, 3444 <usb_free+0x2c>
		usb_rx_memory(p);
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    342e:	b672      	cpsid	i
	usb_buffer_available |= mask;
    3430:	480a      	ldr	r0, [pc, #40]	; (345c <usb_free+0x44>)
    3432:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
    3436:	6802      	ldr	r2, [r0, #0]
    3438:	fa21 f303 	lsr.w	r3, r1, r3
    343c:	431a      	orrs	r2, r3
    343e:	6002      	str	r2, [r0, #0]
	__enable_irq();
    3440:	b662      	cpsie	i
    3442:	4770      	bx	lr
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    3444:	4a06      	ldr	r2, [pc, #24]	; (3460 <usb_free+0x48>)
    3446:	7812      	ldrb	r2, [r2, #0]
    3448:	2a00      	cmp	r2, #0
    344a:	d0f0      	beq.n	342e <usb_free+0x16>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    344c:	f7ff b936 	b.w	26bc <usb_rx_memory>
    3450:	1fff03d0 	.word	0x1fff03d0
    3454:	38e38e39 	.word	0x38e38e39
    3458:	1fff16f1 	.word	0x1fff16f1
    345c:	1fff09d8 	.word	0x1fff09d8
    3460:	1fff16fc 	.word	0x1fff16fc

00003464 <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    3464:	b538      	push	{r3, r4, r5, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    3466:	4d0f      	ldr	r5, [pc, #60]	; (34a4 <usb_serial_getchar+0x40>)
    3468:	6828      	ldr	r0, [r5, #0]
    346a:	b178      	cbz	r0, 348c <usb_serial_getchar+0x28>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    346c:	8843      	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
    346e:	8802      	ldrh	r2, [r0, #0]
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    3470:	18c1      	adds	r1, r0, r3
    3472:	3301      	adds	r3, #1
	if (i >= rx_packet->len) {
    3474:	4293      	cmp	r3, r2
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    3476:	7a0c      	ldrb	r4, [r1, #8]
	if (i >= rx_packet->len) {
    3478:	d202      	bcs.n	3480 <usb_serial_getchar+0x1c>
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    347a:	8043      	strh	r3, [r0, #2]
	}
	return c;
    347c:	4620      	mov	r0, r4
}
    347e:	bd38      	pop	{r3, r4, r5, pc}
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
    3480:	f7ff ffca 	bl	3418 <usb_free>
		rx_packet = NULL;
    3484:	2300      	movs	r3, #0
	} else {
		rx_packet->index = i;
	}
	return c;
    3486:	4620      	mov	r0, r4
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
    3488:	602b      	str	r3, [r5, #0]
    348a:	bd38      	pop	{r3, r4, r5, pc}
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    348c:	4b06      	ldr	r3, [pc, #24]	; (34a8 <usb_serial_getchar+0x44>)
    348e:	781b      	ldrb	r3, [r3, #0]
    3490:	b12b      	cbz	r3, 349e <usb_serial_getchar+0x3a>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    3492:	2003      	movs	r0, #3
    3494:	f7ff f8de 	bl	2654 <usb_rx>
    3498:	6028      	str	r0, [r5, #0]
		if (!rx_packet) return -1;
    349a:	2800      	cmp	r0, #0
    349c:	d1e6      	bne.n	346c <usb_serial_getchar+0x8>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    349e:	f04f 30ff 	mov.w	r0, #4294967295
    34a2:	bd38      	pop	{r3, r4, r5, pc}
    34a4:	1fff1710 	.word	0x1fff1710
    34a8:	1fff16fc 	.word	0x1fff16fc

000034ac <usb_serial_peekchar>:
	return c;
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    34ac:	b510      	push	{r4, lr}
	if (!rx_packet) {
    34ae:	4c09      	ldr	r4, [pc, #36]	; (34d4 <usb_serial_peekchar+0x28>)
    34b0:	6820      	ldr	r0, [r4, #0]
    34b2:	b118      	cbz	r0, 34bc <usb_serial_peekchar+0x10>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    34b4:	8843      	ldrh	r3, [r0, #2]
    34b6:	4418      	add	r0, r3
    34b8:	7a00      	ldrb	r0, [r0, #8]
}
    34ba:	bd10      	pop	{r4, pc}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    34bc:	4b06      	ldr	r3, [pc, #24]	; (34d8 <usb_serial_peekchar+0x2c>)
    34be:	781b      	ldrb	r3, [r3, #0]
    34c0:	b12b      	cbz	r3, 34ce <usb_serial_peekchar+0x22>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    34c2:	2003      	movs	r0, #3
    34c4:	f7ff f8c6 	bl	2654 <usb_rx>
    34c8:	6020      	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    34ca:	2800      	cmp	r0, #0
    34cc:	d1f2      	bne.n	34b4 <usb_serial_peekchar+0x8>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    34ce:	f04f 30ff 	mov.w	r0, #4294967295
    34d2:	bd10      	pop	{r4, pc}
    34d4:	1fff1710 	.word	0x1fff1710
    34d8:	1fff16fc 	.word	0x1fff16fc

000034dc <usb_serial_available>:
// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    34dc:	4b04      	ldr	r3, [pc, #16]	; (34f0 <usb_serial_available+0x14>)
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    34de:	4a05      	ldr	r2, [pc, #20]	; (34f4 <usb_serial_available+0x18>)
    34e0:	681b      	ldr	r3, [r3, #0]

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    34e2:	8890      	ldrh	r0, [r2, #4]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    34e4:	b11b      	cbz	r3, 34ee <usb_serial_available+0x12>
    34e6:	881a      	ldrh	r2, [r3, #0]
    34e8:	885b      	ldrh	r3, [r3, #2]
    34ea:	1ad3      	subs	r3, r2, r3
    34ec:	4418      	add	r0, r3
	return count;
}
    34ee:	4770      	bx	lr
    34f0:	1fff1710 	.word	0x1fff1710
    34f4:	1fff1a6c 	.word	0x1fff1a6c

000034f8 <usb_serial_flush_input>:
// discard any buffered input
void usb_serial_flush_input(void)
{
	usb_packet_t *rx;

	if (!usb_configuration) return;
    34f8:	4b0b      	ldr	r3, [pc, #44]	; (3528 <usb_serial_flush_input+0x30>)
    34fa:	781b      	ldrb	r3, [r3, #0]
    34fc:	b19b      	cbz	r3, 3526 <usb_serial_flush_input+0x2e>
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    34fe:	b510      	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
    3500:	4c0a      	ldr	r4, [pc, #40]	; (352c <usb_serial_flush_input+0x34>)
    3502:	6820      	ldr	r0, [r4, #0]
    3504:	b148      	cbz	r0, 351a <usb_serial_flush_input+0x22>
		usb_free(rx_packet);
    3506:	f7ff ff87 	bl	3418 <usb_free>
		rx_packet = NULL;
    350a:	2300      	movs	r3, #0
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    350c:	2003      	movs	r0, #3
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
    350e:	6023      	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    3510:	f7ff f8a0 	bl	2654 <usb_rx>
		if (!rx) break;
    3514:	b130      	cbz	r0, 3524 <usb_serial_flush_input+0x2c>
		usb_free(rx);
    3516:	f7ff ff7f 	bl	3418 <usb_free>
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    351a:	2003      	movs	r0, #3
    351c:	f7ff f89a 	bl	2654 <usb_rx>
		if (!rx) break;
    3520:	2800      	cmp	r0, #0
    3522:	d1f8      	bne.n	3516 <usb_serial_flush_input+0x1e>
    3524:	bd10      	pop	{r4, pc}
    3526:	4770      	bx	lr
    3528:	1fff16fc 	.word	0x1fff16fc
    352c:	1fff1710 	.word	0x1fff1710

00003530 <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    3530:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    3534:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 3630 <usb_serial_write+0x100>
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    3538:	b083      	sub	sp, #12
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    353a:	2201      	movs	r2, #1
    353c:	f889 2000 	strb.w	r2, [r9]
	while (size > 0) {
    3540:	9101      	str	r1, [sp, #4]
    3542:	b369      	cbz	r1, 35a0 <usb_serial_write+0x70>
    3544:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 3634 <usb_serial_write+0x104>
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    3548:	4f35      	ldr	r7, [pc, #212]	; (3620 <usb_serial_write+0xf0>)
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    354a:	9e01      	ldr	r6, [sp, #4]
    354c:	4683      	mov	fp, r0
		if (!tx_packet) {
    354e:	f8d8 0000 	ldr.w	r0, [r8]
    3552:	b3b0      	cbz	r0, 35c2 <usb_serial_write+0x92>
    3554:	4d33      	ldr	r5, [pc, #204]	; (3624 <usb_serial_write+0xf4>)
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
    3556:	8844      	ldrh	r4, [r0, #2]
    3558:	f1c4 0140 	rsb	r1, r4, #64	; 0x40
    355c:	42b1      	cmp	r1, r6
    355e:	bf28      	it	cs
    3560:	4631      	movcs	r1, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    3562:	eb04 0e01 	add.w	lr, r4, r1
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    3566:	2200      	movs	r2, #0
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    3568:	fa1f fe8e 	uxth.w	lr, lr
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    356c:	702a      	strb	r2, [r5, #0]
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
    356e:	1a76      	subs	r6, r6, r1
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    3570:	f8a0 e002 	strh.w	lr, [r0, #2]
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
    3574:	f100 0208 	add.w	r2, r0, #8
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
    3578:	b151      	cbz	r1, 3590 <usb_serial_write+0x60>
    357a:	3c01      	subs	r4, #1
    357c:	4422      	add	r2, r4
    357e:	4459      	add	r1, fp
    3580:	f81b 4b01 	ldrb.w	r4, [fp], #1
    3584:	f802 4f01 	strb.w	r4, [r2, #1]!
    3588:	458b      	cmp	fp, r1
    358a:	d1f9      	bne.n	3580 <usb_serial_write+0x50>
    358c:	f8b0 e002 	ldrh.w	lr, [r0, #2]
		if (tx_packet->index >= CDC_TX_SIZE) {
    3590:	f1be 0f3f 	cmp.w	lr, #63	; 0x3f
    3594:	d80b      	bhi.n	35ae <usb_serial_write+0x7e>
			tx_packet->len = CDC_TX_SIZE;
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    3596:	4a24      	ldr	r2, [pc, #144]	; (3628 <usb_serial_write+0xf8>)
    3598:	2105      	movs	r1, #5
    359a:	7011      	strb	r1, [r2, #0]
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    359c:	2e00      	cmp	r6, #0
    359e:	d1d6      	bne.n	354e <usb_serial_write+0x1e>
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
    35a0:	9801      	ldr	r0, [sp, #4]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
    35a2:	2300      	movs	r3, #0
    35a4:	f889 3000 	strb.w	r3, [r9]
	return ret;
}
    35a8:	b003      	add	sp, #12
    35aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
		if (tx_packet->index >= CDC_TX_SIZE) {
			tx_packet->len = CDC_TX_SIZE;
    35ae:	2240      	movs	r2, #64	; 0x40
    35b0:	8002      	strh	r2, [r0, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    35b2:	4601      	mov	r1, r0
    35b4:	2004      	movs	r0, #4
    35b6:	f7ff f8e5 	bl	2784 <usb_tx>
			tx_packet = NULL;
    35ba:	2200      	movs	r2, #0
    35bc:	f8c8 2000 	str.w	r2, [r8]
    35c0:	e7e9      	b.n	3596 <usb_serial_write+0x66>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    35c2:	783a      	ldrb	r2, [r7, #0]
    35c4:	b322      	cbz	r2, 3610 <usb_serial_write+0xe0>
    35c6:	4c19      	ldr	r4, [pc, #100]	; (362c <usb_serial_write+0xfc>)
    35c8:	4d16      	ldr	r5, [pc, #88]	; (3624 <usb_serial_write+0xf4>)
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
    35ca:	f04f 0a01 	mov.w	sl, #1
    35ce:	e007      	b.n	35e0 <usb_serial_write+0xb0>
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    35d0:	3c01      	subs	r4, #1
    35d2:	d016      	beq.n	3602 <usb_serial_write+0xd2>
    35d4:	782a      	ldrb	r2, [r5, #0]
    35d6:	b9a2      	cbnz	r2, 3602 <usb_serial_write+0xd2>
					transmit_previous_timeout = 1;
					return -1;
				}
				yield();
    35d8:	f000 fb90 	bl	3cfc <yield>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    35dc:	783a      	ldrb	r2, [r7, #0]
    35de:	b1ba      	cbz	r2, 3610 <usb_serial_write+0xe0>
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    35e0:	2004      	movs	r0, #4
    35e2:	f7ff f855 	bl	2690 <usb_tx_packet_count>
    35e6:	2807      	cmp	r0, #7
    35e8:	d8f2      	bhi.n	35d0 <usb_serial_write+0xa0>
					tx_noautoflush = 1;
    35ea:	f889 a000 	strb.w	sl, [r9]
					tx_packet = usb_malloc();
    35ee:	f7ff fef3 	bl	33d8 <usb_malloc>
    35f2:	f8c8 0000 	str.w	r0, [r8]
					if (tx_packet) break;
    35f6:	2800      	cmp	r0, #0
    35f8:	d1ad      	bne.n	3556 <usb_serial_write+0x26>
					tx_noautoflush = 0;
    35fa:	4b0d      	ldr	r3, [pc, #52]	; (3630 <usb_serial_write+0x100>)
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    35fc:	3c01      	subs	r4, #1
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
    35fe:	7018      	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    3600:	d1e8      	bne.n	35d4 <usb_serial_write+0xa4>
					transmit_previous_timeout = 1;
    3602:	2301      	movs	r3, #1
					return -1;
    3604:	f04f 30ff 	mov.w	r0, #4294967295
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
					transmit_previous_timeout = 1;
    3608:	702b      	strb	r3, [r5, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    360a:	b003      	add	sp, #12
    360c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    3610:	2300      	movs	r3, #0
					return -1;
    3612:	f04f 30ff 	mov.w	r0, #4294967295
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    3616:	f889 3000 	strb.w	r3, [r9]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    361a:	b003      	add	sp, #12
    361c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3620:	1fff16fc 	.word	0x1fff16fc
    3624:	1fff170c 	.word	0x1fff170c
    3628:	1fff1704 	.word	0x1fff1704
    362c:	00014821 	.word	0x00014821
    3630:	1fff1705 	.word	0x1fff1705
    3634:	1fff1708 	.word	0x1fff1708

00003638 <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    3638:	b500      	push	{lr}
    363a:	b083      	sub	sp, #12
    363c:	ab02      	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    363e:	2101      	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    3640:	f803 0d01 	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    3644:	4618      	mov	r0, r3
    3646:	f7ff ff73 	bl	3530 <usb_serial_write>
}
    364a:	b003      	add	sp, #12
    364c:	f85d fb04 	ldr.w	pc, [sp], #4

00003650 <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    3650:	b538      	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
    3652:	4d0e      	ldr	r5, [pc, #56]	; (368c <usb_serial_write_buffer_free+0x3c>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    3654:	4c0e      	ldr	r4, [pc, #56]	; (3690 <usb_serial_write_buffer_free+0x40>)
	if (!tx_packet) {
    3656:	6828      	ldr	r0, [r5, #0]

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    3658:	2301      	movs	r3, #1
    365a:	7023      	strb	r3, [r4, #0]
	if (!tx_packet) {
    365c:	b128      	cbz	r0, 366a <usb_serial_write_buffer_free+0x1a>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    365e:	8840      	ldrh	r0, [r0, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    3660:	2300      	movs	r3, #0
    3662:	7023      	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    3664:	f1c0 0040 	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    3668:	bd38      	pop	{r3, r4, r5, pc}
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    366a:	4b0a      	ldr	r3, [pc, #40]	; (3694 <usb_serial_write_buffer_free+0x44>)
    366c:	781b      	ldrb	r3, [r3, #0]
    366e:	b913      	cbnz	r3, 3676 <usb_serial_write_buffer_free+0x26>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    3670:	2000      	movs	r0, #0
    3672:	7020      	strb	r0, [r4, #0]
			return 0;
    3674:	bd38      	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    3676:	2004      	movs	r0, #4
    3678:	f7ff f80a 	bl	2690 <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    367c:	2807      	cmp	r0, #7
    367e:	d8f7      	bhi.n	3670 <usb_serial_write_buffer_free+0x20>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    3680:	f7ff feaa 	bl	33d8 <usb_malloc>
    3684:	6028      	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    3686:	2800      	cmp	r0, #0
    3688:	d1e9      	bne.n	365e <usb_serial_write_buffer_free+0xe>
    368a:	e7f1      	b.n	3670 <usb_serial_write_buffer_free+0x20>
    368c:	1fff1708 	.word	0x1fff1708
    3690:	1fff1705 	.word	0x1fff1705
    3694:	1fff16fc 	.word	0x1fff16fc

00003698 <usb_serial_flush_output>:
	tx_noautoflush = 0;
	return len;
}

void usb_serial_flush_output(void)
{
    3698:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!usb_configuration) return;
    369a:	4b11      	ldr	r3, [pc, #68]	; (36e0 <usb_serial_flush_output+0x48>)
    369c:	781b      	ldrb	r3, [r3, #0]
    369e:	b18b      	cbz	r3, 36c4 <usb_serial_flush_output+0x2c>
	tx_noautoflush = 1;
	if (tx_packet) {
    36a0:	4e10      	ldr	r6, [pc, #64]	; (36e4 <usb_serial_flush_output+0x4c>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    36a2:	4d11      	ldr	r5, [pc, #68]	; (36e8 <usb_serial_flush_output+0x50>)
	if (tx_packet) {
    36a4:	6834      	ldr	r4, [r6, #0]
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    36a6:	2701      	movs	r7, #1
    36a8:	702f      	strb	r7, [r5, #0]
	if (tx_packet) {
    36aa:	b164      	cbz	r4, 36c6 <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    36ac:	4a0f      	ldr	r2, [pc, #60]	; (36ec <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
    36ae:	8863      	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    36b0:	2700      	movs	r7, #0
    36b2:	7017      	strb	r7, [r2, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    36b4:	4621      	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    36b6:	8023      	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    36b8:	2004      	movs	r0, #4
    36ba:	f7ff f863 	bl	2784 <usb_tx>
		tx_packet = NULL;
    36be:	6037      	str	r7, [r6, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
	tx_noautoflush = 0;
    36c0:	2300      	movs	r3, #0
    36c2:	702b      	strb	r3, [r5, #0]
    36c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    36c6:	f7ff fe87 	bl	33d8 <usb_malloc>
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    36ca:	4b08      	ldr	r3, [pc, #32]	; (36ec <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
    36cc:	b128      	cbz	r0, 36da <usb_serial_flush_output+0x42>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    36ce:	4601      	mov	r1, r0
    36d0:	2004      	movs	r0, #4
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    36d2:	701c      	strb	r4, [r3, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    36d4:	f7ff f856 	bl	2784 <usb_tx>
    36d8:	e7f2      	b.n	36c0 <usb_serial_flush_output+0x28>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    36da:	701f      	strb	r7, [r3, #0]
    36dc:	e7f0      	b.n	36c0 <usb_serial_flush_output+0x28>
    36de:	bf00      	nop
    36e0:	1fff16fc 	.word	0x1fff16fc
    36e4:	1fff1708 	.word	0x1fff1708
    36e8:	1fff1705 	.word	0x1fff1705
    36ec:	1fff1704 	.word	0x1fff1704

000036f0 <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback(void)
{
    36f0:	b538      	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    36f2:	4b0e      	ldr	r3, [pc, #56]	; (372c <usb_serial_flush_callback+0x3c>)
    36f4:	781b      	ldrb	r3, [r3, #0]
    36f6:	b973      	cbnz	r3, 3716 <usb_serial_flush_callback+0x26>
	if (tx_packet) {
    36f8:	4c0d      	ldr	r4, [pc, #52]	; (3730 <usb_serial_flush_callback+0x40>)
    36fa:	6821      	ldr	r1, [r4, #0]
    36fc:	b161      	cbz	r1, 3718 <usb_serial_flush_callback+0x28>
    36fe:	f003 05ff 	and.w	r5, r3, #255	; 0xff
		tx_packet->len = tx_packet->index;
    3702:	884b      	ldrh	r3, [r1, #2]
    3704:	800b      	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    3706:	2004      	movs	r0, #4
    3708:	f7ff f83c 	bl	2784 <usb_tx>
		tx_packet = NULL;
    370c:	6025      	str	r5, [r4, #0]
    370e:	bd38      	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
    3710:	4b08      	ldr	r3, [pc, #32]	; (3734 <usb_serial_flush_callback+0x44>)
    3712:	2201      	movs	r2, #1
    3714:	701a      	strb	r2, [r3, #0]
    3716:	bd38      	pop	{r3, r4, r5, pc}
	if (tx_packet) {
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    3718:	f7ff fe5e 	bl	33d8 <usb_malloc>
		if (tx) {
    371c:	2800      	cmp	r0, #0
    371e:	d0f7      	beq.n	3710 <usb_serial_flush_callback+0x20>
			usb_tx(CDC_TX_ENDPOINT, tx);
    3720:	4601      	mov	r1, r0
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    3722:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    3726:	2004      	movs	r0, #4
    3728:	f7ff b82c 	b.w	2784 <usb_tx>
    372c:	1fff1705 	.word	0x1fff1705
    3730:	1fff1708 	.word	0x1fff1708
    3734:	1fff1704 	.word	0x1fff1704

00003738 <EventResponder::triggerEventNotImmediate()>:
bool EventResponder::runningFromYield = false;

// TODO: interrupt disable/enable needed in many places!!!

void EventResponder::triggerEventNotImmediate()
{
    3738:	b410      	push	{r4}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    373a:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    373e:	b672      	cpsid	i
	bool irq = disableInterrupts();
	if (_triggered == false) {
    3740:	7f43      	ldrb	r3, [r0, #29]
    3742:	b933      	cbnz	r3, 3752 <EventResponder::triggerEventNotImmediate()+0x1a>
		// not already triggered
		if (_type == EventTypeYield) {
    3744:	7f01      	ldrb	r1, [r0, #28]
    3746:	2901      	cmp	r1, #1
    3748:	d008      	beq.n	375c <EventResponder::triggerEventNotImmediate()+0x24>
				_next = nullptr;
				_prev = lastYield;
				_prev->_next = this;
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
    374a:	2903      	cmp	r1, #3
    374c:	d010      	beq.n	3770 <EventResponder::triggerEventNotImmediate()+0x38>
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
		} else {
			// detached, easy :-)
		}
		_triggered = true;
    374e:	2301      	movs	r3, #1
    3750:	7743      	strb	r3, [r0, #29]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    3752:	b902      	cbnz	r2, 3756 <EventResponder::triggerEventNotImmediate()+0x1e>
    3754:	b662      	cpsie	i
	}
	enableInterrupts(irq);
}
    3756:	f85d 4b04 	ldr.w	r4, [sp], #4
    375a:	4770      	bx	lr
	bool irq = disableInterrupts();
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
    375c:	4c11      	ldr	r4, [pc, #68]	; (37a4 <EventResponder::triggerEventNotImmediate()+0x6c>)
    375e:	6821      	ldr	r1, [r4, #0]
    3760:	b1a1      	cbz	r1, 378c <EventResponder::triggerEventNotImmediate()+0x54>
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
    3762:	4911      	ldr	r1, [pc, #68]	; (37a8 <EventResponder::triggerEventNotImmediate()+0x70>)
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
    3764:	6143      	str	r3, [r0, #20]
				_prev = lastYield;
    3766:	680b      	ldr	r3, [r1, #0]
    3768:	6183      	str	r3, [r0, #24]
				_prev->_next = this;
				lastYield = this;
    376a:	6008      	str	r0, [r1, #0]
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
				_prev->_next = this;
    376c:	6158      	str	r0, [r3, #20]
    376e:	e7ee      	b.n	374e <EventResponder::triggerEventNotImmediate()+0x16>
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
    3770:	4c0e      	ldr	r4, [pc, #56]	; (37ac <EventResponder::triggerEventNotImmediate()+0x74>)
    3772:	6821      	ldr	r1, [r4, #0]
    3774:	b181      	cbz	r1, 3798 <EventResponder::triggerEventNotImmediate()+0x60>
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
    3776:	490e      	ldr	r1, [pc, #56]	; (37b0 <EventResponder::triggerEventNotImmediate()+0x78>)
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
    3778:	6143      	str	r3, [r0, #20]
				_prev = lastInterrupt;
    377a:	680b      	ldr	r3, [r1, #0]
    377c:	6183      	str	r3, [r0, #24]
				_prev->_next = this;
				lastInterrupt = this;
    377e:	6008      	str	r0, [r1, #0]
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
				_prev->_next = this;
    3780:	6158      	str	r0, [r3, #20]
				lastInterrupt = this;
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
    3782:	4b0c      	ldr	r3, [pc, #48]	; (37b4 <EventResponder::triggerEventNotImmediate()+0x7c>)
    3784:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
    3788:	6019      	str	r1, [r3, #0]
    378a:	e7e0      	b.n	374e <EventResponder::triggerEventNotImmediate()+0x16>
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
    378c:	4b06      	ldr	r3, [pc, #24]	; (37a8 <EventResponder::triggerEventNotImmediate()+0x70>)
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
    378e:	6141      	str	r1, [r0, #20]
				_prev = nullptr;
    3790:	6181      	str	r1, [r0, #24]
				firstYield = this;
    3792:	6020      	str	r0, [r4, #0]
				lastYield = this;
    3794:	6018      	str	r0, [r3, #0]
    3796:	e7da      	b.n	374e <EventResponder::triggerEventNotImmediate()+0x16>
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
    3798:	4b05      	ldr	r3, [pc, #20]	; (37b0 <EventResponder::triggerEventNotImmediate()+0x78>)
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
    379a:	6141      	str	r1, [r0, #20]
				_prev = nullptr;
    379c:	6181      	str	r1, [r0, #24]
				firstInterrupt = this;
    379e:	6020      	str	r0, [r4, #0]
				lastInterrupt = this;
    37a0:	6018      	str	r0, [r3, #0]
    37a2:	e7ee      	b.n	3782 <EventResponder::triggerEventNotImmediate()+0x4a>
    37a4:	1fff1728 	.word	0x1fff1728
    37a8:	1fff1724 	.word	0x1fff1724
    37ac:	1fff1718 	.word	0x1fff1718
    37b0:	1fff171c 	.word	0x1fff171c
    37b4:	e000ed04 	.word	0xe000ed04

000037b8 <EventResponder::triggerEvent(int, void*)>:
	}

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
    37b8:	b410      	push	{r4}
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    37ba:	7f04      	ldrb	r4, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    37bc:	6041      	str	r1, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    37be:	2c02      	cmp	r4, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    37c0:	60c2      	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    37c2:	d003      	beq.n	37cc <EventResponder::triggerEvent(int, void*)+0x14>
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
		}
	}
    37c4:	f85d 4b04 	ldr.w	r4, [sp], #4
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    37c8:	f7ff bfb6 	b.w	3738 <EventResponder::triggerEventNotImmediate()>
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    37cc:	6883      	ldr	r3, [r0, #8]
		} else {
			triggerEventNotImmediate();
		}
	}
    37ce:	f85d 4b04 	ldr.w	r4, [sp], #4
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    37d2:	4718      	bx	r3

000037d4 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    37d4:	b570      	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    37d6:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    37da:	b672      	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    37dc:	4c0c      	ldr	r4, [pc, #48]	; (3810 <EventResponder::runFromInterrupt()+0x3c>)
    37de:	6820      	ldr	r0, [r4, #0]
		if (first) {
    37e0:	b180      	cbz	r0, 3804 <EventResponder::runFromInterrupt()+0x30>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    37e2:	4e0c      	ldr	r6, [pc, #48]	; (3814 <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    37e4:	2500      	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    37e6:	6943      	ldr	r3, [r0, #20]
    37e8:	6023      	str	r3, [r4, #0]
			if (firstInterrupt) {
    37ea:	b173      	cbz	r3, 380a <EventResponder::runFromInterrupt()+0x36>
				firstInterrupt->_prev = nullptr;
    37ec:	619d      	str	r5, [r3, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    37ee:	b902      	cbnz	r2, 37f2 <EventResponder::runFromInterrupt()+0x1e>
    37f0:	b662      	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    37f2:	7745      	strb	r5, [r0, #29]
			(*(first->_function))(*first);
    37f4:	6883      	ldr	r3, [r0, #8]
    37f6:	4798      	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    37f8:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    37fc:	b672      	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    37fe:	6820      	ldr	r0, [r4, #0]
		if (first) {
    3800:	2800      	cmp	r0, #0
    3802:	d1f0      	bne.n	37e6 <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    3804:	b902      	cbnz	r2, 3808 <EventResponder::runFromInterrupt()+0x34>
    3806:	b662      	cpsie	i
    3808:	bd70      	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    380a:	6033      	str	r3, [r6, #0]
    380c:	e7ef      	b.n	37ee <EventResponder::runFromInterrupt()+0x1a>
    380e:	bf00      	nop
    3810:	1fff1718 	.word	0x1fff1718
    3814:	1fff171c 	.word	0x1fff171c

00003818 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    3818:	f7ff bfdc 	b.w	37d4 <EventResponder::runFromInterrupt()>

0000381c <MillisTimer::addToActiveList()>:
	enableTimerInterrupt(irq);
}

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
	if (listActive == nullptr) {
    381c:	4a18      	ldr	r2, [pc, #96]	; (3880 <MillisTimer::addToActiveList()+0x64>)
	_state = TimerWaiting;
	enableTimerInterrupt(irq);
}

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
    381e:	b430      	push	{r4, r5}
	if (listActive == nullptr) {
    3820:	6814      	ldr	r4, [r2, #0]
    3822:	2c00      	cmp	r4, #0
    3824:	d027      	beq.n	3876 <MillisTimer::addToActiveList()+0x5a>
		// list is empty, easy case
		_next = nullptr;
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
    3826:	6803      	ldr	r3, [r0, #0]
    3828:	6821      	ldr	r1, [r4, #0]
    382a:	428b      	cmp	r3, r1
    382c:	d20e      	bcs.n	384c <MillisTimer::addToActiveList()+0x30>
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
		listActive->_prev = this;
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
    382e:	1acb      	subs	r3, r1, r3
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
    3830:	2100      	movs	r1, #0
		_next = nullptr;
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
    3832:	6084      	str	r4, [r0, #8]
		_prev = nullptr;
    3834:	60c1      	str	r1, [r0, #12]
		listActive->_prev = this;
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
    3836:	6023      	str	r3, [r4, #0]
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
		listActive->_prev = this;
    3838:	60e0      	str	r0, [r4, #12]
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
		listActive = this;
    383a:	6010      	str	r0, [r2, #0]
		_ms -= timer->_ms;
		_next = nullptr;
		_prev = timer;
		timer->_next = this;
	}
	_state = TimerActive;
    383c:	2302      	movs	r3, #2
    383e:	7503      	strb	r3, [r0, #20]
}
    3840:	bc30      	pop	{r4, r5}
    3842:	4770      	bx	lr
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
    3844:	6811      	ldr	r1, [r2, #0]
    3846:	428b      	cmp	r3, r1
    3848:	4614      	mov	r4, r2
    384a:	d308      	bcc.n	385e <MillisTimer::addToActiveList()+0x42>
		listActive->_ms -= _ms;	
		listActive = this;
	} else {
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
    384c:	68a2      	ldr	r2, [r4, #8]
				_state = TimerActive;
				return;
			}
		}
		// add this time at the end of the list
		_ms -= timer->_ms;
    384e:	1a5b      	subs	r3, r3, r1
    3850:	6003      	str	r3, [r0, #0]
		listActive->_ms -= _ms;	
		listActive = this;
	} else {
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
    3852:	2a00      	cmp	r2, #0
    3854:	d1f6      	bne.n	3844 <MillisTimer::addToActiveList()+0x28>
				return;
			}
		}
		// add this time at the end of the list
		_ms -= timer->_ms;
		_next = nullptr;
    3856:	6082      	str	r2, [r0, #8]
		_prev = timer;
    3858:	60c4      	str	r4, [r0, #12]
		timer->_next = this;
    385a:	60a0      	str	r0, [r4, #8]
    385c:	e7ee      	b.n	383c <MillisTimer::addToActiveList()+0x20>
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
				_prev = timer->_prev;
    385e:	68d2      	ldr	r2, [r2, #12]
    3860:	60c2      	str	r2, [r0, #12]
		while (timer->_next) {
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
    3862:	6084      	str	r4, [r0, #8]
				_prev = timer->_prev;
				timer->_prev = this;
    3864:	60e0      	str	r0, [r4, #12]
				_prev->_next = this;
    3866:	68c5      	ldr	r5, [r0, #12]
				timer->_ms -= _ms;
    3868:	1acb      	subs	r3, r1, r3
				_state = TimerActive;
    386a:	2202      	movs	r2, #2
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
				_prev = timer->_prev;
				timer->_prev = this;
				_prev->_next = this;
    386c:	60a8      	str	r0, [r5, #8]
				timer->_ms -= _ms;
    386e:	6023      	str	r3, [r4, #0]
				_state = TimerActive;
    3870:	7502      	strb	r2, [r0, #20]
		_next = nullptr;
		_prev = timer;
		timer->_next = this;
	}
	_state = TimerActive;
}
    3872:	bc30      	pop	{r4, r5}
    3874:	4770      	bx	lr

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
	if (listActive == nullptr) {
		// list is empty, easy case
		_next = nullptr;
    3876:	6084      	str	r4, [r0, #8]
		_prev = nullptr;
    3878:	60c4      	str	r4, [r0, #12]
		listActive = this;
    387a:	6010      	str	r0, [r2, #0]
    387c:	e7de      	b.n	383c <MillisTimer::addToActiveList()+0x20>
    387e:	bf00      	nop
    3880:	1fff1720 	.word	0x1fff1720

00003884 <MillisTimer::runFromTimer()>:
	}
	enableTimerInterrupt(irq);
}

void MillisTimer::runFromTimer()
{
    3884:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	MillisTimer *timer = listActive;
    3886:	4e22      	ldr	r6, [pc, #136]	; (3910 <MillisTimer::runFromTimer()+0x8c>)
    3888:	6834      	ldr	r4, [r6, #0]
	while (timer) {
    388a:	b32c      	cbz	r4, 38d8 <MillisTimer::runFromTimer()+0x54>
		if (timer->_ms > 0) {
    388c:	6823      	ldr	r3, [r4, #0]
    388e:	2b00      	cmp	r3, #0
    3890:	d13a      	bne.n	3908 <MillisTimer::runFromTimer()+0x84>
    3892:	4f20      	ldr	r7, [pc, #128]	; (3914 <MillisTimer::runFromTimer()+0x90>)
			timer->_ms--;
			break;
		} else {
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
    3894:	461d      	mov	r5, r3
    3896:	e004      	b.n	38a2 <MillisTimer::runFromTimer()+0x1e>
			event.triggerEvent(0, timer);
			if (timer->_reload) {
				timer->_ms = timer->_reload;
				timer->addToActiveList();
			}
			timer = listActive;
    3898:	6834      	ldr	r4, [r6, #0]
}

void MillisTimer::runFromTimer()
{
	MillisTimer *timer = listActive;
	while (timer) {
    389a:	b1ec      	cbz	r4, 38d8 <MillisTimer::runFromTimer()+0x54>
		if (timer->_ms > 0) {
    389c:	6823      	ldr	r3, [r4, #0]
    389e:	2b00      	cmp	r3, #0
    38a0:	d132      	bne.n	3908 <MillisTimer::runFromTimer()+0x84>
			timer->_ms--;
			break;
		} else {
			MillisTimer *next = timer->_next;
    38a2:	68a3      	ldr	r3, [r4, #8]
			if (next) next->_prev = nullptr;
    38a4:	b103      	cbz	r3, 38a8 <MillisTimer::runFromTimer()+0x24>
    38a6:	60dd      	str	r5, [r3, #12]
			listActive = next;
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
    38a8:	6920      	ldr	r0, [r4, #16]
			timer->_ms--;
			break;
		} else {
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
			listActive = next;
    38aa:	6033      	str	r3, [r6, #0]
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
    38ac:	6803      	ldr	r3, [r0, #0]
			break;
		} else {
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
			listActive = next;
			timer->_state = TimerOff;
    38ae:	7525      	strb	r5, [r4, #20]
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
    38b0:	681b      	ldr	r3, [r3, #0]
    38b2:	42bb      	cmp	r3, r7
    38b4:	d121      	bne.n	38fa <MillisTimer::runFromTimer()+0x76>
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    38b6:	7f03      	ldrb	r3, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    38b8:	6045      	str	r5, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    38ba:	2b02      	cmp	r3, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    38bc:	60c4      	str	r4, [r0, #12]
		if (_type == EventTypeImmediate) {
    38be:	d020      	beq.n	3902 <MillisTimer::runFromTimer()+0x7e>
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    38c0:	f7ff ff3a 	bl	3738 <EventResponder::triggerEventNotImmediate()>
			if (timer->_reload) {
    38c4:	6863      	ldr	r3, [r4, #4]
    38c6:	2b00      	cmp	r3, #0
    38c8:	d0e6      	beq.n	3898 <MillisTimer::runFromTimer()+0x14>
				timer->_ms = timer->_reload;
    38ca:	6023      	str	r3, [r4, #0]
				timer->addToActiveList();
    38cc:	4620      	mov	r0, r4
    38ce:	f7ff ffa5 	bl	381c <MillisTimer::addToActiveList()>
			}
			timer = listActive;
    38d2:	6834      	ldr	r4, [r6, #0]
}

void MillisTimer::runFromTimer()
{
	MillisTimer *timer = listActive;
	while (timer) {
    38d4:	2c00      	cmp	r4, #0
    38d6:	d1e1      	bne.n	389c <MillisTimer::runFromTimer()+0x18>
	volatile TimerStateType _state = TimerOff;
	static MillisTimer *listWaiting; // single linked list of waiting to start timers
	static MillisTimer *listActive;  // double linked list of running timers
	static bool disableTimerInterrupt() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    38d8:	f3ef 8310 	mrs	r3, PRIMASK
		__disable_irq();
    38dc:	b672      	cpsid	i
			}
			timer = listActive;
		}
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
    38de:	4a0e      	ldr	r2, [pc, #56]	; (3918 <MillisTimer::runFromTimer()+0x94>)
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
    38e0:	2100      	movs	r1, #0
			}
			timer = listActive;
		}
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
    38e2:	6810      	ldr	r0, [r2, #0]
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
    38e4:	6011      	str	r1, [r2, #0]
		return (primask == 0) ? true : false;
	}
	static void enableTimerInterrupt(bool doit) {
		if (doit) __enable_irq();
    38e6:	b903      	cbnz	r3, 38ea <MillisTimer::runFromTimer()+0x66>
    38e8:	b662      	cpsie	i
	enableTimerInterrupt(irq);
	while (waiting) {
    38ea:	b128      	cbz	r0, 38f8 <MillisTimer::runFromTimer()+0x74>
		MillisTimer *next = waiting->_next;
    38ec:	6884      	ldr	r4, [r0, #8]
		waiting->addToActiveList();
    38ee:	f7ff ff95 	bl	381c <MillisTimer::addToActiveList()>
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
	enableTimerInterrupt(irq);
	while (waiting) {
    38f2:	4620      	mov	r0, r4
    38f4:	2800      	cmp	r0, #0
    38f6:	d1f9      	bne.n	38ec <MillisTimer::runFromTimer()+0x68>
    38f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
			listActive = next;
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
    38fa:	4622      	mov	r2, r4
    38fc:	2100      	movs	r1, #0
    38fe:	4798      	blx	r3
    3900:	e7e0      	b.n	38c4 <MillisTimer::runFromTimer()+0x40>
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    3902:	6883      	ldr	r3, [r0, #8]
    3904:	4798      	blx	r3
    3906:	e7dd      	b.n	38c4 <MillisTimer::runFromTimer()+0x40>
void MillisTimer::runFromTimer()
{
	MillisTimer *timer = listActive;
	while (timer) {
		if (timer->_ms > 0) {
			timer->_ms--;
    3908:	3b01      	subs	r3, #1
    390a:	6023      	str	r3, [r4, #0]
			break;
    390c:	e7e4      	b.n	38d8 <MillisTimer::runFromTimer()+0x54>
    390e:	bf00      	nop
    3910:	1fff1720 	.word	0x1fff1720
    3914:	000037b9 	.word	0x000037b9
    3918:	1fff1730 	.word	0x1fff1730

0000391c <systick_isr>:
// with libraries using mid-to-high priority interrupts.

extern "C" volatile uint32_t systick_millis_count;
void systick_isr(void)
{
	systick_millis_count++;
    391c:	4a02      	ldr	r2, [pc, #8]	; (3928 <systick_isr+0xc>)
    391e:	6813      	ldr	r3, [r2, #0]
    3920:	3301      	adds	r3, #1
    3922:	6013      	str	r3, [r2, #0]
	MillisTimer::runFromTimer();
    3924:	f7ff bfae 	b.w	3884 <MillisTimer::runFromTimer()>
    3928:	1fff1618 	.word	0x1fff1618

0000392c <dummy_funct()>:
	}
}
#endif

static void dummy_funct(void)
{
    392c:	4770      	bx	lr
    392e:	bf00      	nop

00003930 <IntervalTimer::beginCycles(void (*)(), unsigned long)>:
#endif


bool IntervalTimer::beginCycles(void (*funct)(), uint32_t cycles)
{
	if (channel) {
    3930:	6803      	ldr	r3, [r0, #0]
uint8_t IntervalTimer::nvic_priorites[2] = {255, 255};
#endif


bool IntervalTimer::beginCycles(void (*funct)(), uint32_t cycles)
{
    3932:	b4f0      	push	{r4, r5, r6, r7}
	if (channel) {
    3934:	b1fb      	cbz	r3, 3976 <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x46>
		channel->TCTRL = 0;
    3936:	2500      	movs	r5, #0
		channel->TFLG = 1;
    3938:	2401      	movs	r4, #1


bool IntervalTimer::beginCycles(void (*funct)(), uint32_t cycles)
{
	if (channel) {
		channel->TCTRL = 0;
    393a:	609d      	str	r5, [r3, #8]
		channel->TFLG = 1;
    393c:	60dc      	str	r4, [r3, #12]
				channel = NULL;
				return false;
			}
		}
	}
	int index = channel - KINETISK_PIT_CHANNELS;
    393e:	4c1b      	ldr	r4, [pc, #108]	; (39ac <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x7c>)
	funct_table[index] = funct;
	channel->LDVAL = cycles;
    3940:	601a      	str	r2, [r3, #0]
				channel = NULL;
				return false;
			}
		}
	}
	int index = channel - KINETISK_PIT_CHANNELS;
    3942:	441c      	add	r4, r3
    3944:	1124      	asrs	r4, r4, #4
	funct_table[index] = funct;
	channel->LDVAL = cycles;
	channel->TCTRL = 3;
#if defined(KINETISK)
	NVIC_SET_PRIORITY(IRQ_PIT_CH0 + index, nvic_priority);
	NVIC_ENABLE_IRQ(IRQ_PIT_CH0 + index);
    3946:	f104 0530 	add.w	r5, r4, #48	; 0x30
    394a:	116a      	asrs	r2, r5, #5
		}
	}
	int index = channel - KINETISK_PIT_CHANNELS;
	funct_table[index] = funct;
	channel->LDVAL = cycles;
	channel->TCTRL = 3;
    394c:	2603      	movs	r6, #3
#if defined(KINETISK)
	NVIC_SET_PRIORITY(IRQ_PIT_CH0 + index, nvic_priority);
	NVIC_ENABLE_IRQ(IRQ_PIT_CH0 + index);
    394e:	0092      	lsls	r2, r2, #2
		}
	}
	int index = channel - KINETISK_PIT_CHANNELS;
	funct_table[index] = funct;
	channel->LDVAL = cycles;
	channel->TCTRL = 3;
    3950:	609e      	str	r6, [r3, #8]
				return false;
			}
		}
	}
	int index = channel - KINETISK_PIT_CHANNELS;
	funct_table[index] = funct;
    3952:	4f17      	ldr	r7, [pc, #92]	; (39b0 <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x80>)
	channel->LDVAL = cycles;
	channel->TCTRL = 3;
#if defined(KINETISK)
	NVIC_SET_PRIORITY(IRQ_PIT_CH0 + index, nvic_priority);
    3954:	7906      	ldrb	r6, [r0, #4]
    3956:	4b17      	ldr	r3, [pc, #92]	; (39b4 <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x84>)
				return false;
			}
		}
	}
	int index = channel - KINETISK_PIT_CHANNELS;
	funct_table[index] = funct;
    3958:	f847 1024 	str.w	r1, [r7, r4, lsl #2]
	channel->LDVAL = cycles;
	channel->TCTRL = 3;
#if defined(KINETISK)
	NVIC_SET_PRIORITY(IRQ_PIT_CH0 + index, nvic_priority);
	NVIC_ENABLE_IRQ(IRQ_PIT_CH0 + index);
    395c:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
    3960:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
    3964:	f005 051f 	and.w	r5, r5, #31
    3968:	2001      	movs	r0, #1
    396a:	fa00 f505 	lsl.w	r5, r0, r5
	int index = channel - KINETISK_PIT_CHANNELS;
	funct_table[index] = funct;
	channel->LDVAL = cycles;
	channel->TCTRL = 3;
#if defined(KINETISK)
	NVIC_SET_PRIORITY(IRQ_PIT_CH0 + index, nvic_priority);
    396e:	54e6      	strb	r6, [r4, r3]
	NVIC_ENABLE_IRQ(IRQ_PIT_CH0 + index);
    3970:	6015      	str	r5, [r2, #0]
		NVIC_SET_PRIORITY(IRQ_PIT, nvic_priorites[1]);
	}
	NVIC_ENABLE_IRQ(IRQ_PIT);
#endif
	return true;
}
    3972:	bcf0      	pop	{r4, r5, r6, r7}
    3974:	4770      	bx	lr
{
	if (channel) {
		channel->TCTRL = 0;
		channel->TFLG = 1;
	} else {
		SIM_SCGC6 |= SIM_SCGC6_PIT;
    3976:	4c10      	ldr	r4, [pc, #64]	; (39b8 <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x88>)
    3978:	6823      	ldr	r3, [r4, #0]
    397a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
    397e:	6023      	str	r3, [r4, #0]
		__asm__ volatile("nop"); // solves timing problem on Teensy 3.5
    3980:	bf00      	nop
		PIT_MCR = 1;
    3982:	4b0e      	ldr	r3, [pc, #56]	; (39bc <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x8c>)
		channel = KINETISK_PIT_CHANNELS;
		while (1) {
			if (channel->TCTRL == 0) break;
			if (++channel >= KINETISK_PIT_CHANNELS + NUM_CHANNELS) {
    3984:	4d0e      	ldr	r5, [pc, #56]	; (39c0 <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x90>)
		channel->TFLG = 1;
	} else {
		SIM_SCGC6 |= SIM_SCGC6_PIT;
		__asm__ volatile("nop"); // solves timing problem on Teensy 3.5
		PIT_MCR = 1;
		channel = KINETISK_PIT_CHANNELS;
    3986:	f5a4 3487 	sub.w	r4, r4, #69120	; 0x10e00
    398a:	f5a4 749e 	sub.w	r4, r4, #316	; 0x13c
		channel->TCTRL = 0;
		channel->TFLG = 1;
	} else {
		SIM_SCGC6 |= SIM_SCGC6_PIT;
		__asm__ volatile("nop"); // solves timing problem on Teensy 3.5
		PIT_MCR = 1;
    398e:	2601      	movs	r6, #1
    3990:	601e      	str	r6, [r3, #0]
		channel = KINETISK_PIT_CHANNELS;
    3992:	4623      	mov	r3, r4
    3994:	6004      	str	r4, [r0, #0]
		while (1) {
			if (channel->TCTRL == 0) break;
    3996:	689c      	ldr	r4, [r3, #8]
    3998:	2c00      	cmp	r4, #0
    399a:	d0d0      	beq.n	393e <IntervalTimer::beginCycles(void (*)(), unsigned long)+0xe>
			if (++channel >= KINETISK_PIT_CHANNELS + NUM_CHANNELS) {
    399c:	3310      	adds	r3, #16
    399e:	42ab      	cmp	r3, r5
    39a0:	6003      	str	r3, [r0, #0]
    39a2:	d1f8      	bne.n	3996 <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x66>
				channel = NULL;
    39a4:	2300      	movs	r3, #0
    39a6:	6003      	str	r3, [r0, #0]
				return false;
    39a8:	4618      	mov	r0, r3
    39aa:	e7e2      	b.n	3972 <IntervalTimer::beginCycles(void (*)(), unsigned long)+0x42>
    39ac:	bffc8f00 	.word	0xbffc8f00
    39b0:	1fff09dc 	.word	0x1fff09dc
    39b4:	e000e430 	.word	0xe000e430
    39b8:	4004803c 	.word	0x4004803c
    39bc:	40037000 	.word	0x40037000
    39c0:	40037140 	.word	0x40037140

000039c4 <IntervalTimer::end()>:
	return true;
}


void IntervalTimer::end() {
	if (channel) {
    39c4:	6801      	ldr	r1, [r0, #0]
    39c6:	b1a9      	cbz	r1, 39f4 <IntervalTimer::end()+0x30>
		int index = channel - KINETISK_PIT_CHANNELS;
    39c8:	4b0b      	ldr	r3, [pc, #44]	; (39f8 <IntervalTimer::end()+0x34>)
#endif
	return true;
}


void IntervalTimer::end() {
    39ca:	b4f0      	push	{r4, r5, r6, r7}
	if (channel) {
		int index = channel - KINETISK_PIT_CHANNELS;
    39cc:	440b      	add	r3, r1
    39ce:	111b      	asrs	r3, r3, #4
#if defined(KINETISK)
		NVIC_DISABLE_IRQ(IRQ_PIT_CH0 + index);
#elif defined(KINETISL)
		// TODO: disable IRQ_PIT, but only if both instances ended
#endif
		funct_table[index] = dummy_funct;
    39d0:	4e0a      	ldr	r6, [pc, #40]	; (39fc <IntervalTimer::end()+0x38>)
    39d2:	4f0b      	ldr	r7, [pc, #44]	; (3a00 <IntervalTimer::end()+0x3c>)

void IntervalTimer::end() {
	if (channel) {
		int index = channel - KINETISK_PIT_CHANNELS;
#if defined(KINETISK)
		NVIC_DISABLE_IRQ(IRQ_PIT_CH0 + index);
    39d4:	4d0b      	ldr	r5, [pc, #44]	; (3a04 <IntervalTimer::end()+0x40>)
#elif defined(KINETISL)
		// TODO: disable IRQ_PIT, but only if both instances ended
#endif
		funct_table[index] = dummy_funct;
    39d6:	f846 7023 	str.w	r7, [r6, r3, lsl #2]

void IntervalTimer::end() {
	if (channel) {
		int index = channel - KINETISK_PIT_CHANNELS;
#if defined(KINETISK)
		NVIC_DISABLE_IRQ(IRQ_PIT_CH0 + index);
    39da:	f103 0230 	add.w	r2, r3, #48	; 0x30
    39de:	f002 041f 	and.w	r4, r2, #31
    39e2:	2301      	movs	r3, #1
    39e4:	1152      	asrs	r2, r2, #5
    39e6:	40a3      	lsls	r3, r4
#elif defined(KINETISL)
		// TODO: disable IRQ_PIT, but only if both instances ended
#endif
		funct_table[index] = dummy_funct;
		channel->TCTRL = 0;
    39e8:	2400      	movs	r4, #0

void IntervalTimer::end() {
	if (channel) {
		int index = channel - KINETISK_PIT_CHANNELS;
#if defined(KINETISK)
		NVIC_DISABLE_IRQ(IRQ_PIT_CH0 + index);
    39ea:	f845 3022 	str.w	r3, [r5, r2, lsl #2]
#elif defined(KINETISL)
		// TODO: disable IRQ_PIT, but only if both instances ended
#endif
		funct_table[index] = dummy_funct;
		channel->TCTRL = 0;
    39ee:	608c      	str	r4, [r1, #8]
			NVIC_SET_PRIORITY(IRQ_PIT, nvic_priorites[0]);
		} else {
			NVIC_SET_PRIORITY(IRQ_PIT, nvic_priorites[1]);
		}
#endif
		channel = 0;
    39f0:	6004      	str	r4, [r0, #0]
	}
}
    39f2:	bcf0      	pop	{r4, r5, r6, r7}
    39f4:	4770      	bx	lr
    39f6:	bf00      	nop
    39f8:	bffc8f00 	.word	0xbffc8f00
    39fc:	1fff09dc 	.word	0x1fff09dc
    3a00:	0000392d 	.word	0x0000392d
    3a04:	e000e180 	.word	0xe000e180

00003a08 <pit0_isr>:


#if defined(KINETISK)
void pit0_isr()
{
	PIT_TFLG0 = 1;
    3a08:	4a02      	ldr	r2, [pc, #8]	; (3a14 <pit0_isr+0xc>)
	funct_table[0]();
    3a0a:	4b03      	ldr	r3, [pc, #12]	; (3a18 <pit0_isr+0x10>)


#if defined(KINETISK)
void pit0_isr()
{
	PIT_TFLG0 = 1;
    3a0c:	2101      	movs	r1, #1
    3a0e:	6011      	str	r1, [r2, #0]
	funct_table[0]();
    3a10:	681b      	ldr	r3, [r3, #0]
    3a12:	4718      	bx	r3
    3a14:	4003710c 	.word	0x4003710c
    3a18:	1fff09dc 	.word	0x1fff09dc

00003a1c <pit1_isr>:
}

void pit1_isr() {
	PIT_TFLG1 = 1;
    3a1c:	4a02      	ldr	r2, [pc, #8]	; (3a28 <pit1_isr+0xc>)
	funct_table[1]();
    3a1e:	4b03      	ldr	r3, [pc, #12]	; (3a2c <pit1_isr+0x10>)
	PIT_TFLG0 = 1;
	funct_table[0]();
}

void pit1_isr() {
	PIT_TFLG1 = 1;
    3a20:	2101      	movs	r1, #1
    3a22:	6011      	str	r1, [r2, #0]
	funct_table[1]();
    3a24:	685b      	ldr	r3, [r3, #4]
    3a26:	4718      	bx	r3
    3a28:	4003711c 	.word	0x4003711c
    3a2c:	1fff09dc 	.word	0x1fff09dc

00003a30 <pit2_isr>:
}

void pit2_isr() {
	PIT_TFLG2 = 1;
    3a30:	4a02      	ldr	r2, [pc, #8]	; (3a3c <pit2_isr+0xc>)
	funct_table[2]();
    3a32:	4b03      	ldr	r3, [pc, #12]	; (3a40 <pit2_isr+0x10>)
	PIT_TFLG1 = 1;
	funct_table[1]();
}

void pit2_isr() {
	PIT_TFLG2 = 1;
    3a34:	2101      	movs	r1, #1
    3a36:	6011      	str	r1, [r2, #0]
	funct_table[2]();
    3a38:	689b      	ldr	r3, [r3, #8]
    3a3a:	4718      	bx	r3
    3a3c:	4003712c 	.word	0x4003712c
    3a40:	1fff09dc 	.word	0x1fff09dc

00003a44 <pit3_isr>:
}

void pit3_isr() {
	PIT_TFLG3 = 1;
    3a44:	4a02      	ldr	r2, [pc, #8]	; (3a50 <pit3_isr+0xc>)
	funct_table[3]();
    3a46:	4b03      	ldr	r3, [pc, #12]	; (3a54 <pit3_isr+0x10>)
	PIT_TFLG2 = 1;
	funct_table[2]();
}

void pit3_isr() {
	PIT_TFLG3 = 1;
    3a48:	2101      	movs	r1, #1
    3a4a:	6011      	str	r1, [r2, #0]
	funct_table[3]();
    3a4c:	68db      	ldr	r3, [r3, #12]
    3a4e:	4718      	bx	r3
    3a50:	4003713c 	.word	0x4003713c
    3a54:	1fff09dc 	.word	0x1fff09dc

00003a58 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    3a58:	b508      	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    3a5a:	f7fc fe29 	bl	6b0 <setup>
	while (1) {
		loop();
    3a5e:	f7fc fd5f 	bl	520 <loop>
		yield();
    3a62:	f000 f94b 	bl	3cfc <yield>
    3a66:	e7fa      	b.n	3a5e <main+0x6>

00003a68 <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    3a68:	b500      	push	{lr}
	uint8_t buf[2]={'\r', '\n'};
    3a6a:	4a06      	ldr	r2, [pc, #24]	; (3a84 <Print::println()+0x1c>)
	return write(buf, 2);
    3a6c:	6803      	ldr	r3, [r0, #0]
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    3a6e:	8812      	ldrh	r2, [r2, #0]
	return write(buf, 2);
    3a70:	685b      	ldr	r3, [r3, #4]
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    3a72:	b083      	sub	sp, #12
	uint8_t buf[2]={'\r', '\n'};
	return write(buf, 2);
    3a74:	a901      	add	r1, sp, #4
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    3a76:	f8ad 2004 	strh.w	r2, [sp, #4]
	return write(buf, 2);
    3a7a:	2202      	movs	r2, #2
    3a7c:	4798      	blx	r3
}
    3a7e:	b003      	add	sp, #12
    3a80:	f85d fb04 	ldr.w	pc, [sp], #4
    3a84:	00006b68 	.word	0x00006b68

00003a88 <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
}

#else

size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
{
    3a88:	b5f0      	push	{r4, r5, r6, r7, lr}
    3a8a:	4607      	mov	r7, r0
    3a8c:	b08b      	sub	sp, #44	; 0x2c
	uint8_t digit, i;

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
    3a8e:	2a00      	cmp	r2, #0
    3a90:	d033      	beq.n	3afa <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x72>
		return write((uint8_t)n);
	} else if (base == 1) {
		base = 10;
    3a92:	2a01      	cmp	r2, #1
    3a94:	bf08      	it	eq
    3a96:	220a      	moveq	r2, #10
	}


	if (n == 0) {
    3a98:	b351      	cbz	r1, 3af0 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x68>
    3a9a:	2421      	movs	r4, #33	; 0x21
    3a9c:	e000      	b.n	3aa0 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x18>
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
			i--;
    3a9e:	b2f4      	uxtb	r4, r6
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    3aa0:	fbb1 f5f2 	udiv	r5, r1, r2
    3aa4:	fb02 1115 	mls	r1, r2, r5, r1
    3aa8:	b2c8      	uxtb	r0, r1
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    3aaa:	2909      	cmp	r1, #9
    3aac:	f100 0130 	add.w	r1, r0, #48	; 0x30
    3ab0:	bf98      	it	ls
    3ab2:	b2c8      	uxtbls	r0, r1
    3ab4:	a90a      	add	r1, sp, #40	; 0x28
    3ab6:	bf88      	it	hi
    3ab8:	3037      	addhi	r0, #55	; 0x37
    3aba:	4421      	add	r1, r4
    3abc:	bf88      	it	hi
    3abe:	b2c0      	uxtbhi	r0, r0
    3ac0:	f801 0c24 	strb.w	r0, [r1, #-36]
			n /= base;
			if (n == 0) break;
			i--;
    3ac4:	1e66      	subs	r6, r4, #1
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
    3ac6:	4629      	mov	r1, r5
    3ac8:	2d00      	cmp	r5, #0
    3aca:	d1e8      	bne.n	3a9e <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x16>
			i--;
		}
	}
	if (sign) {
    3acc:	b133      	cbz	r3, 3adc <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x54>
		i--;
    3ace:	3c01      	subs	r4, #1
    3ad0:	b2e4      	uxtb	r4, r4
		buf[i] = '-';
    3ad2:	ab0a      	add	r3, sp, #40	; 0x28
    3ad4:	4423      	add	r3, r4
    3ad6:	222d      	movs	r2, #45	; 0x2d
    3ad8:	f803 2c24 	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
    3adc:	683b      	ldr	r3, [r7, #0]
    3ade:	aa01      	add	r2, sp, #4
    3ae0:	1911      	adds	r1, r2, r4
    3ae2:	685b      	ldr	r3, [r3, #4]
    3ae4:	4638      	mov	r0, r7
    3ae6:	f1c4 0222 	rsb	r2, r4, #34	; 0x22
    3aea:	4798      	blx	r3
}
    3aec:	b00b      	add	sp, #44	; 0x2c
    3aee:	bdf0      	pop	{r4, r5, r6, r7, pc}
		base = 10;
	}


	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    3af0:	2230      	movs	r2, #48	; 0x30
    3af2:	f88d 2025 	strb.w	r2, [sp, #37]	; 0x25
		i = sizeof(buf) - 1;
    3af6:	2421      	movs	r4, #33	; 0x21
    3af8:	e7e8      	b.n	3acc <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x44>

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
		return write((uint8_t)n);
    3afa:	6803      	ldr	r3, [r0, #0]
    3afc:	b2c9      	uxtb	r1, r1
    3afe:	681b      	ldr	r3, [r3, #0]
    3b00:	4798      	blx	r3
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
    3b02:	b00b      	add	sp, #44	; 0x2c
    3b04:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3b06:	bf00      	nop

00003b08 <Print::print(long)>:

size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
    3b08:	2900      	cmp	r1, #0
		sign = '-';
		n = -n;
    3b0a:	bfba      	itte	lt
    3b0c:	4249      	neglt	r1, r1
size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
		sign = '-';
    3b0e:	232d      	movlt	r3, #45	; 0x2d
}


size_t Print::print(long n)
{
	uint8_t sign=0;
    3b10:	2300      	movge	r3, #0

	if (n < 0) {
		sign = '-';
		n = -n;
	}
	return printNumber(n, 10, sign);
    3b12:	220a      	movs	r2, #10
    3b14:	f7ff bfb8 	b.w	3a88 <Print::printNumber(unsigned long, unsigned char, unsigned char)>

00003b18 <Print::printFloat(double, unsigned char)>:
}

#endif

size_t Print::printFloat(double number, uint8_t digits) 
{
    3b18:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    3b1c:	ec57 6b10 	vmov	r6, r7, d0
    3b20:	b085      	sub	sp, #20
    3b22:	4605      	mov	r5, r0
    3b24:	460c      	mov	r4, r1
	uint8_t sign=0;
	size_t count=0;

	if (isnan(number)) return print("nan");
    3b26:	ee10 2a10 	vmov	r2, s0
    3b2a:	463b      	mov	r3, r7
    3b2c:	ee10 0a10 	vmov	r0, s0
    3b30:	4639      	mov	r1, r7
    3b32:	f002 f911 	bl	5d58 <__aeabi_dcmpun>
    3b36:	2800      	cmp	r0, #0
    3b38:	f040 80b2 	bne.w	3ca0 <Print::printFloat(double, unsigned char)+0x188>
    	if (isinf(number)) return print("inf");
    3b3c:	f027 4900 	bic.w	r9, r7, #2147483648	; 0x80000000
    3b40:	4630      	mov	r0, r6
    3b42:	4649      	mov	r1, r9
    3b44:	f04f 32ff 	mov.w	r2, #4294967295
    3b48:	4b59      	ldr	r3, [pc, #356]	; (3cb0 <Print::printFloat(double, unsigned char)+0x198>)
    3b4a:	f002 f905 	bl	5d58 <__aeabi_dcmpun>
    3b4e:	b990      	cbnz	r0, 3b76 <Print::printFloat(double, unsigned char)+0x5e>
    3b50:	4630      	mov	r0, r6
    3b52:	4649      	mov	r1, r9
    3b54:	f04f 32ff 	mov.w	r2, #4294967295
    3b58:	4b55      	ldr	r3, [pc, #340]	; (3cb0 <Print::printFloat(double, unsigned char)+0x198>)
    3b5a:	f002 f8df 	bl	5d1c <__aeabi_dcmple>
    3b5e:	b950      	cbnz	r0, 3b76 <Print::printFloat(double, unsigned char)+0x5e>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    3b60:	682b      	ldr	r3, [r5, #0]
    3b62:	4954      	ldr	r1, [pc, #336]	; (3cb4 <Print::printFloat(double, unsigned char)+0x19c>)
    3b64:	685b      	ldr	r3, [r3, #4]
    3b66:	4628      	mov	r0, r5
    3b68:	2203      	movs	r2, #3
    3b6a:	4798      	blx	r3
    3b6c:	4680      	mov	r8, r0
			remainder -= n; 
		}
		count += write(buf, count);
	}
	return count;
}
    3b6e:	4640      	mov	r0, r8
    3b70:	b005      	add	sp, #20
    3b72:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	uint8_t sign=0;
	size_t count=0;

	if (isnan(number)) return print("nan");
    	if (isinf(number)) return print("inf");
    	if (number > 4294967040.0f) return print("ovf");  // constant determined empirically
    3b76:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
    3b7a:	4b4f      	ldr	r3, [pc, #316]	; (3cb8 <Print::printFloat(double, unsigned char)+0x1a0>)
    3b7c:	4630      	mov	r0, r6
    3b7e:	4639      	mov	r1, r7
    3b80:	f002 f8e0 	bl	5d44 <__aeabi_dcmpgt>
    3b84:	2800      	cmp	r0, #0
    3b86:	d172      	bne.n	3c6e <Print::printFloat(double, unsigned char)+0x156>
    	if (number <-4294967040.0f) return print("ovf");  // constant determined empirically
    3b88:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
    3b8c:	4b4b      	ldr	r3, [pc, #300]	; (3cbc <Print::printFloat(double, unsigned char)+0x1a4>)
    3b8e:	4630      	mov	r0, r6
    3b90:	4639      	mov	r1, r7
    3b92:	f002 f8b9 	bl	5d08 <__aeabi_dcmplt>
    3b96:	2800      	cmp	r0, #0
    3b98:	d169      	bne.n	3c6e <Print::printFloat(double, unsigned char)+0x156>
	
	// Handle negative numbers
	if (number < 0.0) {
    3b9a:	2200      	movs	r2, #0
    3b9c:	2300      	movs	r3, #0
    3b9e:	4630      	mov	r0, r6
    3ba0:	4639      	mov	r1, r7
    3ba2:	f002 f8b1 	bl	5d08 <__aeabi_dcmplt>
    3ba6:	2800      	cmp	r0, #0
    3ba8:	d164      	bne.n	3c74 <Print::printFloat(double, unsigned char)+0x15c>

#endif

size_t Print::printFloat(double number, uint8_t digits) 
{
	uint8_t sign=0;
    3baa:	4681      	mov	r9, r0
		number = -number;
	}

	// Round correctly so that print(1.999, 2) prints as "2.00"
	double rounding = 0.5;
	for (uint8_t i=0; i<digits; ++i) {
    3bac:	2c00      	cmp	r4, #0
    3bae:	d067      	beq.n	3c80 <Print::printFloat(double, unsigned char)+0x168>
    3bb0:	4943      	ldr	r1, [pc, #268]	; (3cc0 <Print::printFloat(double, unsigned char)+0x1a8>)
    3bb2:	2000      	movs	r0, #0
    3bb4:	f04f 0800 	mov.w	r8, #0
		rounding *= 0.1;
    3bb8:	a33b      	add	r3, pc, #236	; (adr r3, 3ca8 <Print::printFloat(double, unsigned char)+0x190>)
    3bba:	e9d3 2300 	ldrd	r2, r3, [r3]
    3bbe:	f108 0801 	add.w	r8, r8, #1
    3bc2:	f001 fe2f 	bl	5824 <__aeabi_dmul>
		number = -number;
	}

	// Round correctly so that print(1.999, 2) prints as "2.00"
	double rounding = 0.5;
	for (uint8_t i=0; i<digits; ++i) {
    3bc6:	fa5f f388 	uxtb.w	r3, r8
    3bca:	429c      	cmp	r4, r3
    3bcc:	d8f4      	bhi.n	3bb8 <Print::printFloat(double, unsigned char)+0xa0>
		rounding *= 0.1;
	}
	number += rounding;
    3bce:	4602      	mov	r2, r0
    3bd0:	460b      	mov	r3, r1
    3bd2:	4630      	mov	r0, r6
    3bd4:	4639      	mov	r1, r7
    3bd6:	f001 fc73 	bl	54c0 <__adddf3>
    3bda:	460f      	mov	r7, r1
    3bdc:	4606      	mov	r6, r0

	// Extract the integer part of the number and print it
	unsigned long int_part = (unsigned long)number;
    3bde:	f002 f8f9 	bl	5dd4 <__aeabi_d2uiz>
    3be2:	4680      	mov	r8, r0
	double remainder = number - (double)int_part;
    3be4:	f001 fda8 	bl	5738 <__aeabi_ui2d>
    3be8:	4602      	mov	r2, r0
    3bea:	460b      	mov	r3, r1
    3bec:	4630      	mov	r0, r6
    3bee:	4639      	mov	r1, r7
    3bf0:	f001 fc64 	bl	54bc <__aeabi_dsub>
	count += printNumber(int_part, 10, sign);
    3bf4:	464b      	mov	r3, r9
	}
	number += rounding;

	// Extract the integer part of the number and print it
	unsigned long int_part = (unsigned long)number;
	double remainder = number - (double)int_part;
    3bf6:	4606      	mov	r6, r0
    3bf8:	460f      	mov	r7, r1
	count += printNumber(int_part, 10, sign);
    3bfa:	220a      	movs	r2, #10
    3bfc:	4641      	mov	r1, r8
    3bfe:	4628      	mov	r0, r5
    3c00:	f7ff ff42 	bl	3a88 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    3c04:	2c0f      	cmp	r4, #15
    3c06:	bf28      	it	cs
    3c08:	240f      	movcs	r4, #15
    3c0a:	f104 0901 	add.w	r9, r4, #1

	// Print the decimal point, but only if there are digits beyond
	if (digits > 0) {
		uint8_t n, buf[16], count=1;
		buf[0] = '.';
    3c0e:	232e      	movs	r3, #46	; 0x2e
	number += rounding;

	// Extract the integer part of the number and print it
	unsigned long int_part = (unsigned long)number;
	double remainder = number - (double)int_part;
	count += printNumber(int_part, 10, sign);
    3c10:	4680      	mov	r8, r0
    3c12:	fa5f f989 	uxtb.w	r9, r9

	// Print the decimal point, but only if there are digits beyond
	if (digits > 0) {
		uint8_t n, buf[16], count=1;
		buf[0] = '.';
    3c16:	f88d 3000 	strb.w	r3, [sp]
    3c1a:	2401      	movs	r4, #1

		// Extract digits from the remainder one at a time
		if (digits > sizeof(buf) - 1) digits = sizeof(buf) - 1;

		while (digits-- > 0) {
			remainder *= 10.0;
    3c1c:	2200      	movs	r2, #0
    3c1e:	4b29      	ldr	r3, [pc, #164]	; (3cc4 <Print::printFloat(double, unsigned char)+0x1ac>)
    3c20:	4630      	mov	r0, r6
    3c22:	4639      	mov	r1, r7
    3c24:	f001 fdfe 	bl	5824 <__aeabi_dmul>
    3c28:	460f      	mov	r7, r1
    3c2a:	4606      	mov	r6, r0
			n = (uint8_t)(remainder);
    3c2c:	f002 f8d2 	bl	5dd4 <__aeabi_d2uiz>
			buf[count++] = '0' + n;
    3c30:	ab04      	add	r3, sp, #16
    3c32:	4423      	add	r3, r4
		// Extract digits from the remainder one at a time
		if (digits > sizeof(buf) - 1) digits = sizeof(buf) - 1;

		while (digits-- > 0) {
			remainder *= 10.0;
			n = (uint8_t)(remainder);
    3c34:	b2c0      	uxtb	r0, r0
			buf[count++] = '0' + n;
    3c36:	f100 0230 	add.w	r2, r0, #48	; 0x30
    3c3a:	f803 2c10 	strb.w	r2, [r3, #-16]
			remainder -= n; 
    3c3e:	f001 fd8b 	bl	5758 <__aeabi_i2d>
    3c42:	4602      	mov	r2, r0
    3c44:	460b      	mov	r3, r1
    3c46:	4630      	mov	r0, r6
    3c48:	4639      	mov	r1, r7
    3c4a:	f001 fc37 	bl	54bc <__aeabi_dsub>
		if (digits > sizeof(buf) - 1) digits = sizeof(buf) - 1;

		while (digits-- > 0) {
			remainder *= 10.0;
			n = (uint8_t)(remainder);
			buf[count++] = '0' + n;
    3c4e:	3401      	adds	r4, #1
    3c50:	b2e4      	uxtb	r4, r4
		buf[0] = '.';

		// Extract digits from the remainder one at a time
		if (digits > sizeof(buf) - 1) digits = sizeof(buf) - 1;

		while (digits-- > 0) {
    3c52:	454c      	cmp	r4, r9
			remainder *= 10.0;
			n = (uint8_t)(remainder);
			buf[count++] = '0' + n;
			remainder -= n; 
    3c54:	4606      	mov	r6, r0
    3c56:	460f      	mov	r7, r1
		buf[0] = '.';

		// Extract digits from the remainder one at a time
		if (digits > sizeof(buf) - 1) digits = sizeof(buf) - 1;

		while (digits-- > 0) {
    3c58:	d1e0      	bne.n	3c1c <Print::printFloat(double, unsigned char)+0x104>
			remainder *= 10.0;
			n = (uint8_t)(remainder);
			buf[count++] = '0' + n;
			remainder -= n; 
		}
		count += write(buf, count);
    3c5a:	682b      	ldr	r3, [r5, #0]
    3c5c:	4622      	mov	r2, r4
    3c5e:	685b      	ldr	r3, [r3, #4]
    3c60:	4628      	mov	r0, r5
    3c62:	4669      	mov	r1, sp
    3c64:	4798      	blx	r3
	}
	return count;
}
    3c66:	4640      	mov	r0, r8
    3c68:	b005      	add	sp, #20
    3c6a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    3c6e:	682b      	ldr	r3, [r5, #0]
    3c70:	4915      	ldr	r1, [pc, #84]	; (3cc8 <Print::printFloat(double, unsigned char)+0x1b0>)
    3c72:	e777      	b.n	3b64 <Print::printFloat(double, unsigned char)+0x4c>
    	if (number <-4294967040.0f) return print("ovf");  // constant determined empirically
	
	// Handle negative numbers
	if (number < 0.0) {
		sign = 1;
		number = -number;
    3c74:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
    3c78:	461f      	mov	r7, r3
    	if (number > 4294967040.0f) return print("ovf");  // constant determined empirically
    	if (number <-4294967040.0f) return print("ovf");  // constant determined empirically
	
	// Handle negative numbers
	if (number < 0.0) {
		sign = 1;
    3c7a:	f04f 0901 	mov.w	r9, #1
    3c7e:	e795      	b.n	3bac <Print::printFloat(double, unsigned char)+0x94>
	number += rounding;

	// Extract the integer part of the number and print it
	unsigned long int_part = (unsigned long)number;
	double remainder = number - (double)int_part;
	count += printNumber(int_part, 10, sign);
    3c80:	2200      	movs	r2, #0
    3c82:	4b0f      	ldr	r3, [pc, #60]	; (3cc0 <Print::printFloat(double, unsigned char)+0x1a8>)
    3c84:	4630      	mov	r0, r6
    3c86:	4639      	mov	r1, r7
    3c88:	f001 fc1a 	bl	54c0 <__adddf3>
    3c8c:	f002 f8a2 	bl	5dd4 <__aeabi_d2uiz>
    3c90:	464b      	mov	r3, r9
    3c92:	4601      	mov	r1, r0
    3c94:	220a      	movs	r2, #10
    3c96:	4628      	mov	r0, r5
    3c98:	f7ff fef6 	bl	3a88 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    3c9c:	4680      	mov	r8, r0
    3c9e:	e766      	b.n	3b6e <Print::printFloat(double, unsigned char)+0x56>
    3ca0:	682b      	ldr	r3, [r5, #0]
    3ca2:	490a      	ldr	r1, [pc, #40]	; (3ccc <Print::printFloat(double, unsigned char)+0x1b4>)
    3ca4:	e75e      	b.n	3b64 <Print::printFloat(double, unsigned char)+0x4c>
    3ca6:	bf00      	nop
    3ca8:	a0000000 	.word	0xa0000000
    3cac:	3fb99999 	.word	0x3fb99999
    3cb0:	7fefffff 	.word	0x7fefffff
    3cb4:	00006b74 	.word	0x00006b74
    3cb8:	41efffff 	.word	0x41efffff
    3cbc:	c1efffff 	.word	0xc1efffff
    3cc0:	3fe00000 	.word	0x3fe00000
    3cc4:	40240000 	.word	0x40240000
    3cc8:	00006b70 	.word	0x00006b70
    3ccc:	00006b6c 	.word	0x00006b6c

00003cd0 <usb_serial_class::clear()>:
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    3cd0:	f7ff bc12 	b.w	34f8 <usb_serial_flush_input>

00003cd4 <usb_serial_class::peek()>:
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    3cd4:	f7ff bbea 	b.w	34ac <usb_serial_peekchar>

00003cd8 <usb_serial_class::read()>:
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    3cd8:	f7ff bbc4 	b.w	3464 <usb_serial_getchar>

00003cdc <usb_serial_class::available()>:
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    3cdc:	f7ff bbfe 	b.w	34dc <usb_serial_available>

00003ce0 <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    3ce0:	f7ff bcda 	b.w	3698 <usb_serial_flush_output>

00003ce4 <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    3ce4:	f7ff bcb4 	b.w	3650 <usb_serial_write_buffer_free>

00003ce8 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    3ce8:	4608      	mov	r0, r1
    3cea:	4611      	mov	r1, r2
    3cec:	f7ff bc20 	b.w	3530 <usb_serial_write>

00003cf0 <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    3cf0:	4608      	mov	r0, r1
    3cf2:	f7ff bca1 	b.w	3638 <usb_serial_putchar>
    3cf6:	bf00      	nop

00003cf8 <serialEvent()>:
#endif

#endif // F_CPU

void serialEvent() __attribute__((weak));
void serialEvent() {}
    3cf8:	4770      	bx	lr
    3cfa:	bf00      	nop

00003cfc <yield>:
#include <Arduino.h>
#include "EventResponder.h"

void yield(void) __attribute__ ((weak));
void yield(void)
{
    3cfc:	b538      	push	{r3, r4, r5, lr}
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
    3cfe:	4c2c      	ldr	r4, [pc, #176]	; (3db0 <yield+0xb4>)
    3d00:	7823      	ldrb	r3, [r4, #0]
    3d02:	b103      	cbz	r3, 3d06 <yield+0xa>
    3d04:	bd38      	pop	{r3, r4, r5, pc}
	running = 1;
    3d06:	2301      	movs	r3, #1
    3d08:	7023      	strb	r3, [r4, #0]
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    3d0a:	f7ff fbe7 	bl	34dc <usb_serial_available>
	if (Serial.available()) serialEvent();
    3d0e:	2800      	cmp	r0, #0
    3d10:	d142      	bne.n	3d98 <yield+0x9c>
	virtual void transmitterEnable(uint8_t pin) { serial_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial_set_cts(pin); }
	virtual int available(void)     { return serial_available(); }
    3d12:	f000 f87b 	bl	3e0c <serial_available>
	if (Serial1.available()) serialEvent1();
    3d16:	2800      	cmp	r0, #0
    3d18:	d13b      	bne.n	3d92 <yield+0x96>
	virtual void transmitterEnable(uint8_t pin) { serial2_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial2_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial2_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial2_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial2_set_cts(pin); }
	virtual int available(void)     { return serial2_available(); }
    3d1a:	f000 f90d 	bl	3f38 <serial2_available>
	if (Serial2.available()) serialEvent2();
    3d1e:	2800      	cmp	r0, #0
    3d20:	d134      	bne.n	3d8c <yield+0x90>
	virtual void transmitterEnable(uint8_t pin) { serial3_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial3_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial3_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial3_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial3_set_cts(pin); }
	virtual int available(void)     { return serial3_available(); }
    3d22:	f000 f99f 	bl	4064 <serial3_available>
	if (Serial3.available()) serialEvent3();
    3d26:	bb70      	cbnz	r0, 3d86 <yield+0x8a>
	virtual void transmitterEnable(uint8_t pin) { serial4_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial4_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial4_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial4_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial4_set_cts(pin); }
	virtual int available(void)     { return serial4_available(); }
    3d28:	f000 fa18 	bl	415c <serial4_available>
#ifdef HAS_KINETISK_UART3
	if (Serial4.available()) serialEvent4();
    3d2c:	bb40      	cbnz	r0, 3d80 <yield+0x84>
	virtual void transmitterEnable(uint8_t pin) { serial5_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial5_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial5_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial5_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial5_set_cts(pin); }
	virtual int available(void)     { return serial5_available(); }
    3d2e:	f000 fa91 	bl	4254 <serial5_available>
#endif
#ifdef HAS_KINETISK_UART4
	if (Serial5.available()) serialEvent5();
    3d32:	bb10      	cbnz	r0, 3d7a <yield+0x7e>
	virtual void transmitterEnable(uint8_t pin) { serial6_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial6_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial6_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial6_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial6_set_cts(pin); }
	virtual int available(void)     { return serial6_available(); }
    3d34:	f000 fb0a 	bl	434c <serial6_available>
#endif
#if defined(HAS_KINETISK_UART5) || defined (HAS_KINETISK_LPUART0)
	if (Serial6.available()) serialEvent6();
    3d38:	b9e0      	cbnz	r0, 3d74 <yield+0x78>
#endif
	running = 0;
    3d3a:	2300      	movs	r3, #0
    3d3c:	7023      	strb	r3, [r4, #0]

	static void runFromYield() {
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    3d3e:	f3ef 8305 	mrs	r3, IPSR
		if (ipsr != 0) return;
    3d42:	2b00      	cmp	r3, #0
    3d44:	d1de      	bne.n	3d04 <yield+0x8>
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    3d46:	f3ef 8110 	mrs	r1, PRIMASK
		__disable_irq();
    3d4a:	b672      	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    3d4c:	4b19      	ldr	r3, [pc, #100]	; (3db4 <yield+0xb8>)
    3d4e:	6818      	ldr	r0, [r3, #0]
		if (first == nullptr) {
    3d50:	b328      	cbz	r0, 3d9e <yield+0xa2>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    3d52:	4c19      	ldr	r4, [pc, #100]	; (3db8 <yield+0xbc>)
    3d54:	7822      	ldrb	r2, [r4, #0]
    3d56:	bb12      	cbnz	r2, 3d9e <yield+0xa2>
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
		firstYield = first->_next;
    3d58:	6945      	ldr	r5, [r0, #20]
    3d5a:	601d      	str	r5, [r3, #0]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    3d5c:	2301      	movs	r3, #1
    3d5e:	7023      	strb	r3, [r4, #0]
		firstYield = first->_next;
		if (firstYield) {
    3d60:	b30d      	cbz	r5, 3da6 <yield+0xaa>
			firstYield->_prev = nullptr;
    3d62:	61aa      	str	r2, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    3d64:	b901      	cbnz	r1, 3d68 <yield+0x6c>
    3d66:	b662      	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    3d68:	2500      	movs	r5, #0
    3d6a:	7745      	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    3d6c:	6883      	ldr	r3, [r0, #8]
    3d6e:	4798      	blx	r3
		runningFromYield = false;
    3d70:	7025      	strb	r5, [r4, #0]
    3d72:	e7c7      	b.n	3d04 <yield+0x8>
#endif
#ifdef HAS_KINETISK_UART4
	if (Serial5.available()) serialEvent5();
#endif
#if defined(HAS_KINETISK_UART5) || defined (HAS_KINETISK_LPUART0)
	if (Serial6.available()) serialEvent6();
    3d74:	f000 fbb8 	bl	44e8 <serialEvent6()>
    3d78:	e7df      	b.n	3d3a <yield+0x3e>
	if (Serial3.available()) serialEvent3();
#ifdef HAS_KINETISK_UART3
	if (Serial4.available()) serialEvent4();
#endif
#ifdef HAS_KINETISK_UART4
	if (Serial5.available()) serialEvent5();
    3d7a:	f000 fbb3 	bl	44e4 <serialEvent5()>
    3d7e:	e7d9      	b.n	3d34 <yield+0x38>
	if (Serial.available()) serialEvent();
	if (Serial1.available()) serialEvent1();
	if (Serial2.available()) serialEvent2();
	if (Serial3.available()) serialEvent3();
#ifdef HAS_KINETISK_UART3
	if (Serial4.available()) serialEvent4();
    3d80:	f000 fbae 	bl	44e0 <serialEvent4()>
    3d84:	e7d3      	b.n	3d2e <yield+0x32>
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
	if (Serial.available()) serialEvent();
	if (Serial1.available()) serialEvent1();
	if (Serial2.available()) serialEvent2();
	if (Serial3.available()) serialEvent3();
    3d86:	f000 fba9 	bl	44dc <serialEvent3()>
    3d8a:	e7cd      	b.n	3d28 <yield+0x2c>

	if (running) return; // TODO: does this need to be atomic?
	running = 1;
	if (Serial.available()) serialEvent();
	if (Serial1.available()) serialEvent1();
	if (Serial2.available()) serialEvent2();
    3d8c:	f000 fba4 	bl	44d8 <serialEvent2()>
    3d90:	e7c7      	b.n	3d22 <yield+0x26>
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
	running = 1;
	if (Serial.available()) serialEvent();
	if (Serial1.available()) serialEvent1();
    3d92:	f000 fb9f 	bl	44d4 <serialEvent1()>
    3d96:	e7c0      	b.n	3d1a <yield+0x1e>
{
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
	running = 1;
	if (Serial.available()) serialEvent();
    3d98:	f7ff ffae 	bl	3cf8 <serialEvent()>
    3d9c:	e7b9      	b.n	3d12 <yield+0x16>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    3d9e:	2900      	cmp	r1, #0
    3da0:	d1b0      	bne.n	3d04 <yield+0x8>
    3da2:	b662      	cpsie	i
    3da4:	bd38      	pop	{r3, r4, r5, pc}
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    3da6:	4b05      	ldr	r3, [pc, #20]	; (3dbc <yield+0xc0>)
    3da8:	601d      	str	r5, [r3, #0]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    3daa:	2900      	cmp	r1, #0
    3dac:	d1dc      	bne.n	3d68 <yield+0x6c>
    3dae:	e7da      	b.n	3d66 <yield+0x6a>
    3db0:	1fff1734 	.word	0x1fff1734
    3db4:	1fff1728 	.word	0x1fff1728
    3db8:	1fff172c 	.word	0x1fff172c
    3dbc:	1fff1724 	.word	0x1fff1724

00003dc0 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    3dc0:	b4f0      	push	{r4, r5, r6, r7}
    3dc2:	1e4d      	subs	r5, r1, #1
    3dc4:	462e      	mov	r6, r5
	unsigned digit;
	int i=0, j;
    3dc6:	2400      	movs	r4, #0
    3dc8:	e000      	b.n	3dcc <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    3dca:	3401      	adds	r4, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    3dcc:	fbb0 f3f2 	udiv	r3, r0, r2
    3dd0:	fb02 0013 	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    3dd4:	2809      	cmp	r0, #9
    3dd6:	f100 0730 	add.w	r7, r0, #48	; 0x30
    3dda:	bf8a      	itet	hi
    3ddc:	3037      	addhi	r0, #55	; 0x37
    3dde:	b2f8      	uxtbls	r0, r7
    3de0:	b2c0      	uxtbhi	r0, r0
    3de2:	f806 0f01 	strb.w	r0, [r6, #1]!
		val /= radix;
		if (val == 0) break;
    3de6:	4618      	mov	r0, r3
    3de8:	2b00      	cmp	r3, #0
    3dea:	d1ee      	bne.n	3dca <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    3dec:	190a      	adds	r2, r1, r4
    3dee:	7053      	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    3df0:	b14c      	cbz	r4, 3e06 <ultoa+0x46>
		t = buf[j];
		buf[j] = buf[i];
    3df2:	7810      	ldrb	r0, [r2, #0]
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
		t = buf[j];
    3df4:	f815 6f01 	ldrb.w	r6, [r5, #1]!
		buf[j] = buf[i];
    3df8:	7028      	strb	r0, [r5, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    3dfa:	3301      	adds	r3, #1
    3dfc:	1ae0      	subs	r0, r4, r3
    3dfe:	4283      	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    3e00:	f802 6901 	strb.w	r6, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    3e04:	dbf5      	blt.n	3df2 <ultoa+0x32>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    3e06:	4608      	mov	r0, r1
    3e08:	bcf0      	pop	{r4, r5, r6, r7}
    3e0a:	4770      	bx	lr

00003e0c <serial_available>:

int serial_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    3e0c:	4a05      	ldr	r2, [pc, #20]	; (3e24 <serial_available+0x18>)
	tail = rx_buffer_tail;
    3e0e:	4b06      	ldr	r3, [pc, #24]	; (3e28 <serial_available+0x1c>)

int serial_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    3e10:	7810      	ldrb	r0, [r2, #0]
	tail = rx_buffer_tail;
    3e12:	781b      	ldrb	r3, [r3, #0]

int serial_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    3e14:	b2c0      	uxtb	r0, r0
	tail = rx_buffer_tail;
    3e16:	b2db      	uxtb	r3, r3
	if (head >= tail) return head - tail;
    3e18:	4298      	cmp	r0, r3
	return SERIAL1_RX_BUFFER_SIZE + head - tail;
    3e1a:	bf38      	it	cc
    3e1c:	3040      	addcc	r0, #64	; 0x40
    3e1e:	1ac0      	subs	r0, r0, r3
}
    3e20:	4770      	bx	lr
    3e22:	bf00      	nop
    3e24:	1fff173c 	.word	0x1fff173c
    3e28:	1fff173d 	.word	0x1fff173d

00003e2c <uart0_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart0_status_isr(void)
{
    3e2c:	b4f0      	push	{r4, r5, r6, r7}
	uint8_t c;
#ifdef HAS_KINETISK_UART0_FIFO
	uint32_t newhead;
	uint8_t avail;

	if (UART0_S1 & (UART_S1_RDRF | UART_S1_IDLE)) {
    3e2e:	4b38      	ldr	r3, [pc, #224]	; (3f10 <uart0_status_isr+0xe4>)
    3e30:	791a      	ldrb	r2, [r3, #4]
    3e32:	f012 0f30 	tst.w	r2, #48	; 0x30
    3e36:	d02c      	beq.n	3e92 <uart0_status_isr+0x66>
		__disable_irq();
    3e38:	b672      	cpsid	i
		avail = UART0_RCFIFO;
    3e3a:	7d99      	ldrb	r1, [r3, #22]
		if (avail == 0) {
    3e3c:	f001 02ff 	and.w	r2, r1, #255	; 0xff
    3e40:	2900      	cmp	r1, #0
    3e42:	d03d      	beq.n	3ec0 <uart0_status_isr+0x94>
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
    3e44:	b662      	cpsie	i
			head = rx_buffer_head;
    3e46:	4f33      	ldr	r7, [pc, #204]	; (3f14 <uart0_status_isr+0xe8>)
			tail = rx_buffer_tail;
    3e48:	4933      	ldr	r1, [pc, #204]	; (3f18 <uart0_status_isr+0xec>)
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
			head = rx_buffer_head;
    3e4a:	7838      	ldrb	r0, [r7, #0]
			tail = rx_buffer_tail;
    3e4c:	780d      	ldrb	r5, [r1, #0]
				}
				newhead = head + 1;
				if (newhead >= SERIAL1_RX_BUFFER_SIZE) newhead = 0;
				if (newhead != tail) {
					head = newhead;
					rx_buffer[head] = n;
    3e4e:	4e33      	ldr	r6, [pc, #204]	; (3f1c <uart0_status_isr+0xf0>)
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART0_C3 & 0x80)) {
					n = UART0_D | 0x100;
				} else {
					n = UART0_D;
    3e50:	461c      	mov	r4, r3
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
			head = rx_buffer_head;
    3e52:	b2c0      	uxtb	r0, r0
			tail = rx_buffer_tail;
    3e54:	b2ed      	uxtb	r5, r5
				if (use9Bits && (UART0_C3 & 0x80)) {
					n = UART0_D | 0x100;
				} else {
					n = UART0_D;
				}
				newhead = head + 1;
    3e56:	1c43      	adds	r3, r0, #1
				if (newhead >= SERIAL1_RX_BUFFER_SIZE) newhead = 0;
    3e58:	2b40      	cmp	r3, #64	; 0x40
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART0_C3 & 0x80)) {
					n = UART0_D | 0x100;
				} else {
					n = UART0_D;
    3e5a:	79e1      	ldrb	r1, [r4, #7]
				}
				newhead = head + 1;
				if (newhead >= SERIAL1_RX_BUFFER_SIZE) newhead = 0;
    3e5c:	bf28      	it	cs
    3e5e:	2300      	movcs	r3, #0
				if (newhead != tail) {
    3e60:	42ab      	cmp	r3, r5
					head = newhead;
					rx_buffer[head] = n;
				}
			} while (--avail > 0);
    3e62:	f102 32ff 	add.w	r2, r2, #4294967295
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART0_C3 & 0x80)) {
					n = UART0_D | 0x100;
				} else {
					n = UART0_D;
    3e66:	b2c9      	uxtb	r1, r1
				}
				newhead = head + 1;
				if (newhead >= SERIAL1_RX_BUFFER_SIZE) newhead = 0;
				if (newhead != tail) {
					head = newhead;
					rx_buffer[head] = n;
    3e68:	bf1c      	itt	ne
    3e6a:	54f1      	strbne	r1, [r6, r3]
    3e6c:	4618      	movne	r0, r3
				}
			} while (--avail > 0);
    3e6e:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
    3e72:	d1f0      	bne.n	3e56 <uart0_status_isr+0x2a>
			rx_buffer_head = head;
			if (rts_pin) {
    3e74:	4b2a      	ldr	r3, [pc, #168]	; (3f20 <uart0_status_isr+0xf4>)
    3e76:	681b      	ldr	r3, [r3, #0]
				if (newhead != tail) {
					head = newhead;
					rx_buffer[head] = n;
				}
			} while (--avail > 0);
			rx_buffer_head = head;
    3e78:	b2c2      	uxtb	r2, r0
    3e7a:	703a      	strb	r2, [r7, #0]
			if (rts_pin) {
    3e7c:	b14b      	cbz	r3, 3e92 <uart0_status_isr+0x66>
				int avail;
				if (head >= tail) avail = head - tail;
    3e7e:	42a8      	cmp	r0, r5
				else avail = SERIAL1_RX_BUFFER_SIZE + head - tail;
    3e80:	bf36      	itet	cc
    3e82:	f1c5 0540 	rsbcc	r5, r5, #64	; 0x40
				}
			} while (--avail > 0);
			rx_buffer_head = head;
			if (rts_pin) {
				int avail;
				if (head >= tail) avail = head - tail;
    3e86:	1b40      	subcs	r0, r0, r5
				else avail = SERIAL1_RX_BUFFER_SIZE + head - tail;
    3e88:	1940      	addcc	r0, r0, r5
				if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
    3e8a:	2827      	cmp	r0, #39	; 0x27
    3e8c:	bfc4      	itt	gt
    3e8e:	2201      	movgt	r2, #1
    3e90:	701a      	strbgt	r2, [r3, #0]
			}
		}
	}
	c = UART0_C2;
    3e92:	491f      	ldr	r1, [pc, #124]	; (3f10 <uart0_status_isr+0xe4>)
    3e94:	78ca      	ldrb	r2, [r1, #3]
    3e96:	b2d2      	uxtb	r2, r2
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
    3e98:	0615      	lsls	r5, r2, #24
    3e9a:	d416      	bmi.n	3eca <uart0_status_isr+0x9e>
			UART0_D = n;
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART0_S1 & UART_S1_TC)) {
    3e9c:	0652      	lsls	r2, r2, #25
    3e9e:	d50d      	bpl.n	3ebc <uart0_status_isr+0x90>
    3ea0:	4b1b      	ldr	r3, [pc, #108]	; (3f10 <uart0_status_isr+0xe4>)
    3ea2:	791b      	ldrb	r3, [r3, #4]
    3ea4:	065b      	lsls	r3, r3, #25
    3ea6:	d509      	bpl.n	3ebc <uart0_status_isr+0x90>
		transmitting = 0;
		if (transmit_pin) transmit_deassert();
    3ea8:	4b1e      	ldr	r3, [pc, #120]	; (3f24 <uart0_status_isr+0xf8>)
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART0_S1 & UART_S1_TC)) {
		transmitting = 0;
    3eaa:	491f      	ldr	r1, [pc, #124]	; (3f28 <uart0_status_isr+0xfc>)
		if (transmit_pin) transmit_deassert();
    3eac:	681b      	ldr	r3, [r3, #0]
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART0_S1 & UART_S1_TC)) {
		transmitting = 0;
    3eae:	2200      	movs	r2, #0
    3eb0:	700a      	strb	r2, [r1, #0]
		if (transmit_pin) transmit_deassert();
    3eb2:	b103      	cbz	r3, 3eb6 <uart0_status_isr+0x8a>
    3eb4:	701a      	strb	r2, [r3, #0]
		UART0_C2 = C2_TX_INACTIVE;
    3eb6:	4b16      	ldr	r3, [pc, #88]	; (3f10 <uart0_status_isr+0xe4>)
    3eb8:	223c      	movs	r2, #60	; 0x3c
    3eba:	70da      	strb	r2, [r3, #3]
	}
}
    3ebc:	bcf0      	pop	{r4, r5, r6, r7}
    3ebe:	4770      	bx	lr
			// the chance, interrupts are disabled so a higher
			// priority interrupt (hopefully) doesn't delay.
			// TODO: change this to disabling the IDLE interrupt
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
    3ec0:	2240      	movs	r2, #64	; 0x40
			// to read the data register.  But reading with no
			// data causes a FIFO underrun, which causes the
			// FIFO to return corrupted data.  If anyone from
			// Freescale reads this, what a poor design!  There
			// write should be a write-1-to-clear for IDLE.
			c = UART0_D;
    3ec2:	79d9      	ldrb	r1, [r3, #7]
			// the chance, interrupts are disabled so a higher
			// priority interrupt (hopefully) doesn't delay.
			// TODO: change this to disabling the IDLE interrupt
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
    3ec4:	745a      	strb	r2, [r3, #17]
			__enable_irq();
    3ec6:	b662      	cpsie	i
    3ec8:	e7e3      	b.n	3e92 <uart0_status_isr+0x66>
				if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
			}
		}
	}
	c = UART0_C2;
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
    3eca:	790b      	ldrb	r3, [r1, #4]
    3ecc:	061c      	lsls	r4, r3, #24
    3ece:	d5e5      	bpl.n	3e9c <uart0_status_isr+0x70>
		head = tx_buffer_head;
    3ed0:	4b16      	ldr	r3, [pc, #88]	; (3f2c <uart0_status_isr+0x100>)
		tail = tx_buffer_tail;
    3ed2:	4e17      	ldr	r6, [pc, #92]	; (3f30 <uart0_status_isr+0x104>)
			}
		}
	}
	c = UART0_C2;
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    3ed4:	781c      	ldrb	r4, [r3, #0]
		tail = tx_buffer_tail;
    3ed6:	7833      	ldrb	r3, [r6, #0]
			}
		}
	}
	c = UART0_C2;
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    3ed8:	b2e4      	uxtb	r4, r4
		tail = tx_buffer_tail;
    3eda:	b2db      	uxtb	r3, r3
		do {
			if (tail == head) break;
    3edc:	429c      	cmp	r4, r3
    3ede:	d00e      	beq.n	3efe <uart0_status_isr+0xd2>
    3ee0:	4d14      	ldr	r5, [pc, #80]	; (3f34 <uart0_status_isr+0x108>)
    3ee2:	e001      	b.n	3ee8 <uart0_status_isr+0xbc>
    3ee4:	42a3      	cmp	r3, r4
    3ee6:	d00a      	beq.n	3efe <uart0_status_isr+0xd2>
			if (++tail >= SERIAL1_TX_BUFFER_SIZE) tail = 0;
    3ee8:	3301      	adds	r3, #1
    3eea:	2b40      	cmp	r3, #64	; 0x40
    3eec:	bf28      	it	cs
    3eee:	2300      	movcs	r3, #0
			avail = UART0_S1;
    3ef0:	7908      	ldrb	r0, [r1, #4]
			n = tx_buffer[tail];
    3ef2:	5ce8      	ldrb	r0, [r5, r3]
    3ef4:	b2c0      	uxtb	r0, r0
			if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART0_D = n;
    3ef6:	71c8      	strb	r0, [r1, #7]
		} while (UART0_TCFIFO < 8);
    3ef8:	7d08      	ldrb	r0, [r1, #20]
    3efa:	2807      	cmp	r0, #7
    3efc:	d9f2      	bls.n	3ee4 <uart0_status_isr+0xb8>
		tx_buffer_tail = tail;
    3efe:	b2db      	uxtb	r3, r3
		if (UART0_S1 & UART_S1_TDRE) UART0_C2 = C2_TX_COMPLETING;
    3f00:	4903      	ldr	r1, [pc, #12]	; (3f10 <uart0_status_isr+0xe4>)
			avail = UART0_S1;
			n = tx_buffer[tail];
			if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART0_D = n;
		} while (UART0_TCFIFO < 8);
		tx_buffer_tail = tail;
    3f02:	7033      	strb	r3, [r6, #0]
		if (UART0_S1 & UART_S1_TDRE) UART0_C2 = C2_TX_COMPLETING;
    3f04:	790b      	ldrb	r3, [r1, #4]
    3f06:	0618      	lsls	r0, r3, #24
    3f08:	bf44      	itt	mi
    3f0a:	237c      	movmi	r3, #124	; 0x7c
    3f0c:	70cb      	strbmi	r3, [r1, #3]
    3f0e:	e7c5      	b.n	3e9c <uart0_status_isr+0x70>
    3f10:	4006a000 	.word	0x4006a000
    3f14:	1fff173c 	.word	0x1fff173c
    3f18:	1fff173d 	.word	0x1fff173d
    3f1c:	1fff1780 	.word	0x1fff1780
    3f20:	1fff1738 	.word	0x1fff1738
    3f24:	1fff17c4 	.word	0x1fff17c4
    3f28:	1fff17c0 	.word	0x1fff17c0
    3f2c:	1fff17c8 	.word	0x1fff17c8
    3f30:	1fff17c1 	.word	0x1fff17c1
    3f34:	1fff1740 	.word	0x1fff1740

00003f38 <serial2_available>:

int serial2_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    3f38:	4a05      	ldr	r2, [pc, #20]	; (3f50 <serial2_available+0x18>)
	tail = rx_buffer_tail;
    3f3a:	4b06      	ldr	r3, [pc, #24]	; (3f54 <serial2_available+0x1c>)

int serial2_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    3f3c:	7810      	ldrb	r0, [r2, #0]
	tail = rx_buffer_tail;
    3f3e:	781b      	ldrb	r3, [r3, #0]

int serial2_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    3f40:	b2c0      	uxtb	r0, r0
	tail = rx_buffer_tail;
    3f42:	b2db      	uxtb	r3, r3
	if (head >= tail) return head - tail;
    3f44:	4298      	cmp	r0, r3
	return SERIAL2_RX_BUFFER_SIZE + head - tail;
    3f46:	bf38      	it	cc
    3f48:	3040      	addcc	r0, #64	; 0x40
    3f4a:	1ac0      	subs	r0, r0, r3
}
    3f4c:	4770      	bx	lr
    3f4e:	bf00      	nop
    3f50:	1fff183c 	.word	0x1fff183c
    3f54:	1fff17d1 	.word	0x1fff17d1

00003f58 <uart1_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart1_status_isr(void)
{
    3f58:	b4f0      	push	{r4, r5, r6, r7}
	uint8_t c;
#ifdef HAS_KINETISK_UART1_FIFO
	uint32_t newhead;
	uint8_t avail;

	if (UART1_S1 & (UART_S1_RDRF | UART_S1_IDLE)) {
    3f5a:	4b38      	ldr	r3, [pc, #224]	; (403c <uart1_status_isr+0xe4>)
    3f5c:	791a      	ldrb	r2, [r3, #4]
    3f5e:	f012 0f30 	tst.w	r2, #48	; 0x30
    3f62:	d02c      	beq.n	3fbe <uart1_status_isr+0x66>
		__disable_irq();
    3f64:	b672      	cpsid	i
		avail = UART1_RCFIFO;
    3f66:	7d99      	ldrb	r1, [r3, #22]
		if (avail == 0) {
    3f68:	f001 02ff 	and.w	r2, r1, #255	; 0xff
    3f6c:	2900      	cmp	r1, #0
    3f6e:	d03d      	beq.n	3fec <uart1_status_isr+0x94>
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART1_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
    3f70:	b662      	cpsie	i
			head = rx_buffer_head;
    3f72:	4f33      	ldr	r7, [pc, #204]	; (4040 <uart1_status_isr+0xe8>)
			tail = rx_buffer_tail;
    3f74:	4933      	ldr	r1, [pc, #204]	; (4044 <uart1_status_isr+0xec>)
			// which transmit interrupts are enabled.
			UART1_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
			head = rx_buffer_head;
    3f76:	7838      	ldrb	r0, [r7, #0]
			tail = rx_buffer_tail;
    3f78:	780d      	ldrb	r5, [r1, #0]
				}
				newhead = head + 1;
				if (newhead >= SERIAL2_RX_BUFFER_SIZE) newhead = 0;
				if (newhead != tail) {
					head = newhead;
					rx_buffer[head] = n;
    3f7a:	4e33      	ldr	r6, [pc, #204]	; (4048 <uart1_status_isr+0xf0>)
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART1_C3 & 0x80)) {
					n = UART1_D | 0x100;
				} else {
					n = UART1_D;
    3f7c:	461c      	mov	r4, r3
			// which transmit interrupts are enabled.
			UART1_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
			head = rx_buffer_head;
    3f7e:	b2c0      	uxtb	r0, r0
			tail = rx_buffer_tail;
    3f80:	b2ed      	uxtb	r5, r5
				if (use9Bits && (UART1_C3 & 0x80)) {
					n = UART1_D | 0x100;
				} else {
					n = UART1_D;
				}
				newhead = head + 1;
    3f82:	1c43      	adds	r3, r0, #1
				if (newhead >= SERIAL2_RX_BUFFER_SIZE) newhead = 0;
    3f84:	2b40      	cmp	r3, #64	; 0x40
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART1_C3 & 0x80)) {
					n = UART1_D | 0x100;
				} else {
					n = UART1_D;
    3f86:	79e1      	ldrb	r1, [r4, #7]
				}
				newhead = head + 1;
				if (newhead >= SERIAL2_RX_BUFFER_SIZE) newhead = 0;
    3f88:	bf28      	it	cs
    3f8a:	2300      	movcs	r3, #0
				if (newhead != tail) {
    3f8c:	42ab      	cmp	r3, r5
					head = newhead;
					rx_buffer[head] = n;
				}
			} while (--avail > 0);
    3f8e:	f102 32ff 	add.w	r2, r2, #4294967295
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART1_C3 & 0x80)) {
					n = UART1_D | 0x100;
				} else {
					n = UART1_D;
    3f92:	b2c9      	uxtb	r1, r1
				}
				newhead = head + 1;
				if (newhead >= SERIAL2_RX_BUFFER_SIZE) newhead = 0;
				if (newhead != tail) {
					head = newhead;
					rx_buffer[head] = n;
    3f94:	bf1c      	itt	ne
    3f96:	54f1      	strbne	r1, [r6, r3]
    3f98:	4618      	movne	r0, r3
				}
			} while (--avail > 0);
    3f9a:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
    3f9e:	d1f0      	bne.n	3f82 <uart1_status_isr+0x2a>
			rx_buffer_head = head;
			if (rts_pin) {
    3fa0:	4b2a      	ldr	r3, [pc, #168]	; (404c <uart1_status_isr+0xf4>)
    3fa2:	681b      	ldr	r3, [r3, #0]
				if (newhead != tail) {
					head = newhead;
					rx_buffer[head] = n;
				}
			} while (--avail > 0);
			rx_buffer_head = head;
    3fa4:	b2c2      	uxtb	r2, r0
    3fa6:	703a      	strb	r2, [r7, #0]
			if (rts_pin) {
    3fa8:	b14b      	cbz	r3, 3fbe <uart1_status_isr+0x66>
				int avail;
				if (head >= tail) avail = head - tail;
    3faa:	42a8      	cmp	r0, r5
				else avail = SERIAL2_RX_BUFFER_SIZE + head - tail;
    3fac:	bf36      	itet	cc
    3fae:	f1c5 0540 	rsbcc	r5, r5, #64	; 0x40
				}
			} while (--avail > 0);
			rx_buffer_head = head;
			if (rts_pin) {
				int avail;
				if (head >= tail) avail = head - tail;
    3fb2:	1b40      	subcs	r0, r0, r5
				else avail = SERIAL2_RX_BUFFER_SIZE + head - tail;
    3fb4:	1940      	addcc	r0, r0, r5
				if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
    3fb6:	2827      	cmp	r0, #39	; 0x27
    3fb8:	bfc4      	itt	gt
    3fba:	2201      	movgt	r2, #1
    3fbc:	701a      	strbgt	r2, [r3, #0]
			}
		}
	}
	c = UART1_C2;
    3fbe:	491f      	ldr	r1, [pc, #124]	; (403c <uart1_status_isr+0xe4>)
    3fc0:	78ca      	ldrb	r2, [r1, #3]
    3fc2:	b2d2      	uxtb	r2, r2
	if ((c & UART_C2_TIE) && (UART1_S1 & UART_S1_TDRE)) {
    3fc4:	0615      	lsls	r5, r2, #24
    3fc6:	d416      	bmi.n	3ff6 <uart1_status_isr+0x9e>
			UART1_D = n;
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART1_S1 & UART_S1_TC)) {
    3fc8:	0652      	lsls	r2, r2, #25
    3fca:	d50d      	bpl.n	3fe8 <uart1_status_isr+0x90>
    3fcc:	4b1b      	ldr	r3, [pc, #108]	; (403c <uart1_status_isr+0xe4>)
    3fce:	791b      	ldrb	r3, [r3, #4]
    3fd0:	065b      	lsls	r3, r3, #25
    3fd2:	d509      	bpl.n	3fe8 <uart1_status_isr+0x90>
		transmitting = 0;
		if (transmit_pin) transmit_deassert();
    3fd4:	4b1e      	ldr	r3, [pc, #120]	; (4050 <uart1_status_isr+0xf8>)
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART1_S1 & UART_S1_TC)) {
		transmitting = 0;
    3fd6:	491f      	ldr	r1, [pc, #124]	; (4054 <uart1_status_isr+0xfc>)
		if (transmit_pin) transmit_deassert();
    3fd8:	681b      	ldr	r3, [r3, #0]
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART1_S1 & UART_S1_TC)) {
		transmitting = 0;
    3fda:	2200      	movs	r2, #0
    3fdc:	700a      	strb	r2, [r1, #0]
		if (transmit_pin) transmit_deassert();
    3fde:	b103      	cbz	r3, 3fe2 <uart1_status_isr+0x8a>
    3fe0:	701a      	strb	r2, [r3, #0]
		UART1_C2 = C2_TX_INACTIVE;
    3fe2:	4b16      	ldr	r3, [pc, #88]	; (403c <uart1_status_isr+0xe4>)
    3fe4:	223c      	movs	r2, #60	; 0x3c
    3fe6:	70da      	strb	r2, [r3, #3]
	}
}
    3fe8:	bcf0      	pop	{r4, r5, r6, r7}
    3fea:	4770      	bx	lr
			// the chance, interrupts are disabled so a higher
			// priority interrupt (hopefully) doesn't delay.
			// TODO: change this to disabling the IDLE interrupt
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART1_CFIFO = UART_CFIFO_RXFLUSH;
    3fec:	2240      	movs	r2, #64	; 0x40
			// to read the data register.  But reading with no
			// data causes a FIFO underrun, which causes the
			// FIFO to return corrupted data.  If anyone from
			// Freescale reads this, what a poor design!  There
			// write should be a write-1-to-clear for IDLE.
			c = UART1_D;
    3fee:	79d9      	ldrb	r1, [r3, #7]
			// the chance, interrupts are disabled so a higher
			// priority interrupt (hopefully) doesn't delay.
			// TODO: change this to disabling the IDLE interrupt
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART1_CFIFO = UART_CFIFO_RXFLUSH;
    3ff0:	745a      	strb	r2, [r3, #17]
			__enable_irq();
    3ff2:	b662      	cpsie	i
    3ff4:	e7e3      	b.n	3fbe <uart1_status_isr+0x66>
				if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
			}
		}
	}
	c = UART1_C2;
	if ((c & UART_C2_TIE) && (UART1_S1 & UART_S1_TDRE)) {
    3ff6:	790b      	ldrb	r3, [r1, #4]
    3ff8:	061c      	lsls	r4, r3, #24
    3ffa:	d5e5      	bpl.n	3fc8 <uart1_status_isr+0x70>
		head = tx_buffer_head;
    3ffc:	4b16      	ldr	r3, [pc, #88]	; (4058 <uart1_status_isr+0x100>)
		tail = tx_buffer_tail;
    3ffe:	4e17      	ldr	r6, [pc, #92]	; (405c <uart1_status_isr+0x104>)
			}
		}
	}
	c = UART1_C2;
	if ((c & UART_C2_TIE) && (UART1_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    4000:	781c      	ldrb	r4, [r3, #0]
		tail = tx_buffer_tail;
    4002:	7833      	ldrb	r3, [r6, #0]
			}
		}
	}
	c = UART1_C2;
	if ((c & UART_C2_TIE) && (UART1_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    4004:	b2e4      	uxtb	r4, r4
		tail = tx_buffer_tail;
    4006:	b2db      	uxtb	r3, r3
		do {
			if (tail == head) break;
    4008:	429c      	cmp	r4, r3
    400a:	d00e      	beq.n	402a <uart1_status_isr+0xd2>
    400c:	4d14      	ldr	r5, [pc, #80]	; (4060 <uart1_status_isr+0x108>)
    400e:	e001      	b.n	4014 <uart1_status_isr+0xbc>
    4010:	42a3      	cmp	r3, r4
    4012:	d00a      	beq.n	402a <uart1_status_isr+0xd2>
			if (++tail >= SERIAL2_TX_BUFFER_SIZE) tail = 0;
    4014:	3301      	adds	r3, #1
    4016:	2b28      	cmp	r3, #40	; 0x28
    4018:	bf28      	it	cs
    401a:	2300      	movcs	r3, #0
			avail = UART1_S1;
    401c:	7908      	ldrb	r0, [r1, #4]
			n = tx_buffer[tail];
    401e:	5ce8      	ldrb	r0, [r5, r3]
    4020:	b2c0      	uxtb	r0, r0
			if (use9Bits) UART1_C3 = (UART1_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART1_D = n;
    4022:	71c8      	strb	r0, [r1, #7]
		} while (UART1_TCFIFO < 8);
    4024:	7d08      	ldrb	r0, [r1, #20]
    4026:	2807      	cmp	r0, #7
    4028:	d9f2      	bls.n	4010 <uart1_status_isr+0xb8>
		tx_buffer_tail = tail;
    402a:	b2db      	uxtb	r3, r3
		if (UART1_S1 & UART_S1_TDRE) UART1_C2 = C2_TX_COMPLETING;
    402c:	4903      	ldr	r1, [pc, #12]	; (403c <uart1_status_isr+0xe4>)
			avail = UART1_S1;
			n = tx_buffer[tail];
			if (use9Bits) UART1_C3 = (UART1_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART1_D = n;
		} while (UART1_TCFIFO < 8);
		tx_buffer_tail = tail;
    402e:	7033      	strb	r3, [r6, #0]
		if (UART1_S1 & UART_S1_TDRE) UART1_C2 = C2_TX_COMPLETING;
    4030:	790b      	ldrb	r3, [r1, #4]
    4032:	0618      	lsls	r0, r3, #24
    4034:	bf44      	itt	mi
    4036:	237c      	movmi	r3, #124	; 0x7c
    4038:	70cb      	strbmi	r3, [r1, #3]
    403a:	e7c5      	b.n	3fc8 <uart1_status_isr+0x70>
    403c:	4006b000 	.word	0x4006b000
    4040:	1fff183c 	.word	0x1fff183c
    4044:	1fff17d1 	.word	0x1fff17d1
    4048:	1fff17fc 	.word	0x1fff17fc
    404c:	1fff17cc 	.word	0x1fff17cc
    4050:	1fff1840 	.word	0x1fff1840
    4054:	1fff17d0 	.word	0x1fff17d0
    4058:	1fff1844 	.word	0x1fff1844
    405c:	1fff183d 	.word	0x1fff183d
    4060:	1fff17d4 	.word	0x1fff17d4

00004064 <serial3_available>:

int serial3_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    4064:	4a05      	ldr	r2, [pc, #20]	; (407c <serial3_available+0x18>)
	tail = rx_buffer_tail;
    4066:	4b06      	ldr	r3, [pc, #24]	; (4080 <serial3_available+0x1c>)

int serial3_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    4068:	7810      	ldrb	r0, [r2, #0]
	tail = rx_buffer_tail;
    406a:	781b      	ldrb	r3, [r3, #0]

int serial3_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    406c:	b2c0      	uxtb	r0, r0
	tail = rx_buffer_tail;
    406e:	b2db      	uxtb	r3, r3
	if (head >= tail) return head - tail;
    4070:	4298      	cmp	r0, r3
	return SERIAL3_RX_BUFFER_SIZE + head - tail;
    4072:	bf38      	it	cc
    4074:	3040      	addcc	r0, #64	; 0x40
    4076:	1ac0      	subs	r0, r0, r3
}
    4078:	4770      	bx	lr
    407a:	bf00      	nop
    407c:	1fff184c 	.word	0x1fff184c
    4080:	1fff184d 	.word	0x1fff184d

00004084 <uart2_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart2_status_isr(void)
{
    4084:	b430      	push	{r4, r5}
	uint32_t head, tail, n;
	uint8_t c;

	if (UART2_S1 & UART_S1_RDRF) {
    4086:	4b2b      	ldr	r3, [pc, #172]	; (4134 <uart2_status_isr+0xb0>)
    4088:	791a      	ldrb	r2, [r3, #4]
    408a:	0694      	lsls	r4, r2, #26
    408c:	d51f      	bpl.n	40ce <uart2_status_isr+0x4a>
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
		}
		head = rx_buffer_head + 1;
    408e:	482a      	ldr	r0, [pc, #168]	; (4138 <uart2_status_isr+0xb4>)

	if (UART2_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
    4090:	79da      	ldrb	r2, [r3, #7]
		}
		head = rx_buffer_head + 1;
    4092:	7803      	ldrb	r3, [r0, #0]
		if (head >= SERIAL3_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    4094:	4929      	ldr	r1, [pc, #164]	; (413c <uart2_status_isr+0xb8>)
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
		}
		head = rx_buffer_head + 1;
    4096:	3301      	adds	r3, #1
    4098:	2b3f      	cmp	r3, #63	; 0x3f
		if (head >= SERIAL3_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    409a:	7809      	ldrb	r1, [r1, #0]
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
		}
		head = rx_buffer_head + 1;
    409c:	bfc8      	it	gt
    409e:	2300      	movgt	r3, #0
		if (head >= SERIAL3_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    40a0:	428b      	cmp	r3, r1

	if (UART2_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
    40a2:	b2d2      	uxtb	r2, r2
		}
		head = rx_buffer_head + 1;
		if (head >= SERIAL3_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    40a4:	d003      	beq.n	40ae <uart2_status_isr+0x2a>
			rx_buffer[head] = n;
    40a6:	4c26      	ldr	r4, [pc, #152]	; (4140 <uart2_status_isr+0xbc>)
			rx_buffer_head = head;
    40a8:	b2d9      	uxtb	r1, r3
			n = UART2_D;
		}
		head = rx_buffer_head + 1;
		if (head >= SERIAL3_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
			rx_buffer[head] = n;
    40aa:	54e2      	strb	r2, [r4, r3]
			rx_buffer_head = head;
    40ac:	7001      	strb	r1, [r0, #0]
		}
		if (rts_pin) {
    40ae:	4a25      	ldr	r2, [pc, #148]	; (4144 <uart2_status_isr+0xc0>)
    40b0:	6811      	ldr	r1, [r2, #0]
    40b2:	b161      	cbz	r1, 40ce <uart2_status_isr+0x4a>
			int avail;
			tail = tx_buffer_tail;
    40b4:	4a24      	ldr	r2, [pc, #144]	; (4148 <uart2_status_isr+0xc4>)
    40b6:	7812      	ldrb	r2, [r2, #0]
    40b8:	b2d2      	uxtb	r2, r2
			if (head >= tail) avail = head - tail;
    40ba:	4293      	cmp	r3, r2
			else avail = SERIAL3_RX_BUFFER_SIZE + head - tail;
    40bc:	bf36      	itet	cc
    40be:	f1c2 0240 	rsbcc	r2, r2, #64	; 0x40
			rx_buffer_head = head;
		}
		if (rts_pin) {
			int avail;
			tail = tx_buffer_tail;
			if (head >= tail) avail = head - tail;
    40c2:	1a9b      	subcs	r3, r3, r2
			else avail = SERIAL3_RX_BUFFER_SIZE + head - tail;
    40c4:	189b      	addcc	r3, r3, r2
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
    40c6:	2b27      	cmp	r3, #39	; 0x27
    40c8:	bfc4      	itt	gt
    40ca:	2301      	movgt	r3, #1
    40cc:	700b      	strbgt	r3, [r1, #0]
		}
	}
	c = UART2_C2;
    40ce:	4a19      	ldr	r2, [pc, #100]	; (4134 <uart2_status_isr+0xb0>)
    40d0:	78d3      	ldrb	r3, [r2, #3]
    40d2:	b2db      	uxtb	r3, r3
	if ((c & UART_C2_TIE) && (UART2_S1 & UART_S1_TDRE)) {
    40d4:	0618      	lsls	r0, r3, #24
    40d6:	d411      	bmi.n	40fc <uart2_status_isr+0x78>
			if (use9Bits) UART2_C3 = (UART2_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART2_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART2_S1 & UART_S1_TC)) {
    40d8:	065a      	lsls	r2, r3, #25
    40da:	d50d      	bpl.n	40f8 <uart2_status_isr+0x74>
    40dc:	4b15      	ldr	r3, [pc, #84]	; (4134 <uart2_status_isr+0xb0>)
    40de:	791b      	ldrb	r3, [r3, #4]
    40e0:	065b      	lsls	r3, r3, #25
    40e2:	d509      	bpl.n	40f8 <uart2_status_isr+0x74>
		transmitting = 0;
		if (transmit_pin) transmit_deassert();
    40e4:	4b19      	ldr	r3, [pc, #100]	; (414c <uart2_status_isr+0xc8>)
			UART2_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART2_S1 & UART_S1_TC)) {
		transmitting = 0;
    40e6:	491a      	ldr	r1, [pc, #104]	; (4150 <uart2_status_isr+0xcc>)
		if (transmit_pin) transmit_deassert();
    40e8:	681b      	ldr	r3, [r3, #0]
			UART2_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART2_S1 & UART_S1_TC)) {
		transmitting = 0;
    40ea:	2200      	movs	r2, #0
    40ec:	700a      	strb	r2, [r1, #0]
		if (transmit_pin) transmit_deassert();
    40ee:	b103      	cbz	r3, 40f2 <uart2_status_isr+0x6e>
    40f0:	701a      	strb	r2, [r3, #0]
		UART2_C2 = C2_TX_INACTIVE;
    40f2:	4b10      	ldr	r3, [pc, #64]	; (4134 <uart2_status_isr+0xb0>)
    40f4:	222c      	movs	r2, #44	; 0x2c
    40f6:	70da      	strb	r2, [r3, #3]
	}
}
    40f8:	bc30      	pop	{r4, r5}
    40fa:	4770      	bx	lr
			else avail = SERIAL3_RX_BUFFER_SIZE + head - tail;
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = UART2_C2;
	if ((c & UART_C2_TIE) && (UART2_S1 & UART_S1_TDRE)) {
    40fc:	7911      	ldrb	r1, [r2, #4]
    40fe:	0609      	lsls	r1, r1, #24
    4100:	d5ea      	bpl.n	40d8 <uart2_status_isr+0x54>
		head = tx_buffer_head;
    4102:	4914      	ldr	r1, [pc, #80]	; (4154 <uart2_status_isr+0xd0>)
		tail = tx_buffer_tail;
    4104:	4810      	ldr	r0, [pc, #64]	; (4148 <uart2_status_isr+0xc4>)
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = UART2_C2;
	if ((c & UART_C2_TIE) && (UART2_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    4106:	780c      	ldrb	r4, [r1, #0]
		tail = tx_buffer_tail;
    4108:	7801      	ldrb	r1, [r0, #0]
    410a:	b2c9      	uxtb	r1, r1
		if (head == tail) {
    410c:	428c      	cmp	r4, r1
    410e:	d00d      	beq.n	412c <uart2_status_isr+0xa8>
			UART2_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL3_TX_BUFFER_SIZE) tail = 0;
    4110:	1c4a      	adds	r2, r1, #1
    4112:	2a27      	cmp	r2, #39	; 0x27
    4114:	bf84      	itt	hi
    4116:	2100      	movhi	r1, #0
    4118:	460a      	movhi	r2, r1
			n = tx_buffer[tail];
    411a:	4d0f      	ldr	r5, [pc, #60]	; (4158 <uart2_status_isr+0xd4>)
			if (use9Bits) UART2_C3 = (UART2_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART2_D = n;
    411c:	4c05      	ldr	r4, [pc, #20]	; (4134 <uart2_status_isr+0xb0>)
    411e:	bf98      	it	ls
    4120:	b2d1      	uxtbls	r1, r2
		tail = tx_buffer_tail;
		if (head == tail) {
			UART2_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL3_TX_BUFFER_SIZE) tail = 0;
			n = tx_buffer[tail];
    4122:	5caa      	ldrb	r2, [r5, r2]
    4124:	b2d2      	uxtb	r2, r2
			if (use9Bits) UART2_C3 = (UART2_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART2_D = n;
    4126:	71e2      	strb	r2, [r4, #7]
			tx_buffer_tail = tail;
    4128:	7001      	strb	r1, [r0, #0]
    412a:	e7d5      	b.n	40d8 <uart2_status_isr+0x54>
	c = UART2_C2;
	if ((c & UART_C2_TIE) && (UART2_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			UART2_C2 = C2_TX_COMPLETING;
    412c:	216c      	movs	r1, #108	; 0x6c
    412e:	70d1      	strb	r1, [r2, #3]
    4130:	e7d2      	b.n	40d8 <uart2_status_isr+0x54>
    4132:	bf00      	nop
    4134:	4006c000 	.word	0x4006c000
    4138:	1fff184c 	.word	0x1fff184c
    413c:	1fff184d 	.word	0x1fff184d
    4140:	1fff1878 	.word	0x1fff1878
    4144:	1fff1848 	.word	0x1fff1848
    4148:	1fff18b9 	.word	0x1fff18b9
    414c:	1fff18bc 	.word	0x1fff18bc
    4150:	1fff18b8 	.word	0x1fff18b8
    4154:	1fff18c0 	.word	0x1fff18c0
    4158:	1fff1850 	.word	0x1fff1850

0000415c <serial4_available>:

int serial4_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    415c:	4a05      	ldr	r2, [pc, #20]	; (4174 <serial4_available+0x18>)
	tail = rx_buffer_tail;
    415e:	4b06      	ldr	r3, [pc, #24]	; (4178 <serial4_available+0x1c>)

int serial4_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    4160:	7810      	ldrb	r0, [r2, #0]
	tail = rx_buffer_tail;
    4162:	781b      	ldrb	r3, [r3, #0]

int serial4_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    4164:	b2c0      	uxtb	r0, r0
	tail = rx_buffer_tail;
    4166:	b2db      	uxtb	r3, r3
	if (head >= tail) return head - tail;
    4168:	4298      	cmp	r0, r3
	return SERIAL4_RX_BUFFER_SIZE + head - tail;
    416a:	bf38      	it	cc
    416c:	3040      	addcc	r0, #64	; 0x40
    416e:	1ac0      	subs	r0, r0, r3
}
    4170:	4770      	bx	lr
    4172:	bf00      	nop
    4174:	1fff18c8 	.word	0x1fff18c8
    4178:	1fff18c9 	.word	0x1fff18c9

0000417c <uart3_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart3_status_isr(void)
{
    417c:	b430      	push	{r4, r5}
	uint32_t head, tail, n;
	uint8_t c;

	if (UART3_S1 & UART_S1_RDRF) {
    417e:	4b2b      	ldr	r3, [pc, #172]	; (422c <uart3_status_isr+0xb0>)
    4180:	791a      	ldrb	r2, [r3, #4]
    4182:	0694      	lsls	r4, r2, #26
    4184:	d51f      	bpl.n	41c6 <uart3_status_isr+0x4a>
		if (use9Bits && (UART3_C3 & 0x80)) {
			n = UART3_D | 0x100;
		} else {
			n = UART3_D;
		}
		head = rx_buffer_head + 1;
    4186:	482a      	ldr	r0, [pc, #168]	; (4230 <uart3_status_isr+0xb4>)

	if (UART3_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART3_C3 & 0x80)) {
			n = UART3_D | 0x100;
		} else {
			n = UART3_D;
    4188:	79da      	ldrb	r2, [r3, #7]
		}
		head = rx_buffer_head + 1;
    418a:	7803      	ldrb	r3, [r0, #0]
		if (head >= SERIAL4_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    418c:	4929      	ldr	r1, [pc, #164]	; (4234 <uart3_status_isr+0xb8>)
		if (use9Bits && (UART3_C3 & 0x80)) {
			n = UART3_D | 0x100;
		} else {
			n = UART3_D;
		}
		head = rx_buffer_head + 1;
    418e:	3301      	adds	r3, #1
    4190:	2b3f      	cmp	r3, #63	; 0x3f
		if (head >= SERIAL4_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    4192:	7809      	ldrb	r1, [r1, #0]
		if (use9Bits && (UART3_C3 & 0x80)) {
			n = UART3_D | 0x100;
		} else {
			n = UART3_D;
		}
		head = rx_buffer_head + 1;
    4194:	bfc8      	it	gt
    4196:	2300      	movgt	r3, #0
		if (head >= SERIAL4_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    4198:	428b      	cmp	r3, r1

	if (UART3_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART3_C3 & 0x80)) {
			n = UART3_D | 0x100;
		} else {
			n = UART3_D;
    419a:	b2d2      	uxtb	r2, r2
		}
		head = rx_buffer_head + 1;
		if (head >= SERIAL4_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    419c:	d003      	beq.n	41a6 <uart3_status_isr+0x2a>
			rx_buffer[head] = n;
    419e:	4c26      	ldr	r4, [pc, #152]	; (4238 <uart3_status_isr+0xbc>)
			rx_buffer_head = head;
    41a0:	b2d9      	uxtb	r1, r3
			n = UART3_D;
		}
		head = rx_buffer_head + 1;
		if (head >= SERIAL4_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
			rx_buffer[head] = n;
    41a2:	54e2      	strb	r2, [r4, r3]
			rx_buffer_head = head;
    41a4:	7001      	strb	r1, [r0, #0]
		}
		if (rts_pin) {
    41a6:	4a25      	ldr	r2, [pc, #148]	; (423c <uart3_status_isr+0xc0>)
    41a8:	6811      	ldr	r1, [r2, #0]
    41aa:	b161      	cbz	r1, 41c6 <uart3_status_isr+0x4a>
			int avail;
			tail = tx_buffer_tail;
    41ac:	4a24      	ldr	r2, [pc, #144]	; (4240 <uart3_status_isr+0xc4>)
    41ae:	7812      	ldrb	r2, [r2, #0]
    41b0:	b2d2      	uxtb	r2, r2
			if (head >= tail) avail = head - tail;
    41b2:	4293      	cmp	r3, r2
			else avail = SERIAL4_RX_BUFFER_SIZE + head - tail;
    41b4:	bf36      	itet	cc
    41b6:	f1c2 0240 	rsbcc	r2, r2, #64	; 0x40
			rx_buffer_head = head;
		}
		if (rts_pin) {
			int avail;
			tail = tx_buffer_tail;
			if (head >= tail) avail = head - tail;
    41ba:	1a9b      	subcs	r3, r3, r2
			else avail = SERIAL4_RX_BUFFER_SIZE + head - tail;
    41bc:	189b      	addcc	r3, r3, r2
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
    41be:	2b27      	cmp	r3, #39	; 0x27
    41c0:	bfc4      	itt	gt
    41c2:	2301      	movgt	r3, #1
    41c4:	700b      	strbgt	r3, [r1, #0]
		}
	}
	c = UART3_C2;
    41c6:	4a19      	ldr	r2, [pc, #100]	; (422c <uart3_status_isr+0xb0>)
    41c8:	78d3      	ldrb	r3, [r2, #3]
    41ca:	b2db      	uxtb	r3, r3
	if ((c & UART_C2_TIE) && (UART3_S1 & UART_S1_TDRE)) {
    41cc:	0618      	lsls	r0, r3, #24
    41ce:	d411      	bmi.n	41f4 <uart3_status_isr+0x78>
			if (use9Bits) UART3_C3 = (UART3_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART3_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART3_S1 & UART_S1_TC)) {
    41d0:	065a      	lsls	r2, r3, #25
    41d2:	d50d      	bpl.n	41f0 <uart3_status_isr+0x74>
    41d4:	4b15      	ldr	r3, [pc, #84]	; (422c <uart3_status_isr+0xb0>)
    41d6:	791b      	ldrb	r3, [r3, #4]
    41d8:	065b      	lsls	r3, r3, #25
    41da:	d509      	bpl.n	41f0 <uart3_status_isr+0x74>
		transmitting = 0;
		if (transmit_pin) transmit_deassert();
    41dc:	4b19      	ldr	r3, [pc, #100]	; (4244 <uart3_status_isr+0xc8>)
			UART3_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART3_S1 & UART_S1_TC)) {
		transmitting = 0;
    41de:	491a      	ldr	r1, [pc, #104]	; (4248 <uart3_status_isr+0xcc>)
		if (transmit_pin) transmit_deassert();
    41e0:	681b      	ldr	r3, [r3, #0]
			UART3_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART3_S1 & UART_S1_TC)) {
		transmitting = 0;
    41e2:	2200      	movs	r2, #0
    41e4:	700a      	strb	r2, [r1, #0]
		if (transmit_pin) transmit_deassert();
    41e6:	b103      	cbz	r3, 41ea <uart3_status_isr+0x6e>
    41e8:	701a      	strb	r2, [r3, #0]
		UART3_C2 = C2_TX_INACTIVE;
    41ea:	4b10      	ldr	r3, [pc, #64]	; (422c <uart3_status_isr+0xb0>)
    41ec:	222c      	movs	r2, #44	; 0x2c
    41ee:	70da      	strb	r2, [r3, #3]
	}
}
    41f0:	bc30      	pop	{r4, r5}
    41f2:	4770      	bx	lr
			else avail = SERIAL4_RX_BUFFER_SIZE + head - tail;
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = UART3_C2;
	if ((c & UART_C2_TIE) && (UART3_S1 & UART_S1_TDRE)) {
    41f4:	7911      	ldrb	r1, [r2, #4]
    41f6:	0609      	lsls	r1, r1, #24
    41f8:	d5ea      	bpl.n	41d0 <uart3_status_isr+0x54>
		head = tx_buffer_head;
    41fa:	4914      	ldr	r1, [pc, #80]	; (424c <uart3_status_isr+0xd0>)
		tail = tx_buffer_tail;
    41fc:	4810      	ldr	r0, [pc, #64]	; (4240 <uart3_status_isr+0xc4>)
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = UART3_C2;
	if ((c & UART_C2_TIE) && (UART3_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    41fe:	780c      	ldrb	r4, [r1, #0]
		tail = tx_buffer_tail;
    4200:	7801      	ldrb	r1, [r0, #0]
    4202:	b2c9      	uxtb	r1, r1
		if (head == tail) {
    4204:	428c      	cmp	r4, r1
    4206:	d00d      	beq.n	4224 <uart3_status_isr+0xa8>
			UART3_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL4_TX_BUFFER_SIZE) tail = 0;
    4208:	1c4a      	adds	r2, r1, #1
    420a:	2a27      	cmp	r2, #39	; 0x27
    420c:	bf84      	itt	hi
    420e:	2100      	movhi	r1, #0
    4210:	460a      	movhi	r2, r1
			n = tx_buffer[tail];
    4212:	4d0f      	ldr	r5, [pc, #60]	; (4250 <uart3_status_isr+0xd4>)
			if (use9Bits) UART3_C3 = (UART3_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART3_D = n;
    4214:	4c05      	ldr	r4, [pc, #20]	; (422c <uart3_status_isr+0xb0>)
    4216:	bf98      	it	ls
    4218:	b2d1      	uxtbls	r1, r2
		tail = tx_buffer_tail;
		if (head == tail) {
			UART3_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL4_TX_BUFFER_SIZE) tail = 0;
			n = tx_buffer[tail];
    421a:	5caa      	ldrb	r2, [r5, r2]
    421c:	b2d2      	uxtb	r2, r2
			if (use9Bits) UART3_C3 = (UART3_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART3_D = n;
    421e:	71e2      	strb	r2, [r4, #7]
			tx_buffer_tail = tail;
    4220:	7001      	strb	r1, [r0, #0]
    4222:	e7d5      	b.n	41d0 <uart3_status_isr+0x54>
	c = UART3_C2;
	if ((c & UART_C2_TIE) && (UART3_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			UART3_C2 = C2_TX_COMPLETING;
    4224:	216c      	movs	r1, #108	; 0x6c
    4226:	70d1      	strb	r1, [r2, #3]
    4228:	e7d2      	b.n	41d0 <uart3_status_isr+0x54>
    422a:	bf00      	nop
    422c:	4006d000 	.word	0x4006d000
    4230:	1fff18c8 	.word	0x1fff18c8
    4234:	1fff18c9 	.word	0x1fff18c9
    4238:	1fff18f4 	.word	0x1fff18f4
    423c:	1fff18c4 	.word	0x1fff18c4
    4240:	1fff1935 	.word	0x1fff1935
    4244:	1fff1938 	.word	0x1fff1938
    4248:	1fff1934 	.word	0x1fff1934
    424c:	1fff193c 	.word	0x1fff193c
    4250:	1fff18cc 	.word	0x1fff18cc

00004254 <serial5_available>:

int serial5_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    4254:	4a05      	ldr	r2, [pc, #20]	; (426c <serial5_available+0x18>)
	tail = rx_buffer_tail;
    4256:	4b06      	ldr	r3, [pc, #24]	; (4270 <serial5_available+0x1c>)

int serial5_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    4258:	7810      	ldrb	r0, [r2, #0]
	tail = rx_buffer_tail;
    425a:	781b      	ldrb	r3, [r3, #0]

int serial5_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    425c:	b2c0      	uxtb	r0, r0
	tail = rx_buffer_tail;
    425e:	b2db      	uxtb	r3, r3
	if (head >= tail) return head - tail;
    4260:	4298      	cmp	r0, r3
	return SERIAL5_RX_BUFFER_SIZE + head - tail;
    4262:	bf38      	it	cc
    4264:	3040      	addcc	r0, #64	; 0x40
    4266:	1ac0      	subs	r0, r0, r3
}
    4268:	4770      	bx	lr
    426a:	bf00      	nop
    426c:	1fff1944 	.word	0x1fff1944
    4270:	1fff1945 	.word	0x1fff1945

00004274 <uart4_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart4_status_isr(void)
{
    4274:	b430      	push	{r4, r5}
	uint32_t head, tail, n;
	uint8_t c;

	if (UART4_S1 & UART_S1_RDRF) {
    4276:	4b2b      	ldr	r3, [pc, #172]	; (4324 <uart4_status_isr+0xb0>)
    4278:	791a      	ldrb	r2, [r3, #4]
    427a:	0694      	lsls	r4, r2, #26
    427c:	d51f      	bpl.n	42be <uart4_status_isr+0x4a>
		if (use9Bits && (UART4_C3 & 0x80)) {
			n = UART4_D | 0x100;
		} else {
			n = UART4_D;
		}
		head = rx_buffer_head + 1;
    427e:	482a      	ldr	r0, [pc, #168]	; (4328 <uart4_status_isr+0xb4>)

	if (UART4_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART4_C3 & 0x80)) {
			n = UART4_D | 0x100;
		} else {
			n = UART4_D;
    4280:	79da      	ldrb	r2, [r3, #7]
		}
		head = rx_buffer_head + 1;
    4282:	7803      	ldrb	r3, [r0, #0]
		if (head >= SERIAL5_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    4284:	4929      	ldr	r1, [pc, #164]	; (432c <uart4_status_isr+0xb8>)
		if (use9Bits && (UART4_C3 & 0x80)) {
			n = UART4_D | 0x100;
		} else {
			n = UART4_D;
		}
		head = rx_buffer_head + 1;
    4286:	3301      	adds	r3, #1
    4288:	2b3f      	cmp	r3, #63	; 0x3f
		if (head >= SERIAL5_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    428a:	7809      	ldrb	r1, [r1, #0]
		if (use9Bits && (UART4_C3 & 0x80)) {
			n = UART4_D | 0x100;
		} else {
			n = UART4_D;
		}
		head = rx_buffer_head + 1;
    428c:	bfc8      	it	gt
    428e:	2300      	movgt	r3, #0
		if (head >= SERIAL5_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    4290:	428b      	cmp	r3, r1

	if (UART4_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART4_C3 & 0x80)) {
			n = UART4_D | 0x100;
		} else {
			n = UART4_D;
    4292:	b2d2      	uxtb	r2, r2
		}
		head = rx_buffer_head + 1;
		if (head >= SERIAL5_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    4294:	d003      	beq.n	429e <uart4_status_isr+0x2a>
			rx_buffer[head] = n;
    4296:	4c26      	ldr	r4, [pc, #152]	; (4330 <uart4_status_isr+0xbc>)
			rx_buffer_head = head;
    4298:	b2d9      	uxtb	r1, r3
			n = UART4_D;
		}
		head = rx_buffer_head + 1;
		if (head >= SERIAL5_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
			rx_buffer[head] = n;
    429a:	54e2      	strb	r2, [r4, r3]
			rx_buffer_head = head;
    429c:	7001      	strb	r1, [r0, #0]
		}
		if (rts_pin) {
    429e:	4a25      	ldr	r2, [pc, #148]	; (4334 <uart4_status_isr+0xc0>)
    42a0:	6811      	ldr	r1, [r2, #0]
    42a2:	b161      	cbz	r1, 42be <uart4_status_isr+0x4a>
			int avail;
			tail = tx_buffer_tail;
    42a4:	4a24      	ldr	r2, [pc, #144]	; (4338 <uart4_status_isr+0xc4>)
    42a6:	7812      	ldrb	r2, [r2, #0]
    42a8:	b2d2      	uxtb	r2, r2
			if (head >= tail) avail = head - tail;
    42aa:	4293      	cmp	r3, r2
			else avail = SERIAL5_RX_BUFFER_SIZE + head - tail;
    42ac:	bf36      	itet	cc
    42ae:	f1c2 0240 	rsbcc	r2, r2, #64	; 0x40
			rx_buffer_head = head;
		}
		if (rts_pin) {
			int avail;
			tail = tx_buffer_tail;
			if (head >= tail) avail = head - tail;
    42b2:	1a9b      	subcs	r3, r3, r2
			else avail = SERIAL5_RX_BUFFER_SIZE + head - tail;
    42b4:	189b      	addcc	r3, r3, r2
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
    42b6:	2b27      	cmp	r3, #39	; 0x27
    42b8:	bfc4      	itt	gt
    42ba:	2301      	movgt	r3, #1
    42bc:	700b      	strbgt	r3, [r1, #0]
		}
	}
	c = UART4_C2;
    42be:	4a19      	ldr	r2, [pc, #100]	; (4324 <uart4_status_isr+0xb0>)
    42c0:	78d3      	ldrb	r3, [r2, #3]
    42c2:	b2db      	uxtb	r3, r3
	if ((c & UART_C2_TIE) && (UART4_S1 & UART_S1_TDRE)) {
    42c4:	0618      	lsls	r0, r3, #24
    42c6:	d411      	bmi.n	42ec <uart4_status_isr+0x78>
			if (use9Bits) UART4_C3 = (UART4_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART4_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART4_S1 & UART_S1_TC)) {
    42c8:	065a      	lsls	r2, r3, #25
    42ca:	d50d      	bpl.n	42e8 <uart4_status_isr+0x74>
    42cc:	4b15      	ldr	r3, [pc, #84]	; (4324 <uart4_status_isr+0xb0>)
    42ce:	791b      	ldrb	r3, [r3, #4]
    42d0:	065b      	lsls	r3, r3, #25
    42d2:	d509      	bpl.n	42e8 <uart4_status_isr+0x74>
		transmitting = 0;
		if (transmit_pin) transmit_deassert();
    42d4:	4b19      	ldr	r3, [pc, #100]	; (433c <uart4_status_isr+0xc8>)
			UART4_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART4_S1 & UART_S1_TC)) {
		transmitting = 0;
    42d6:	491a      	ldr	r1, [pc, #104]	; (4340 <uart4_status_isr+0xcc>)
		if (transmit_pin) transmit_deassert();
    42d8:	681b      	ldr	r3, [r3, #0]
			UART4_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART4_S1 & UART_S1_TC)) {
		transmitting = 0;
    42da:	2200      	movs	r2, #0
    42dc:	700a      	strb	r2, [r1, #0]
		if (transmit_pin) transmit_deassert();
    42de:	b103      	cbz	r3, 42e2 <uart4_status_isr+0x6e>
    42e0:	701a      	strb	r2, [r3, #0]
		UART4_C2 = C2_TX_INACTIVE;
    42e2:	4b10      	ldr	r3, [pc, #64]	; (4324 <uart4_status_isr+0xb0>)
    42e4:	222c      	movs	r2, #44	; 0x2c
    42e6:	70da      	strb	r2, [r3, #3]
	}
}
    42e8:	bc30      	pop	{r4, r5}
    42ea:	4770      	bx	lr
			else avail = SERIAL5_RX_BUFFER_SIZE + head - tail;
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = UART4_C2;
	if ((c & UART_C2_TIE) && (UART4_S1 & UART_S1_TDRE)) {
    42ec:	7911      	ldrb	r1, [r2, #4]
    42ee:	0609      	lsls	r1, r1, #24
    42f0:	d5ea      	bpl.n	42c8 <uart4_status_isr+0x54>
		head = tx_buffer_head;
    42f2:	4914      	ldr	r1, [pc, #80]	; (4344 <uart4_status_isr+0xd0>)
		tail = tx_buffer_tail;
    42f4:	4810      	ldr	r0, [pc, #64]	; (4338 <uart4_status_isr+0xc4>)
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = UART4_C2;
	if ((c & UART_C2_TIE) && (UART4_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    42f6:	780c      	ldrb	r4, [r1, #0]
		tail = tx_buffer_tail;
    42f8:	7801      	ldrb	r1, [r0, #0]
    42fa:	b2c9      	uxtb	r1, r1
		if (head == tail) {
    42fc:	428c      	cmp	r4, r1
    42fe:	d00d      	beq.n	431c <uart4_status_isr+0xa8>
			UART4_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL5_TX_BUFFER_SIZE) tail = 0;
    4300:	1c4a      	adds	r2, r1, #1
    4302:	2a27      	cmp	r2, #39	; 0x27
    4304:	bf84      	itt	hi
    4306:	2100      	movhi	r1, #0
    4308:	460a      	movhi	r2, r1
			n = tx_buffer[tail];
    430a:	4d0f      	ldr	r5, [pc, #60]	; (4348 <uart4_status_isr+0xd4>)
			if (use9Bits) UART4_C3 = (UART4_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART4_D = n;
    430c:	4c05      	ldr	r4, [pc, #20]	; (4324 <uart4_status_isr+0xb0>)
    430e:	bf98      	it	ls
    4310:	b2d1      	uxtbls	r1, r2
		tail = tx_buffer_tail;
		if (head == tail) {
			UART4_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL5_TX_BUFFER_SIZE) tail = 0;
			n = tx_buffer[tail];
    4312:	5caa      	ldrb	r2, [r5, r2]
    4314:	b2d2      	uxtb	r2, r2
			if (use9Bits) UART4_C3 = (UART4_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART4_D = n;
    4316:	71e2      	strb	r2, [r4, #7]
			tx_buffer_tail = tail;
    4318:	7001      	strb	r1, [r0, #0]
    431a:	e7d5      	b.n	42c8 <uart4_status_isr+0x54>
	c = UART4_C2;
	if ((c & UART_C2_TIE) && (UART4_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			UART4_C2 = C2_TX_COMPLETING;
    431c:	216c      	movs	r1, #108	; 0x6c
    431e:	70d1      	strb	r1, [r2, #3]
    4320:	e7d2      	b.n	42c8 <uart4_status_isr+0x54>
    4322:	bf00      	nop
    4324:	400ea000 	.word	0x400ea000
    4328:	1fff1944 	.word	0x1fff1944
    432c:	1fff1945 	.word	0x1fff1945
    4330:	1fff1970 	.word	0x1fff1970
    4334:	1fff1940 	.word	0x1fff1940
    4338:	1fff19b1 	.word	0x1fff19b1
    433c:	1fff19b4 	.word	0x1fff19b4
    4340:	1fff19b0 	.word	0x1fff19b0
    4344:	1fff19b8 	.word	0x1fff19b8
    4348:	1fff1948 	.word	0x1fff1948

0000434c <serial6_available>:

int serial6_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    434c:	4a05      	ldr	r2, [pc, #20]	; (4364 <serial6_available+0x18>)
	tail = rx_buffer_tail;
    434e:	4b06      	ldr	r3, [pc, #24]	; (4368 <serial6_available+0x1c>)

int serial6_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    4350:	7810      	ldrb	r0, [r2, #0]
	tail = rx_buffer_tail;
    4352:	781b      	ldrb	r3, [r3, #0]

int serial6_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    4354:	b2c0      	uxtb	r0, r0
	tail = rx_buffer_tail;
    4356:	b2db      	uxtb	r3, r3
	if (head >= tail) return head - tail;
    4358:	4298      	cmp	r0, r3
	return SERIAL6_RX_BUFFER_SIZE + head - tail;
    435a:	bf38      	it	cc
    435c:	3040      	addcc	r0, #64	; 0x40
    435e:	1ac0      	subs	r0, r0, r3
}
    4360:	4770      	bx	lr
    4362:	bf00      	nop
    4364:	1fff19c0 	.word	0x1fff19c0
    4368:	1fff19c1 	.word	0x1fff19c1

0000436c <lpuart0_status_isr>:
//   Receive data above watermark   LPUART_STAT_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void lpuart0_status_isr(void)
{
    436c:	b430      	push	{r4, r5}
	uint32_t head, tail, n;
	uint32_t c;

	if (LPUART0_STAT & LPUART_STAT_RDRF) {
    436e:	4b2c      	ldr	r3, [pc, #176]	; (4420 <lpuart0_status_isr+0xb4>)
    4370:	685a      	ldr	r2, [r3, #4]
    4372:	0294      	lsls	r4, r2, #10
    4374:	d51f      	bpl.n	43b6 <lpuart0_status_isr+0x4a>
//			n = UART5_D | 0x100;
//		} else {
//			n = UART5_D;
//		}
		n = LPUART0_DATA & 0x3ff;	// use only the 10 data bits
		head = rx_buffer_head + 1;
    4376:	482b      	ldr	r0, [pc, #172]	; (4424 <lpuart0_status_isr+0xb8>)
//		if (use9Bits && (UART5_C3 & 0x80)) {
//			n = UART5_D | 0x100;
//		} else {
//			n = UART5_D;
//		}
		n = LPUART0_DATA & 0x3ff;	// use only the 10 data bits
    4378:	68da      	ldr	r2, [r3, #12]
		head = rx_buffer_head + 1;
    437a:	7803      	ldrb	r3, [r0, #0]
		if (head >= SERIAL6_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    437c:	492a      	ldr	r1, [pc, #168]	; (4428 <lpuart0_status_isr+0xbc>)
//			n = UART5_D | 0x100;
//		} else {
//			n = UART5_D;
//		}
		n = LPUART0_DATA & 0x3ff;	// use only the 10 data bits
		head = rx_buffer_head + 1;
    437e:	3301      	adds	r3, #1
    4380:	2b3f      	cmp	r3, #63	; 0x3f
		if (head >= SERIAL6_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    4382:	7809      	ldrb	r1, [r1, #0]
//			n = UART5_D | 0x100;
//		} else {
//			n = UART5_D;
//		}
		n = LPUART0_DATA & 0x3ff;	// use only the 10 data bits
		head = rx_buffer_head + 1;
    4384:	bfc8      	it	gt
    4386:	2300      	movgt	r3, #0
		if (head >= SERIAL6_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    4388:	428b      	cmp	r3, r1
    438a:	d004      	beq.n	4396 <lpuart0_status_isr+0x2a>
			rx_buffer[head] = n;
    438c:	4c27      	ldr	r4, [pc, #156]	; (442c <lpuart0_status_isr+0xc0>)
    438e:	b2d2      	uxtb	r2, r2
			rx_buffer_head = head;
    4390:	b2d9      	uxtb	r1, r3
//		}
		n = LPUART0_DATA & 0x3ff;	// use only the 10 data bits
		head = rx_buffer_head + 1;
		if (head >= SERIAL6_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
			rx_buffer[head] = n;
    4392:	54e2      	strb	r2, [r4, r3]
			rx_buffer_head = head;
    4394:	7001      	strb	r1, [r0, #0]
		}
		if (rts_pin) {
    4396:	4a26      	ldr	r2, [pc, #152]	; (4430 <lpuart0_status_isr+0xc4>)
    4398:	6811      	ldr	r1, [r2, #0]
    439a:	b161      	cbz	r1, 43b6 <lpuart0_status_isr+0x4a>
			int avail;
			tail = tx_buffer_tail;
    439c:	4a25      	ldr	r2, [pc, #148]	; (4434 <lpuart0_status_isr+0xc8>)
    439e:	7812      	ldrb	r2, [r2, #0]
    43a0:	b2d2      	uxtb	r2, r2
			if (head >= tail) avail = head - tail;
    43a2:	4293      	cmp	r3, r2
			else avail = SERIAL6_RX_BUFFER_SIZE + head - tail;
    43a4:	bf36      	itet	cc
    43a6:	f1c2 0240 	rsbcc	r2, r2, #64	; 0x40
			rx_buffer_head = head;
		}
		if (rts_pin) {
			int avail;
			tail = tx_buffer_tail;
			if (head >= tail) avail = head - tail;
    43aa:	1a9b      	subcs	r3, r3, r2
			else avail = SERIAL6_RX_BUFFER_SIZE + head - tail;
    43ac:	189b      	addcc	r3, r3, r2
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
    43ae:	2b27      	cmp	r3, #39	; 0x27
    43b0:	bfc4      	itt	gt
    43b2:	2301      	movgt	r3, #1
    43b4:	700b      	strbgt	r3, [r1, #0]
		}
	}
	c = LPUART0_CTRL;
    43b6:	4a1a      	ldr	r2, [pc, #104]	; (4420 <lpuart0_status_isr+0xb4>)
    43b8:	6893      	ldr	r3, [r2, #8]
	if ((c & LPUART_CTRL_TIE) && (LPUART0_STAT & LPUART_STAT_TDRE)) {
    43ba:	0218      	lsls	r0, r3, #8
    43bc:	d502      	bpl.n	43c4 <lpuart0_status_isr+0x58>
    43be:	6852      	ldr	r2, [r2, #4]
    43c0:	0211      	lsls	r1, r2, #8
    43c2:	d411      	bmi.n	43e8 <lpuart0_status_isr+0x7c>
			//if (use9Bits) UART5_C3 = (UART5_C3 & ~0x40) | ((n & 0x100) >> 2);
			LPUART0_DATA = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & LPUART_CTRL_TCIE) && (LPUART0_STAT & LPUART_STAT_TC)) {
    43c4:	025a      	lsls	r2, r3, #9
    43c6:	d50d      	bpl.n	43e4 <lpuart0_status_isr+0x78>
    43c8:	4b15      	ldr	r3, [pc, #84]	; (4420 <lpuart0_status_isr+0xb4>)
    43ca:	685b      	ldr	r3, [r3, #4]
    43cc:	025b      	lsls	r3, r3, #9
    43ce:	d509      	bpl.n	43e4 <lpuart0_status_isr+0x78>
		transmitting = 0;
		if (transmit_pin) transmit_deassert();
    43d0:	4b19      	ldr	r3, [pc, #100]	; (4438 <lpuart0_status_isr+0xcc>)
			LPUART0_DATA = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & LPUART_CTRL_TCIE) && (LPUART0_STAT & LPUART_STAT_TC)) {
		transmitting = 0;
    43d2:	491a      	ldr	r1, [pc, #104]	; (443c <lpuart0_status_isr+0xd0>)
		if (transmit_pin) transmit_deassert();
    43d4:	681b      	ldr	r3, [r3, #0]
			LPUART0_DATA = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & LPUART_CTRL_TCIE) && (LPUART0_STAT & LPUART_STAT_TC)) {
		transmitting = 0;
    43d6:	2200      	movs	r2, #0
    43d8:	700a      	strb	r2, [r1, #0]
		if (transmit_pin) transmit_deassert();
    43da:	b103      	cbz	r3, 43de <lpuart0_status_isr+0x72>
    43dc:	701a      	strb	r2, [r3, #0]
		BITBAND_CLR_BIT(LPUART0_CTRL, TCIE_BIT);
    43de:	4b18      	ldr	r3, [pc, #96]	; (4440 <lpuart0_status_isr+0xd4>)
    43e0:	2200      	movs	r2, #0
    43e2:	601a      	str	r2, [r3, #0]
		// LPUART0_CTRL &= ~LPUART_CTRL_TCIE; // Actually wondering if we can just leave this one on...
	}
}
    43e4:	bc30      	pop	{r4, r5}
    43e6:	4770      	bx	lr
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = LPUART0_CTRL;
	if ((c & LPUART_CTRL_TIE) && (LPUART0_STAT & LPUART_STAT_TDRE)) {
		head = tx_buffer_head;
    43e8:	4a16      	ldr	r2, [pc, #88]	; (4444 <lpuart0_status_isr+0xd8>)
		tail = tx_buffer_tail;
    43ea:	4912      	ldr	r1, [pc, #72]	; (4434 <lpuart0_status_isr+0xc8>)
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = LPUART0_CTRL;
	if ((c & LPUART_CTRL_TIE) && (LPUART0_STAT & LPUART_STAT_TDRE)) {
		head = tx_buffer_head;
    43ec:	7810      	ldrb	r0, [r2, #0]
		tail = tx_buffer_tail;
    43ee:	780a      	ldrb	r2, [r1, #0]
    43f0:	b2d2      	uxtb	r2, r2
		if (head == tail) {
    43f2:	4290      	cmp	r0, r2
    43f4:	d00d      	beq.n	4412 <lpuart0_status_isr+0xa6>
			BITBAND_CLR_BIT(LPUART0_CTRL, TIE_BIT);
			BITBAND_SET_BIT(LPUART0_CTRL, TCIE_BIT);
			//LPUART0_CTRL &= ~LPUART_CTRL_TIE; 
  			//LPUART0_CTRL |= LPUART_CTRL_TCIE; // Actually wondering if we can just leave this one on...
		} else {
			if (++tail >= SERIAL6_TX_BUFFER_SIZE) tail = 0;
    43f6:	3201      	adds	r2, #1
    43f8:	2a27      	cmp	r2, #39	; 0x27
    43fa:	bf84      	itt	hi
    43fc:	2000      	movhi	r0, #0
    43fe:	4602      	movhi	r2, r0
			n = tx_buffer[tail];
    4400:	4d11      	ldr	r5, [pc, #68]	; (4448 <lpuart0_status_isr+0xdc>)
			//if (use9Bits) UART5_C3 = (UART5_C3 & ~0x40) | ((n & 0x100) >> 2);
			LPUART0_DATA = n;
    4402:	4c07      	ldr	r4, [pc, #28]	; (4420 <lpuart0_status_isr+0xb4>)
    4404:	bf98      	it	ls
    4406:	b2d0      	uxtbls	r0, r2
			BITBAND_SET_BIT(LPUART0_CTRL, TCIE_BIT);
			//LPUART0_CTRL &= ~LPUART_CTRL_TIE; 
  			//LPUART0_CTRL |= LPUART_CTRL_TCIE; // Actually wondering if we can just leave this one on...
		} else {
			if (++tail >= SERIAL6_TX_BUFFER_SIZE) tail = 0;
			n = tx_buffer[tail];
    4408:	5caa      	ldrb	r2, [r5, r2]
    440a:	b2d2      	uxtb	r2, r2
			//if (use9Bits) UART5_C3 = (UART5_C3 & ~0x40) | ((n & 0x100) >> 2);
			LPUART0_DATA = n;
    440c:	60e2      	str	r2, [r4, #12]
			tx_buffer_tail = tail;
    440e:	7008      	strb	r0, [r1, #0]
    4410:	e7d8      	b.n	43c4 <lpuart0_status_isr+0x58>
	c = LPUART0_CTRL;
	if ((c & LPUART_CTRL_TIE) && (LPUART0_STAT & LPUART_STAT_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			BITBAND_CLR_BIT(LPUART0_CTRL, TIE_BIT);
    4412:	480e      	ldr	r0, [pc, #56]	; (444c <lpuart0_status_isr+0xe0>)
			BITBAND_SET_BIT(LPUART0_CTRL, TCIE_BIT);
    4414:	4a0a      	ldr	r2, [pc, #40]	; (4440 <lpuart0_status_isr+0xd4>)
	c = LPUART0_CTRL;
	if ((c & LPUART_CTRL_TIE) && (LPUART0_STAT & LPUART_STAT_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			BITBAND_CLR_BIT(LPUART0_CTRL, TIE_BIT);
    4416:	2400      	movs	r4, #0
			BITBAND_SET_BIT(LPUART0_CTRL, TCIE_BIT);
    4418:	2101      	movs	r1, #1
	c = LPUART0_CTRL;
	if ((c & LPUART_CTRL_TIE) && (LPUART0_STAT & LPUART_STAT_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			BITBAND_CLR_BIT(LPUART0_CTRL, TIE_BIT);
    441a:	6004      	str	r4, [r0, #0]
			BITBAND_SET_BIT(LPUART0_CTRL, TCIE_BIT);
    441c:	6011      	str	r1, [r2, #0]
    441e:	e7d1      	b.n	43c4 <lpuart0_status_isr+0x58>
    4420:	400c4000 	.word	0x400c4000
    4424:	1fff19c0 	.word	0x1fff19c0
    4428:	1fff19c1 	.word	0x1fff19c1
    442c:	1fff19ec 	.word	0x1fff19ec
    4430:	1fff19bc 	.word	0x1fff19bc
    4434:	1fff1a2d 	.word	0x1fff1a2d
    4438:	1fff1a30 	.word	0x1fff1a30
    443c:	1fff1a2c 	.word	0x1fff1a2c
    4440:	43880158 	.word	0x43880158
    4444:	1fff1a34 	.word	0x1fff1a34
    4448:	1fff19c4 	.word	0x1fff19c4
    444c:	4388015c 	.word	0x4388015c

00004450 <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    4450:	b510      	push	{r4, lr}
    4452:	b084      	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    4454:	b672      	cpsid	i
	FTFL_FCCOB1 = 15;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
    4456:	f7fd fc6d 	bl	1d34 <kinetis_hsrun_disable>
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    445a:	4a18      	ldr	r2, [pc, #96]	; (44bc <usb_init_serialnumber+0x6c>)
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    445c:	4b18      	ldr	r3, [pc, #96]	; (44c0 <usb_init_serialnumber+0x70>)
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    445e:	4919      	ldr	r1, [pc, #100]	; (44c4 <usb_init_serialnumber+0x74>)
    4460:	6011      	str	r1, [r2, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    4462:	2270      	movs	r2, #112	; 0x70
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    4464:	2180      	movs	r1, #128	; 0x80
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    4466:	701a      	strb	r2, [r3, #0]
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    4468:	461a      	mov	r2, r3
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    446a:	7019      	strb	r1, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    446c:	7813      	ldrb	r3, [r2, #0]
    446e:	061b      	lsls	r3, r3, #24
    4470:	d5fc      	bpl.n	446c <usb_init_serialnumber+0x1c>
	num = *(uint32_t *)&FTFL_FCCOBB;
    4472:	4b15      	ldr	r3, [pc, #84]	; (44c8 <usb_init_serialnumber+0x78>)
    4474:	681c      	ldr	r4, [r3, #0]
	kinetis_hsrun_enable();
    4476:	f7fd fc77 	bl	1d68 <kinetis_hsrun_enable>
#endif
	__enable_irq();
    447a:	b662      	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    447c:	4b13      	ldr	r3, [pc, #76]	; (44cc <usb_init_serialnumber+0x7c>)
    447e:	429c      	cmp	r4, r3
    4480:	bf9c      	itt	ls
    4482:	eb04 0484 	addls.w	r4, r4, r4, lsl #2
    4486:	0064      	lslls	r4, r4, #1
	ultoa(num, buf, 10);
    4488:	4620      	mov	r0, r4
    448a:	4c11      	ldr	r4, [pc, #68]	; (44d0 <usb_init_serialnumber+0x80>)
    448c:	a901      	add	r1, sp, #4
    448e:	220a      	movs	r2, #10
    4490:	f7ff fc96 	bl	3dc0 <ultoa>
    4494:	a901      	add	r1, sp, #4
    4496:	4620      	mov	r0, r4
	for (i=0; i<10; i++) {
    4498:	2300      	movs	r3, #0
		char c = buf[i];
    449a:	f811 2b01 	ldrb.w	r2, [r1], #1
    449e:	3301      	adds	r3, #1
		if (!c) break;
    44a0:	b13a      	cbz	r2, 44b2 <usb_init_serialnumber+0x62>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    44a2:	2b0a      	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    44a4:	f820 2f02 	strh.w	r2, [r0, #2]!
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    44a8:	d1f7      	bne.n	449a <usb_init_serialnumber+0x4a>
    44aa:	2316      	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    44ac:	7023      	strb	r3, [r4, #0]
}
    44ae:	b004      	add	sp, #16
    44b0:	bd10      	pop	{r4, pc}
    44b2:	005b      	lsls	r3, r3, #1
    44b4:	b2db      	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    44b6:	7023      	strb	r3, [r4, #0]
}
    44b8:	b004      	add	sp, #16
    44ba:	bd10      	pop	{r4, pc}
    44bc:	40020004 	.word	0x40020004
    44c0:	40020000 	.word	0x40020000
    44c4:	41070000 	.word	0x41070000
    44c8:	4002000c 	.word	0x4002000c
    44cc:	0098967f 	.word	0x0098967f
    44d0:	1fff0a88 	.word	0x1fff0a88

000044d4 <serialEvent1()>:
#include "HardwareSerial.h"

HardwareSerial Serial1;

void serialEvent1() __attribute__((weak));
void serialEvent1() {}
    44d4:	4770      	bx	lr
    44d6:	bf00      	nop

000044d8 <serialEvent2()>:
#include "HardwareSerial.h"

HardwareSerial2 Serial2;

void serialEvent2() __attribute__((weak));
void serialEvent2() {}
    44d8:	4770      	bx	lr
    44da:	bf00      	nop

000044dc <serialEvent3()>:
#include "HardwareSerial.h"

HardwareSerial3 Serial3;

void serialEvent3() __attribute__((weak));
void serialEvent3() {}
    44dc:	4770      	bx	lr
    44de:	bf00      	nop

000044e0 <serialEvent4()>:
#ifdef HAS_KINETISK_UART3

HardwareSerial4 Serial4;

void serialEvent4() __attribute__((weak));
void serialEvent4() {}
    44e0:	4770      	bx	lr
    44e2:	bf00      	nop

000044e4 <serialEvent5()>:
#ifdef HAS_KINETISK_UART4

HardwareSerial5 Serial5;

void serialEvent5() __attribute__((weak));
void serialEvent5() {}
    44e4:	4770      	bx	lr
    44e6:	bf00      	nop

000044e8 <serialEvent6()>:
#if defined(HAS_KINETISK_UART5) || defined (HAS_KINETISK_LPUART0)

HardwareSerial6 Serial6;

void serialEvent6() __attribute__((weak));
void serialEvent6() {}
    44e8:	4770      	bx	lr
    44ea:	bf00      	nop

000044ec <sinf>:
    44ec:	b500      	push	{lr}
    44ee:	ee10 3a10 	vmov	r3, s0
    44f2:	4a21      	ldr	r2, [pc, #132]	; (4578 <sinf+0x8c>)
    44f4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    44f8:	4293      	cmp	r3, r2
    44fa:	b083      	sub	sp, #12
    44fc:	dd1a      	ble.n	4534 <sinf+0x48>
    44fe:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
    4502:	db04      	blt.n	450e <sinf+0x22>
    4504:	ee30 0a40 	vsub.f32	s0, s0, s0
    4508:	b003      	add	sp, #12
    450a:	f85d fb04 	ldr.w	pc, [sp], #4
    450e:	4668      	mov	r0, sp
    4510:	f000 f9dc 	bl	48cc <__ieee754_rem_pio2f>
    4514:	f000 0003 	and.w	r0, r0, #3
    4518:	2801      	cmp	r0, #1
    451a:	d01d      	beq.n	4558 <sinf+0x6c>
    451c:	2802      	cmp	r0, #2
    451e:	d011      	beq.n	4544 <sinf+0x58>
    4520:	b308      	cbz	r0, 4566 <sinf+0x7a>
    4522:	eddd 0a01 	vldr	s1, [sp, #4]
    4526:	ed9d 0a00 	vldr	s0, [sp]
    452a:	f000 fb1b 	bl	4b64 <__kernel_cosf>
    452e:	eeb1 0a40 	vneg.f32	s0, s0
    4532:	e7e9      	b.n	4508 <sinf+0x1c>
    4534:	2000      	movs	r0, #0
    4536:	eddf 0a11 	vldr	s1, [pc, #68]	; 457c <sinf+0x90>
    453a:	f000 fead 	bl	5298 <__kernel_sinf>
    453e:	b003      	add	sp, #12
    4540:	f85d fb04 	ldr.w	pc, [sp], #4
    4544:	2001      	movs	r0, #1
    4546:	eddd 0a01 	vldr	s1, [sp, #4]
    454a:	ed9d 0a00 	vldr	s0, [sp]
    454e:	f000 fea3 	bl	5298 <__kernel_sinf>
    4552:	eeb1 0a40 	vneg.f32	s0, s0
    4556:	e7d7      	b.n	4508 <sinf+0x1c>
    4558:	eddd 0a01 	vldr	s1, [sp, #4]
    455c:	ed9d 0a00 	vldr	s0, [sp]
    4560:	f000 fb00 	bl	4b64 <__kernel_cosf>
    4564:	e7d0      	b.n	4508 <sinf+0x1c>
    4566:	2001      	movs	r0, #1
    4568:	eddd 0a01 	vldr	s1, [sp, #4]
    456c:	ed9d 0a00 	vldr	s0, [sp]
    4570:	f000 fe92 	bl	5298 <__kernel_sinf>
    4574:	e7c8      	b.n	4508 <sinf+0x1c>
    4576:	bf00      	nop
    4578:	3f490fd8 	.word	0x3f490fd8
    457c:	00000000 	.word	0x00000000

00004580 <fmod>:
    4580:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    4584:	ed2d 8b02 	vpush	{d8}
    4588:	b08b      	sub	sp, #44	; 0x2c
    458a:	ec57 6b10 	vmov	r6, r7, d0
    458e:	ec55 4b11 	vmov	r4, r5, d1
    4592:	f000 f861 	bl	4658 <__ieee754_fmod>
    4596:	4b2e      	ldr	r3, [pc, #184]	; (4650 <fmod+0xd0>)
    4598:	eeb0 8a40 	vmov.f32	s16, s0
    459c:	eef0 8a60 	vmov.f32	s17, s1
    45a0:	f993 8000 	ldrsb.w	r8, [r3]
    45a4:	f1b8 3fff 	cmp.w	r8, #4294967295
    45a8:	d031      	beq.n	460e <fmod+0x8e>
    45aa:	4622      	mov	r2, r4
    45ac:	462b      	mov	r3, r5
    45ae:	4620      	mov	r0, r4
    45b0:	4629      	mov	r1, r5
    45b2:	f001 fbd1 	bl	5d58 <__aeabi_dcmpun>
    45b6:	bb50      	cbnz	r0, 460e <fmod+0x8e>
    45b8:	4632      	mov	r2, r6
    45ba:	463b      	mov	r3, r7
    45bc:	4630      	mov	r0, r6
    45be:	4639      	mov	r1, r7
    45c0:	f001 fbca 	bl	5d58 <__aeabi_dcmpun>
    45c4:	4681      	mov	r9, r0
    45c6:	bb10      	cbnz	r0, 460e <fmod+0x8e>
    45c8:	2200      	movs	r2, #0
    45ca:	2300      	movs	r3, #0
    45cc:	4620      	mov	r0, r4
    45ce:	4629      	mov	r1, r5
    45d0:	f001 fb90 	bl	5cf4 <__aeabi_dcmpeq>
    45d4:	b1d8      	cbz	r0, 460e <fmod+0x8e>
    45d6:	4b1f      	ldr	r3, [pc, #124]	; (4654 <fmod+0xd4>)
    45d8:	f8cd 9020 	str.w	r9, [sp, #32]
    45dc:	2201      	movs	r2, #1
    45de:	e9cd 6702 	strd	r6, r7, [sp, #8]
    45e2:	e9cd 4504 	strd	r4, r5, [sp, #16]
    45e6:	e88d 000c 	stmia.w	sp, {r2, r3}
    45ea:	f1b8 0f00 	cmp.w	r8, #0
    45ee:	d117      	bne.n	4620 <fmod+0xa0>
    45f0:	e9cd 6706 	strd	r6, r7, [sp, #24]
    45f4:	4668      	mov	r0, sp
    45f6:	f000 fe97 	bl	5328 <matherr>
    45fa:	b1e0      	cbz	r0, 4636 <fmod+0xb6>
    45fc:	9b08      	ldr	r3, [sp, #32]
    45fe:	bb0b      	cbnz	r3, 4644 <fmod+0xc4>
    4600:	ed9d 0b06 	vldr	d0, [sp, #24]
    4604:	b00b      	add	sp, #44	; 0x2c
    4606:	ecbd 8b02 	vpop	{d8}
    460a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    460e:	eeb0 0a48 	vmov.f32	s0, s16
    4612:	eef0 0a68 	vmov.f32	s1, s17
    4616:	b00b      	add	sp, #44	; 0x2c
    4618:	ecbd 8b02 	vpop	{d8}
    461c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    4620:	2200      	movs	r2, #0
    4622:	2300      	movs	r3, #0
    4624:	4610      	mov	r0, r2
    4626:	4619      	mov	r1, r3
    4628:	f001 fa26 	bl	5a78 <__aeabi_ddiv>
    462c:	f1b8 0f02 	cmp.w	r8, #2
    4630:	e9cd 0106 	strd	r0, r1, [sp, #24]
    4634:	d1de      	bne.n	45f4 <fmod+0x74>
    4636:	f001 fc49 	bl	5ecc <__errno>
    463a:	2321      	movs	r3, #33	; 0x21
    463c:	6003      	str	r3, [r0, #0]
    463e:	9b08      	ldr	r3, [sp, #32]
    4640:	2b00      	cmp	r3, #0
    4642:	d0dd      	beq.n	4600 <fmod+0x80>
    4644:	f001 fc42 	bl	5ecc <__errno>
    4648:	9b08      	ldr	r3, [sp, #32]
    464a:	6003      	str	r3, [r0, #0]
    464c:	e7d8      	b.n	4600 <fmod+0x80>
    464e:	bf00      	nop
    4650:	1fff0a9e 	.word	0x1fff0a9e
    4654:	00006bf8 	.word	0x00006bf8

00004658 <__ieee754_fmod>:
    4658:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    465c:	ec53 2b11 	vmov	r2, r3, d1
    4660:	f023 4900 	bic.w	r9, r3, #2147483648	; 0x80000000
    4664:	ea52 0009 	orrs.w	r0, r2, r9
    4668:	ec55 4b10 	vmov	r4, r5, d0
    466c:	d025      	beq.n	46ba <__ieee754_fmod+0x62>
    466e:	f005 4600 	and.w	r6, r5, #2147483648	; 0x80000000
    4672:	488f      	ldr	r0, [pc, #572]	; (48b0 <__ieee754_fmod+0x258>)
    4674:	ea85 0b06 	eor.w	fp, r5, r6
    4678:	4583      	cmp	fp, r0
    467a:	dc1e      	bgt.n	46ba <__ieee754_fmod+0x62>
    467c:	4250      	negs	r0, r2
    467e:	4310      	orrs	r0, r2
    4680:	f8df c244 	ldr.w	ip, [pc, #580]	; 48c8 <__ieee754_fmod+0x270>
    4684:	ea49 70d0 	orr.w	r0, r9, r0, lsr #31
    4688:	4560      	cmp	r0, ip
    468a:	ee11 8a10 	vmov	r8, s2
    468e:	d814      	bhi.n	46ba <__ieee754_fmod+0x62>
    4690:	45cb      	cmp	fp, r9
    4692:	461f      	mov	r7, r3
    4694:	ee10 aa10 	vmov	sl, s0
    4698:	ee11 ea10 	vmov	lr, s2
    469c:	ee10 1a10 	vmov	r1, s0
    46a0:	dc17      	bgt.n	46d2 <__ieee754_fmod+0x7a>
    46a2:	db28      	blt.n	46f6 <__ieee754_fmod+0x9e>
    46a4:	4294      	cmp	r4, r2
    46a6:	d326      	bcc.n	46f6 <__ieee754_fmod+0x9e>
    46a8:	d113      	bne.n	46d2 <__ieee754_fmod+0x7a>
    46aa:	4b82      	ldr	r3, [pc, #520]	; (48b4 <__ieee754_fmod+0x25c>)
    46ac:	0ff6      	lsrs	r6, r6, #31
    46ae:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
    46b2:	ed93 0b00 	vldr	d0, [r3]
    46b6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    46ba:	4620      	mov	r0, r4
    46bc:	4629      	mov	r1, r5
    46be:	f001 f8b1 	bl	5824 <__aeabi_dmul>
    46c2:	4602      	mov	r2, r0
    46c4:	460b      	mov	r3, r1
    46c6:	f001 f9d7 	bl	5a78 <__aeabi_ddiv>
    46ca:	ec41 0b10 	vmov	d0, r0, r1
    46ce:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    46d2:	f5bb 1f80 	cmp.w	fp, #1048576	; 0x100000
    46d6:	da12      	bge.n	46fe <__ieee754_fmod+0xa6>
    46d8:	f1bb 0f00 	cmp.w	fp, #0
    46dc:	f040 80a7 	bne.w	482e <__ieee754_fmod+0x1d6>
    46e0:	f1ba 0f00 	cmp.w	sl, #0
    46e4:	4653      	mov	r3, sl
    46e6:	4874      	ldr	r0, [pc, #464]	; (48b8 <__ieee754_fmod+0x260>)
    46e8:	dd0d      	ble.n	4706 <__ieee754_fmod+0xae>
    46ea:	005b      	lsls	r3, r3, #1
    46ec:	2b00      	cmp	r3, #0
    46ee:	f100 30ff 	add.w	r0, r0, #4294967295
    46f2:	dcfa      	bgt.n	46ea <__ieee754_fmod+0x92>
    46f4:	e007      	b.n	4706 <__ieee754_fmod+0xae>
    46f6:	ec45 4b10 	vmov	d0, r4, r5
    46fa:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    46fe:	ea4f 502b 	mov.w	r0, fp, asr #20
    4702:	f2a0 30ff 	subw	r0, r0, #1023	; 0x3ff
    4706:	f5b9 1f80 	cmp.w	r9, #1048576	; 0x100000
    470a:	da0f      	bge.n	472c <__ieee754_fmod+0xd4>
    470c:	f1b9 0f00 	cmp.w	r9, #0
    4710:	f040 80a7 	bne.w	4862 <__ieee754_fmod+0x20a>
    4714:	f1b8 0f00 	cmp.w	r8, #0
    4718:	4643      	mov	r3, r8
    471a:	f8df c19c 	ldr.w	ip, [pc, #412]	; 48b8 <__ieee754_fmod+0x260>
    471e:	dd09      	ble.n	4734 <__ieee754_fmod+0xdc>
    4720:	005b      	lsls	r3, r3, #1
    4722:	2b00      	cmp	r3, #0
    4724:	f10c 3cff 	add.w	ip, ip, #4294967295
    4728:	dcfa      	bgt.n	4720 <__ieee754_fmod+0xc8>
    472a:	e003      	b.n	4734 <__ieee754_fmod+0xdc>
    472c:	ea4f 5c29 	mov.w	ip, r9, asr #20
    4730:	f2ac 3cff 	subw	ip, ip, #1023	; 0x3ff
    4734:	4b61      	ldr	r3, [pc, #388]	; (48bc <__ieee754_fmod+0x264>)
    4736:	4298      	cmp	r0, r3
    4738:	db5b      	blt.n	47f2 <__ieee754_fmod+0x19a>
    473a:	f3cb 0313 	ubfx	r3, fp, #0, #20
    473e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    4742:	4a5e      	ldr	r2, [pc, #376]	; (48bc <__ieee754_fmod+0x264>)
    4744:	4594      	cmp	ip, r2
    4746:	db63      	blt.n	4810 <__ieee754_fmod+0x1b8>
    4748:	f3c7 0513 	ubfx	r5, r7, #0, #20
    474c:	f445 1580 	orr.w	r5, r5, #1048576	; 0x100000
    4750:	ebcc 0000 	rsb	r0, ip, r0
    4754:	e007      	b.n	4766 <__ieee754_fmod+0x10e>
    4756:	ea52 0304 	orrs.w	r3, r2, r4
    475a:	d013      	beq.n	4784 <__ieee754_fmod+0x12c>
    475c:	0fe3      	lsrs	r3, r4, #31
    475e:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    4762:	0061      	lsls	r1, r4, #1
    4764:	3801      	subs	r0, #1
    4766:	ebce 0401 	rsb	r4, lr, r1
    476a:	1b5a      	subs	r2, r3, r5
    476c:	b190      	cbz	r0, 4794 <__ieee754_fmod+0x13c>
    476e:	4571      	cmp	r1, lr
    4770:	bf38      	it	cc
    4772:	f102 32ff 	addcc.w	r2, r2, #4294967295
    4776:	2a00      	cmp	r2, #0
    4778:	daed      	bge.n	4756 <__ieee754_fmod+0xfe>
    477a:	0fca      	lsrs	r2, r1, #31
    477c:	eb02 0343 	add.w	r3, r2, r3, lsl #1
    4780:	0049      	lsls	r1, r1, #1
    4782:	e7ef      	b.n	4764 <__ieee754_fmod+0x10c>
    4784:	4b4b      	ldr	r3, [pc, #300]	; (48b4 <__ieee754_fmod+0x25c>)
    4786:	0ff6      	lsrs	r6, r6, #31
    4788:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
    478c:	ed96 0b00 	vldr	d0, [r6]
    4790:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4794:	4571      	cmp	r1, lr
    4796:	4615      	mov	r5, r2
    4798:	bf38      	it	cc
    479a:	f102 35ff 	addcc.w	r5, r2, #4294967295
    479e:	2d00      	cmp	r5, #0
    47a0:	bfac      	ite	ge
    47a2:	ebce 0101 	rsbge	r1, lr, r1
    47a6:	461d      	movlt	r5, r3
    47a8:	ea55 0301 	orrs.w	r3, r5, r1
    47ac:	d0ea      	beq.n	4784 <__ieee754_fmod+0x12c>
    47ae:	4a44      	ldr	r2, [pc, #272]	; (48c0 <__ieee754_fmod+0x268>)
    47b0:	4295      	cmp	r5, r2
    47b2:	dc08      	bgt.n	47c6 <__ieee754_fmod+0x16e>
    47b4:	0fcb      	lsrs	r3, r1, #31
    47b6:	eb03 0545 	add.w	r5, r3, r5, lsl #1
    47ba:	4295      	cmp	r5, r2
    47bc:	f10c 3cff 	add.w	ip, ip, #4294967295
    47c0:	ea4f 0141 	mov.w	r1, r1, lsl #1
    47c4:	ddf6      	ble.n	47b4 <__ieee754_fmod+0x15c>
    47c6:	4b3d      	ldr	r3, [pc, #244]	; (48bc <__ieee754_fmod+0x264>)
    47c8:	459c      	cmp	ip, r3
    47ca:	da54      	bge.n	4876 <__ieee754_fmod+0x21e>
    47cc:	4a3b      	ldr	r2, [pc, #236]	; (48bc <__ieee754_fmod+0x264>)
    47ce:	ebcc 0202 	rsb	r2, ip, r2
    47d2:	2a14      	cmp	r2, #20
    47d4:	dc5b      	bgt.n	488e <__ieee754_fmod+0x236>
    47d6:	f1c2 0320 	rsb	r3, r2, #32
    47da:	fa05 f303 	lsl.w	r3, r5, r3
    47de:	40d1      	lsrs	r1, r2
    47e0:	430b      	orrs	r3, r1
    47e2:	4115      	asrs	r5, r2
    47e4:	ea45 0106 	orr.w	r1, r5, r6
    47e8:	4618      	mov	r0, r3
    47ea:	ec41 0b10 	vmov	d0, r0, r1
    47ee:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    47f2:	4932      	ldr	r1, [pc, #200]	; (48bc <__ieee754_fmod+0x264>)
    47f4:	1a09      	subs	r1, r1, r0
    47f6:	291f      	cmp	r1, #31
    47f8:	dc2d      	bgt.n	4856 <__ieee754_fmod+0x1fe>
    47fa:	f1c1 0320 	rsb	r3, r1, #32
    47fe:	fa0b fb01 	lsl.w	fp, fp, r1
    4802:	fa2a f303 	lsr.w	r3, sl, r3
    4806:	ea43 030b 	orr.w	r3, r3, fp
    480a:	fa0a f101 	lsl.w	r1, sl, r1
    480e:	e798      	b.n	4742 <__ieee754_fmod+0xea>
    4810:	4c2a      	ldr	r4, [pc, #168]	; (48bc <__ieee754_fmod+0x264>)
    4812:	ebcc 0404 	rsb	r4, ip, r4
    4816:	2c1f      	cmp	r4, #31
    4818:	dc15      	bgt.n	4846 <__ieee754_fmod+0x1ee>
    481a:	f1c4 0220 	rsb	r2, r4, #32
    481e:	fa09 f504 	lsl.w	r5, r9, r4
    4822:	fa28 f202 	lsr.w	r2, r8, r2
    4826:	4315      	orrs	r5, r2
    4828:	fa08 fe04 	lsl.w	lr, r8, r4
    482c:	e790      	b.n	4750 <__ieee754_fmod+0xf8>
    482e:	ea4f 23cb 	mov.w	r3, fp, lsl #11
    4832:	2b00      	cmp	r3, #0
    4834:	4821      	ldr	r0, [pc, #132]	; (48bc <__ieee754_fmod+0x264>)
    4836:	f77f af66 	ble.w	4706 <__ieee754_fmod+0xae>
    483a:	005b      	lsls	r3, r3, #1
    483c:	2b00      	cmp	r3, #0
    483e:	f100 30ff 	add.w	r0, r0, #4294967295
    4842:	dcfa      	bgt.n	483a <__ieee754_fmod+0x1e2>
    4844:	e75f      	b.n	4706 <__ieee754_fmod+0xae>
    4846:	4d1f      	ldr	r5, [pc, #124]	; (48c4 <__ieee754_fmod+0x26c>)
    4848:	ebcc 0505 	rsb	r5, ip, r5
    484c:	fa08 f505 	lsl.w	r5, r8, r5
    4850:	f04f 0e00 	mov.w	lr, #0
    4854:	e77c      	b.n	4750 <__ieee754_fmod+0xf8>
    4856:	4b1b      	ldr	r3, [pc, #108]	; (48c4 <__ieee754_fmod+0x26c>)
    4858:	1a1b      	subs	r3, r3, r0
    485a:	fa0a f303 	lsl.w	r3, sl, r3
    485e:	2100      	movs	r1, #0
    4860:	e76f      	b.n	4742 <__ieee754_fmod+0xea>
    4862:	f8df c058 	ldr.w	ip, [pc, #88]	; 48bc <__ieee754_fmod+0x264>
    4866:	ea4f 23c9 	mov.w	r3, r9, lsl #11
    486a:	005b      	lsls	r3, r3, #1
    486c:	2b00      	cmp	r3, #0
    486e:	f10c 3cff 	add.w	ip, ip, #4294967295
    4872:	dcfa      	bgt.n	486a <__ieee754_fmod+0x212>
    4874:	e75e      	b.n	4734 <__ieee754_fmod+0xdc>
    4876:	f5a5 1580 	sub.w	r5, r5, #1048576	; 0x100000
    487a:	432e      	orrs	r6, r5
    487c:	f20c 3cff 	addw	ip, ip, #1023	; 0x3ff
    4880:	ea46 530c 	orr.w	r3, r6, ip, lsl #20
    4884:	460a      	mov	r2, r1
    4886:	ec43 2b10 	vmov	d0, r2, r3
    488a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    488e:	2a1f      	cmp	r2, #31
    4890:	dc07      	bgt.n	48a2 <__ieee754_fmod+0x24a>
    4892:	f1c2 0320 	rsb	r3, r2, #32
    4896:	409d      	lsls	r5, r3
    4898:	40d1      	lsrs	r1, r2
    489a:	ea45 0301 	orr.w	r3, r5, r1
    489e:	4635      	mov	r5, r6
    48a0:	e7a0      	b.n	47e4 <__ieee754_fmod+0x18c>
    48a2:	4b08      	ldr	r3, [pc, #32]	; (48c4 <__ieee754_fmod+0x26c>)
    48a4:	ebcc 0303 	rsb	r3, ip, r3
    48a8:	fa45 f303 	asr.w	r3, r5, r3
    48ac:	4635      	mov	r5, r6
    48ae:	e799      	b.n	47e4 <__ieee754_fmod+0x18c>
    48b0:	7fefffff 	.word	0x7fefffff
    48b4:	00006c00 	.word	0x00006c00
    48b8:	fffffbed 	.word	0xfffffbed
    48bc:	fffffc02 	.word	0xfffffc02
    48c0:	000fffff 	.word	0x000fffff
    48c4:	fffffbe2 	.word	0xfffffbe2
    48c8:	7ff00000 	.word	0x7ff00000

000048cc <__ieee754_rem_pio2f>:
    48cc:	b570      	push	{r4, r5, r6, lr}
    48ce:	ee10 3a10 	vmov	r3, s0
    48d2:	4a96      	ldr	r2, [pc, #600]	; (4b2c <__ieee754_rem_pio2f+0x260>)
    48d4:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
    48d8:	4294      	cmp	r4, r2
    48da:	b086      	sub	sp, #24
    48dc:	dd5f      	ble.n	499e <__ieee754_rem_pio2f+0xd2>
    48de:	4a94      	ldr	r2, [pc, #592]	; (4b30 <__ieee754_rem_pio2f+0x264>)
    48e0:	4294      	cmp	r4, r2
    48e2:	ee10 6a10 	vmov	r6, s0
    48e6:	dc1b      	bgt.n	4920 <__ieee754_rem_pio2f+0x54>
    48e8:	2b00      	cmp	r3, #0
    48ea:	eddf 7a92 	vldr	s15, [pc, #584]	; 4b34 <__ieee754_rem_pio2f+0x268>
    48ee:	4a92      	ldr	r2, [pc, #584]	; (4b38 <__ieee754_rem_pio2f+0x26c>)
    48f0:	f024 040f 	bic.w	r4, r4, #15
    48f4:	f340 80d5 	ble.w	4aa2 <__ieee754_rem_pio2f+0x1d6>
    48f8:	4294      	cmp	r4, r2
    48fa:	ee70 7a67 	vsub.f32	s15, s0, s15
    48fe:	d05e      	beq.n	49be <__ieee754_rem_pio2f+0xf2>
    4900:	ed9f 7a8e 	vldr	s14, [pc, #568]	; 4b3c <__ieee754_rem_pio2f+0x270>
    4904:	ee77 6ac7 	vsub.f32	s13, s15, s14
    4908:	2301      	movs	r3, #1
    490a:	ee77 7ae6 	vsub.f32	s15, s15, s13
    490e:	edc0 6a00 	vstr	s13, [r0]
    4912:	ee77 7ac7 	vsub.f32	s15, s15, s14
    4916:	edc0 7a01 	vstr	s15, [r0, #4]
    491a:	4618      	mov	r0, r3
    491c:	b006      	add	sp, #24
    491e:	bd70      	pop	{r4, r5, r6, pc}
    4920:	4a87      	ldr	r2, [pc, #540]	; (4b40 <__ieee754_rem_pio2f+0x274>)
    4922:	4294      	cmp	r4, r2
    4924:	4605      	mov	r5, r0
    4926:	dd5c      	ble.n	49e2 <__ieee754_rem_pio2f+0x116>
    4928:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
    492c:	da3f      	bge.n	49ae <__ieee754_rem_pio2f+0xe2>
    492e:	15e2      	asrs	r2, r4, #23
    4930:	3a86      	subs	r2, #134	; 0x86
    4932:	eba4 53c2 	sub.w	r3, r4, r2, lsl #23
    4936:	ee07 3a10 	vmov	s14, r3
    493a:	eefd 6ac7 	vcvt.s32.f32	s13, s14
    493e:	eddf 7a81 	vldr	s15, [pc, #516]	; 4b44 <__ieee754_rem_pio2f+0x278>
    4942:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    4946:	ee37 7a66 	vsub.f32	s14, s14, s13
    494a:	edcd 6a03 	vstr	s13, [sp, #12]
    494e:	ee27 7a27 	vmul.f32	s14, s14, s15
    4952:	eefd 6ac7 	vcvt.s32.f32	s13, s14
    4956:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    495a:	ee37 7a66 	vsub.f32	s14, s14, s13
    495e:	edcd 6a04 	vstr	s13, [sp, #16]
    4962:	ee67 7a27 	vmul.f32	s15, s14, s15
    4966:	eef5 7a40 	vcmp.f32	s15, #0.0
    496a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    496e:	edcd 7a05 	vstr	s15, [sp, #20]
    4972:	f040 80b7 	bne.w	4ae4 <__ieee754_rem_pio2f+0x218>
    4976:	eef5 6a40 	vcmp.f32	s13, #0.0
    497a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    497e:	bf0c      	ite	eq
    4980:	2301      	moveq	r3, #1
    4982:	2302      	movne	r3, #2
    4984:	4970      	ldr	r1, [pc, #448]	; (4b48 <__ieee754_rem_pio2f+0x27c>)
    4986:	9101      	str	r1, [sp, #4]
    4988:	2102      	movs	r1, #2
    498a:	9100      	str	r1, [sp, #0]
    498c:	a803      	add	r0, sp, #12
    498e:	4629      	mov	r1, r5
    4990:	f000 f96a 	bl	4c68 <__kernel_rem_pio2f>
    4994:	2e00      	cmp	r6, #0
    4996:	f2c0 8097 	blt.w	4ac8 <__ieee754_rem_pio2f+0x1fc>
    499a:	4603      	mov	r3, r0
    499c:	e004      	b.n	49a8 <__ieee754_rem_pio2f+0xdc>
    499e:	2200      	movs	r2, #0
    49a0:	ed80 0a00 	vstr	s0, [r0]
    49a4:	6042      	str	r2, [r0, #4]
    49a6:	2300      	movs	r3, #0
    49a8:	4618      	mov	r0, r3
    49aa:	b006      	add	sp, #24
    49ac:	bd70      	pop	{r4, r5, r6, pc}
    49ae:	ee70 7a40 	vsub.f32	s15, s0, s0
    49b2:	2300      	movs	r3, #0
    49b4:	edc0 7a01 	vstr	s15, [r0, #4]
    49b8:	edc0 7a00 	vstr	s15, [r0]
    49bc:	e7f4      	b.n	49a8 <__ieee754_rem_pio2f+0xdc>
    49be:	eddf 6a63 	vldr	s13, [pc, #396]	; 4b4c <__ieee754_rem_pio2f+0x280>
    49c2:	ed9f 7a63 	vldr	s14, [pc, #396]	; 4b50 <__ieee754_rem_pio2f+0x284>
    49c6:	ee77 7ae6 	vsub.f32	s15, s15, s13
    49ca:	2301      	movs	r3, #1
    49cc:	ee77 6ac7 	vsub.f32	s13, s15, s14
    49d0:	ee77 7ae6 	vsub.f32	s15, s15, s13
    49d4:	edc0 6a00 	vstr	s13, [r0]
    49d8:	ee77 7ac7 	vsub.f32	s15, s15, s14
    49dc:	edc0 7a01 	vstr	s15, [r0, #4]
    49e0:	e7e2      	b.n	49a8 <__ieee754_rem_pio2f+0xdc>
    49e2:	f000 fca3 	bl	532c <fabsf>
    49e6:	eddf 6a5b 	vldr	s13, [pc, #364]	; 4b54 <__ieee754_rem_pio2f+0x288>
    49ea:	eddf 5a52 	vldr	s11, [pc, #328]	; 4b34 <__ieee754_rem_pio2f+0x268>
    49ee:	ed9f 7a53 	vldr	s14, [pc, #332]	; 4b3c <__ieee754_rem_pio2f+0x270>
    49f2:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    49f6:	eee0 7a26 	vfma.f32	s15, s0, s13
    49fa:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    49fe:	ee17 3a90 	vmov	r3, s15
    4a02:	eef8 6ae7 	vcvt.f32.s32	s13, s15
    4a06:	2b1f      	cmp	r3, #31
    4a08:	eeb1 6a66 	vneg.f32	s12, s13
    4a0c:	eea6 0a25 	vfma.f32	s0, s12, s11
    4a10:	ee66 7a87 	vmul.f32	s15, s13, s14
    4a14:	dc1d      	bgt.n	4a52 <__ieee754_rem_pio2f+0x186>
    4a16:	4950      	ldr	r1, [pc, #320]	; (4b58 <__ieee754_rem_pio2f+0x28c>)
    4a18:	1e58      	subs	r0, r3, #1
    4a1a:	f024 02ff 	bic.w	r2, r4, #255	; 0xff
    4a1e:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
    4a22:	428a      	cmp	r2, r1
    4a24:	d015      	beq.n	4a52 <__ieee754_rem_pio2f+0x186>
    4a26:	ee30 7a67 	vsub.f32	s14, s0, s15
    4a2a:	ed85 7a00 	vstr	s14, [r5]
    4a2e:	ee30 0a47 	vsub.f32	s0, s0, s14
    4a32:	2e00      	cmp	r6, #0
    4a34:	ee30 0a67 	vsub.f32	s0, s0, s15
    4a38:	ed85 0a01 	vstr	s0, [r5, #4]
    4a3c:	dab4      	bge.n	49a8 <__ieee754_rem_pio2f+0xdc>
    4a3e:	eeb1 7a47 	vneg.f32	s14, s14
    4a42:	eeb1 0a40 	vneg.f32	s0, s0
    4a46:	ed85 7a00 	vstr	s14, [r5]
    4a4a:	ed85 0a01 	vstr	s0, [r5, #4]
    4a4e:	425b      	negs	r3, r3
    4a50:	e7aa      	b.n	49a8 <__ieee754_rem_pio2f+0xdc>
    4a52:	ee30 7a67 	vsub.f32	s14, s0, s15
    4a56:	15e4      	asrs	r4, r4, #23
    4a58:	ee17 2a10 	vmov	r2, s14
    4a5c:	f3c2 52c7 	ubfx	r2, r2, #23, #8
    4a60:	1aa2      	subs	r2, r4, r2
    4a62:	2a08      	cmp	r2, #8
    4a64:	dde1      	ble.n	4a2a <__ieee754_rem_pio2f+0x15e>
    4a66:	eddf 7a39 	vldr	s15, [pc, #228]	; 4b4c <__ieee754_rem_pio2f+0x280>
    4a6a:	ed9f 7a39 	vldr	s14, [pc, #228]	; 4b50 <__ieee754_rem_pio2f+0x284>
    4a6e:	eef0 5a40 	vmov.f32	s11, s0
    4a72:	eee6 5a27 	vfma.f32	s11, s12, s15
    4a76:	ee30 0a65 	vsub.f32	s0, s0, s11
    4a7a:	eea6 0a27 	vfma.f32	s0, s12, s15
    4a7e:	eef0 7a40 	vmov.f32	s15, s0
    4a82:	eed6 7a87 	vfnms.f32	s15, s13, s14
    4a86:	ee35 7ae7 	vsub.f32	s14, s11, s15
    4a8a:	ee17 2a10 	vmov	r2, s14
    4a8e:	f3c2 52c7 	ubfx	r2, r2, #23, #8
    4a92:	1aa4      	subs	r4, r4, r2
    4a94:	2c19      	cmp	r4, #25
    4a96:	dc3a      	bgt.n	4b0e <__ieee754_rem_pio2f+0x242>
    4a98:	ed85 7a00 	vstr	s14, [r5]
    4a9c:	eeb0 0a65 	vmov.f32	s0, s11
    4aa0:	e7c5      	b.n	4a2e <__ieee754_rem_pio2f+0x162>
    4aa2:	4294      	cmp	r4, r2
    4aa4:	ee70 7a27 	vadd.f32	s15, s0, s15
    4aa8:	d01e      	beq.n	4ae8 <__ieee754_rem_pio2f+0x21c>
    4aaa:	ed9f 7a24 	vldr	s14, [pc, #144]	; 4b3c <__ieee754_rem_pio2f+0x270>
    4aae:	ee77 6a87 	vadd.f32	s13, s15, s14
    4ab2:	f04f 33ff 	mov.w	r3, #4294967295
    4ab6:	ee77 7ae6 	vsub.f32	s15, s15, s13
    4aba:	edc0 6a00 	vstr	s13, [r0]
    4abe:	ee77 7a87 	vadd.f32	s15, s15, s14
    4ac2:	edc0 7a01 	vstr	s15, [r0, #4]
    4ac6:	e76f      	b.n	49a8 <__ieee754_rem_pio2f+0xdc>
    4ac8:	ed95 7a00 	vldr	s14, [r5]
    4acc:	edd5 7a01 	vldr	s15, [r5, #4]
    4ad0:	eeb1 7a47 	vneg.f32	s14, s14
    4ad4:	eef1 7a67 	vneg.f32	s15, s15
    4ad8:	4243      	negs	r3, r0
    4ada:	ed85 7a00 	vstr	s14, [r5]
    4ade:	edc5 7a01 	vstr	s15, [r5, #4]
    4ae2:	e761      	b.n	49a8 <__ieee754_rem_pio2f+0xdc>
    4ae4:	2303      	movs	r3, #3
    4ae6:	e74d      	b.n	4984 <__ieee754_rem_pio2f+0xb8>
    4ae8:	eddf 6a18 	vldr	s13, [pc, #96]	; 4b4c <__ieee754_rem_pio2f+0x280>
    4aec:	ed9f 7a18 	vldr	s14, [pc, #96]	; 4b50 <__ieee754_rem_pio2f+0x284>
    4af0:	ee77 7aa6 	vadd.f32	s15, s15, s13
    4af4:	f04f 33ff 	mov.w	r3, #4294967295
    4af8:	ee77 6a87 	vadd.f32	s13, s15, s14
    4afc:	ee77 7ae6 	vsub.f32	s15, s15, s13
    4b00:	edc0 6a00 	vstr	s13, [r0]
    4b04:	ee77 7a87 	vadd.f32	s15, s15, s14
    4b08:	edc0 7a01 	vstr	s15, [r0, #4]
    4b0c:	e74c      	b.n	49a8 <__ieee754_rem_pio2f+0xdc>
    4b0e:	ed9f 7a13 	vldr	s14, [pc, #76]	; 4b5c <__ieee754_rem_pio2f+0x290>
    4b12:	ed9f 5a13 	vldr	s10, [pc, #76]	; 4b60 <__ieee754_rem_pio2f+0x294>
    4b16:	eeb0 0a65 	vmov.f32	s0, s11
    4b1a:	eea6 0a07 	vfma.f32	s0, s12, s14
    4b1e:	ee75 7ac0 	vsub.f32	s15, s11, s0
    4b22:	eee6 7a07 	vfma.f32	s15, s12, s14
    4b26:	eed6 7a85 	vfnms.f32	s15, s13, s10
    4b2a:	e77c      	b.n	4a26 <__ieee754_rem_pio2f+0x15a>
    4b2c:	3f490fd8 	.word	0x3f490fd8
    4b30:	4016cbe3 	.word	0x4016cbe3
    4b34:	3fc90f80 	.word	0x3fc90f80
    4b38:	3fc90fd0 	.word	0x3fc90fd0
    4b3c:	37354443 	.word	0x37354443
    4b40:	43490f80 	.word	0x43490f80
    4b44:	43800000 	.word	0x43800000
    4b48:	00006c90 	.word	0x00006c90
    4b4c:	37354400 	.word	0x37354400
    4b50:	2e85a308 	.word	0x2e85a308
    4b54:	3f22f984 	.word	0x3f22f984
    4b58:	00006c10 	.word	0x00006c10
    4b5c:	2e85a300 	.word	0x2e85a300
    4b60:	248d3132 	.word	0x248d3132

00004b64 <__kernel_cosf>:
    4b64:	ee10 3a10 	vmov	r3, s0
    4b68:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    4b6c:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
    4b70:	da2c      	bge.n	4bcc <__kernel_cosf+0x68>
    4b72:	eefd 7ac0 	vcvt.s32.f32	s15, s0
    4b76:	ee17 3a90 	vmov	r3, s15
    4b7a:	2b00      	cmp	r3, #0
    4b7c:	d060      	beq.n	4c40 <__kernel_cosf+0xdc>
    4b7e:	ee20 7a00 	vmul.f32	s14, s0, s0
    4b82:	eddf 4a31 	vldr	s9, [pc, #196]	; 4c48 <__kernel_cosf+0xe4>
    4b86:	ed9f 5a31 	vldr	s10, [pc, #196]	; 4c4c <__kernel_cosf+0xe8>
    4b8a:	eddf 5a31 	vldr	s11, [pc, #196]	; 4c50 <__kernel_cosf+0xec>
    4b8e:	ed9f 6a31 	vldr	s12, [pc, #196]	; 4c54 <__kernel_cosf+0xf0>
    4b92:	eddf 7a31 	vldr	s15, [pc, #196]	; 4c58 <__kernel_cosf+0xf4>
    4b96:	eddf 6a31 	vldr	s13, [pc, #196]	; 4c5c <__kernel_cosf+0xf8>
    4b9a:	eea7 5a24 	vfma.f32	s10, s14, s9
    4b9e:	eee7 5a05 	vfma.f32	s11, s14, s10
    4ba2:	eea7 6a25 	vfma.f32	s12, s14, s11
    4ba6:	eee7 7a06 	vfma.f32	s15, s14, s12
    4baa:	eee7 6a27 	vfma.f32	s13, s14, s15
    4bae:	ee66 6a87 	vmul.f32	s13, s13, s14
    4bb2:	ee60 0ac0 	vnmul.f32	s1, s1, s0
    4bb6:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
    4bba:	eee7 0a26 	vfma.f32	s1, s14, s13
    4bbe:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    4bc2:	eed7 0a06 	vfnms.f32	s1, s14, s12
    4bc6:	ee37 0ae0 	vsub.f32	s0, s15, s1
    4bca:	4770      	bx	lr
    4bcc:	ee20 7a00 	vmul.f32	s14, s0, s0
    4bd0:	eddf 4a1d 	vldr	s9, [pc, #116]	; 4c48 <__kernel_cosf+0xe4>
    4bd4:	ed9f 5a1d 	vldr	s10, [pc, #116]	; 4c4c <__kernel_cosf+0xe8>
    4bd8:	eddf 5a1d 	vldr	s11, [pc, #116]	; 4c50 <__kernel_cosf+0xec>
    4bdc:	ed9f 6a1d 	vldr	s12, [pc, #116]	; 4c54 <__kernel_cosf+0xf0>
    4be0:	eddf 7a1d 	vldr	s15, [pc, #116]	; 4c58 <__kernel_cosf+0xf4>
    4be4:	eddf 6a1d 	vldr	s13, [pc, #116]	; 4c5c <__kernel_cosf+0xf8>
    4be8:	4a1d      	ldr	r2, [pc, #116]	; (4c60 <__kernel_cosf+0xfc>)
    4bea:	eea7 5a24 	vfma.f32	s10, s14, s9
    4bee:	4293      	cmp	r3, r2
    4bf0:	eee7 5a05 	vfma.f32	s11, s14, s10
    4bf4:	eea7 6a25 	vfma.f32	s12, s14, s11
    4bf8:	eee7 7a06 	vfma.f32	s15, s14, s12
    4bfc:	eee7 6a27 	vfma.f32	s13, s14, s15
    4c00:	ee66 6a87 	vmul.f32	s13, s13, s14
    4c04:	ddd5      	ble.n	4bb2 <__kernel_cosf+0x4e>
    4c06:	4a17      	ldr	r2, [pc, #92]	; (4c64 <__kernel_cosf+0x100>)
    4c08:	4293      	cmp	r3, r2
    4c0a:	dc14      	bgt.n	4c36 <__kernel_cosf+0xd2>
    4c0c:	f103 437f 	add.w	r3, r3, #4278190080	; 0xff000000
    4c10:	ee07 3a90 	vmov	s15, r3
    4c14:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    4c18:	ee36 6a67 	vsub.f32	s12, s12, s15
    4c1c:	ee60 0ac0 	vnmul.f32	s1, s1, s0
    4c20:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5
    4c24:	eee7 0a26 	vfma.f32	s1, s14, s13
    4c28:	eed7 7a25 	vfnms.f32	s15, s14, s11
    4c2c:	ee77 7ae0 	vsub.f32	s15, s15, s1
    4c30:	ee36 0a67 	vsub.f32	s0, s12, s15
    4c34:	4770      	bx	lr
    4c36:	eeb6 6a07 	vmov.f32	s12, #103	; 0x3f380000  0.7187500
    4c3a:	eef5 7a02 	vmov.f32	s15, #82	; 0x3e900000  0.2812500
    4c3e:	e7ed      	b.n	4c1c <__kernel_cosf+0xb8>
    4c40:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    4c44:	4770      	bx	lr
    4c46:	bf00      	nop
    4c48:	ad47d74e 	.word	0xad47d74e
    4c4c:	310f74f6 	.word	0x310f74f6
    4c50:	b493f27c 	.word	0xb493f27c
    4c54:	37d00d01 	.word	0x37d00d01
    4c58:	bab60b61 	.word	0xbab60b61
    4c5c:	3d2aaaab 	.word	0x3d2aaaab
    4c60:	3e999999 	.word	0x3e999999
    4c64:	3f480000 	.word	0x3f480000

00004c68 <__kernel_rem_pio2f>:
    4c68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4c6c:	ed2d 8b04 	vpush	{d8-d9}
    4c70:	b0d7      	sub	sp, #348	; 0x15c
    4c72:	1e5f      	subs	r7, r3, #1
    4c74:	4ca4      	ldr	r4, [pc, #656]	; (4f08 <__kernel_rem_pio2f+0x2a0>)
    4c76:	9d64      	ldr	r5, [sp, #400]	; 0x190
    4c78:	9301      	str	r3, [sp, #4]
    4c7a:	1ed3      	subs	r3, r2, #3
    4c7c:	bf48      	it	mi
    4c7e:	1d13      	addmi	r3, r2, #4
    4c80:	f854 6025 	ldr.w	r6, [r4, r5, lsl #2]
    4c84:	10db      	asrs	r3, r3, #3
    4c86:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    4c8a:	f103 0a01 	add.w	sl, r3, #1
    4c8e:	468b      	mov	fp, r1
    4c90:	19f1      	adds	r1, r6, r7
    4c92:	9302      	str	r3, [sp, #8]
    4c94:	4681      	mov	r9, r0
    4c96:	eba2 0aca 	sub.w	sl, r2, sl, lsl #3
    4c9a:	eba3 0307 	sub.w	r3, r3, r7
    4c9e:	d414      	bmi.n	4cca <__kernel_rem_pio2f+0x62>
    4ca0:	4419      	add	r1, r3
    4ca2:	9865      	ldr	r0, [sp, #404]	; 0x194
    4ca4:	3101      	adds	r1, #1
    4ca6:	aa1a      	add	r2, sp, #104	; 0x68
    4ca8:	2b00      	cmp	r3, #0
    4caa:	bfaa      	itet	ge
    4cac:	f850 4023 	ldrge.w	r4, [r0, r3, lsl #2]
    4cb0:	eddf 7a96 	vldrlt	s15, [pc, #600]	; 4f0c <__kernel_rem_pio2f+0x2a4>
    4cb4:	ee07 4a90 	vmovge	s15, r4
    4cb8:	f103 0301 	add.w	r3, r3, #1
    4cbc:	bfa8      	it	ge
    4cbe:	eef8 7ae7 	vcvtge.f32.s32	s15, s15
    4cc2:	428b      	cmp	r3, r1
    4cc4:	ece2 7a01 	vstmia	r2!, {s15}
    4cc8:	d1ee      	bne.n	4ca8 <__kernel_rem_pio2f+0x40>
    4cca:	2e00      	cmp	r6, #0
    4ccc:	f2c0 82d4 	blt.w	5278 <__kernel_rem_pio2f+0x610>
    4cd0:	9b01      	ldr	r3, [sp, #4]
    4cd2:	a842      	add	r0, sp, #264	; 0x108
    4cd4:	f106 0e01 	add.w	lr, r6, #1
    4cd8:	009c      	lsls	r4, r3, #2
    4cda:	eb00 0e8e 	add.w	lr, r0, lr, lsl #2
    4cde:	eb09 0104 	add.w	r1, r9, r4
    4ce2:	463d      	mov	r5, r7
    4ce4:	2f00      	cmp	r7, #0
    4ce6:	f2c0 81bf 	blt.w	5068 <__kernel_rem_pio2f+0x400>
    4cea:	ab1a      	add	r3, sp, #104	; 0x68
    4cec:	eb03 0285 	add.w	r2, r3, r5, lsl #2
    4cf0:	eddf 7a86 	vldr	s15, [pc, #536]	; 4f0c <__kernel_rem_pio2f+0x2a4>
    4cf4:	3204      	adds	r2, #4
    4cf6:	464b      	mov	r3, r9
    4cf8:	ecf3 6a01 	vldmia	r3!, {s13}
    4cfc:	ed32 7a01 	vldmdb	r2!, {s14}
    4d00:	428b      	cmp	r3, r1
    4d02:	eee6 7a87 	vfma.f32	s15, s13, s14
    4d06:	d1f7      	bne.n	4cf8 <__kernel_rem_pio2f+0x90>
    4d08:	ece0 7a01 	vstmia	r0!, {s15}
    4d0c:	4570      	cmp	r0, lr
    4d0e:	f105 0501 	add.w	r5, r5, #1
    4d12:	d1e7      	bne.n	4ce4 <__kernel_rem_pio2f+0x7c>
    4d14:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
    4d18:	3b02      	subs	r3, #2
    4d1a:	009b      	lsls	r3, r3, #2
    4d1c:	aa06      	add	r2, sp, #24
    4d1e:	f103 0804 	add.w	r8, r3, #4
    4d22:	eddf 8a7c 	vldr	s17, [pc, #496]	; 4f14 <__kernel_rem_pio2f+0x2ac>
    4d26:	ed9f 8a7a 	vldr	s16, [pc, #488]	; 4f10 <__kernel_rem_pio2f+0x2a8>
    4d2a:	f8cd b010 	str.w	fp, [sp, #16]
    4d2e:	4413      	add	r3, r2
    4d30:	444c      	add	r4, r9
    4d32:	4490      	add	r8, r2
    4d34:	9303      	str	r3, [sp, #12]
    4d36:	4635      	mov	r5, r6
    4d38:	ab56      	add	r3, sp, #344	; 0x158
    4d3a:	eb03 0385 	add.w	r3, r3, r5, lsl #2
    4d3e:	2d00      	cmp	r5, #0
    4d40:	ed13 0a14 	vldr	s0, [r3, #-80]	; 0xffffffb0
    4d44:	dd19      	ble.n	4d7a <__kernel_rem_pio2f+0x112>
    4d46:	a942      	add	r1, sp, #264	; 0x108
    4d48:	eb01 0385 	add.w	r3, r1, r5, lsl #2
    4d4c:	aa05      	add	r2, sp, #20
    4d4e:	ee60 7a28 	vmul.f32	s15, s0, s17
    4d52:	eeb0 7a40 	vmov.f32	s14, s0
    4d56:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    4d5a:	ed73 6a01 	vldmdb	r3!, {s13}
    4d5e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    4d62:	428b      	cmp	r3, r1
    4d64:	eea7 7ac8 	vfms.f32	s14, s15, s16
    4d68:	ee37 0aa6 	vadd.f32	s0, s15, s13
    4d6c:	eebd 7ac7 	vcvt.s32.f32	s14, s14
    4d70:	ee17 0a10 	vmov	r0, s14
    4d74:	f842 0f04 	str.w	r0, [r2, #4]!
    4d78:	d1e9      	bne.n	4d4e <__kernel_rem_pio2f+0xe6>
    4d7a:	4650      	mov	r0, sl
    4d7c:	f000 fb26 	bl	53cc <scalbnf>
    4d80:	eeb0 9a40 	vmov.f32	s18, s0
    4d84:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
    4d88:	ee29 0a00 	vmul.f32	s0, s18, s0
    4d8c:	f000 fad6 	bl	533c <floorf>
    4d90:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
    4d94:	eea0 9a67 	vfms.f32	s18, s0, s15
    4d98:	f1ba 0f00 	cmp.w	sl, #0
    4d9c:	eefd 7ac9 	vcvt.s32.f32	s15, s18
    4da0:	ee17 ba90 	vmov	fp, s15
    4da4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    4da8:	ee39 9a67 	vsub.f32	s18, s18, s15
    4dac:	f340 8141 	ble.w	5032 <__kernel_rem_pio2f+0x3ca>
    4db0:	f105 3eff 	add.w	lr, r5, #4294967295
    4db4:	ab06      	add	r3, sp, #24
    4db6:	f1ca 0208 	rsb	r2, sl, #8
    4dba:	f853 302e 	ldr.w	r3, [r3, lr, lsl #2]
    4dbe:	fa43 f002 	asr.w	r0, r3, r2
    4dc2:	fa00 f202 	lsl.w	r2, r0, r2
    4dc6:	a906      	add	r1, sp, #24
    4dc8:	1a9b      	subs	r3, r3, r2
    4dca:	f1ca 0207 	rsb	r2, sl, #7
    4dce:	f841 302e 	str.w	r3, [r1, lr, lsl #2]
    4dd2:	4483      	add	fp, r0
    4dd4:	fa43 f102 	asr.w	r1, r3, r2
    4dd8:	2900      	cmp	r1, #0
    4dda:	dd37      	ble.n	4e4c <__kernel_rem_pio2f+0x1e4>
    4ddc:	2d00      	cmp	r5, #0
    4dde:	f10b 0b01 	add.w	fp, fp, #1
    4de2:	f340 8224 	ble.w	522e <__kernel_rem_pio2f+0x5c6>
    4de6:	2200      	movs	r2, #0
    4de8:	4610      	mov	r0, r2
    4dea:	f10d 0e14 	add.w	lr, sp, #20
    4dee:	468c      	mov	ip, r1
    4df0:	e008      	b.n	4e04 <__kernel_rem_pio2f+0x19c>
    4df2:	f5c3 7180 	rsb	r1, r3, #256	; 0x100
    4df6:	b113      	cbz	r3, 4dfe <__kernel_rem_pio2f+0x196>
    4df8:	f8ce 1000 	str.w	r1, [lr]
    4dfc:	2001      	movs	r0, #1
    4dfe:	3201      	adds	r2, #1
    4e00:	4295      	cmp	r5, r2
    4e02:	dd0c      	ble.n	4e1e <__kernel_rem_pio2f+0x1b6>
    4e04:	f85e 3f04 	ldr.w	r3, [lr, #4]!
    4e08:	2800      	cmp	r0, #0
    4e0a:	d0f2      	beq.n	4df2 <__kernel_rem_pio2f+0x18a>
    4e0c:	3201      	adds	r2, #1
    4e0e:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
    4e12:	4295      	cmp	r5, r2
    4e14:	f8ce 3000 	str.w	r3, [lr]
    4e18:	f04f 0001 	mov.w	r0, #1
    4e1c:	dcf2      	bgt.n	4e04 <__kernel_rem_pio2f+0x19c>
    4e1e:	4661      	mov	r1, ip
    4e20:	f1ba 0f00 	cmp.w	sl, #0
    4e24:	dd10      	ble.n	4e48 <__kernel_rem_pio2f+0x1e0>
    4e26:	f1ba 0f01 	cmp.w	sl, #1
    4e2a:	f000 8109 	beq.w	5040 <__kernel_rem_pio2f+0x3d8>
    4e2e:	f1ba 0f02 	cmp.w	sl, #2
    4e32:	d109      	bne.n	4e48 <__kernel_rem_pio2f+0x1e0>
    4e34:	1e6a      	subs	r2, r5, #1
    4e36:	ab06      	add	r3, sp, #24
    4e38:	f10d 0e18 	add.w	lr, sp, #24
    4e3c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    4e40:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    4e44:	f84e 3022 	str.w	r3, [lr, r2, lsl #2]
    4e48:	2902      	cmp	r1, #2
    4e4a:	d065      	beq.n	4f18 <__kernel_rem_pio2f+0x2b0>
    4e4c:	eeb5 9a40 	vcmp.f32	s18, #0.0
    4e50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4e54:	d172      	bne.n	4f3c <__kernel_rem_pio2f+0x2d4>
    4e56:	f105 3eff 	add.w	lr, r5, #4294967295
    4e5a:	4576      	cmp	r6, lr
    4e5c:	dc0f      	bgt.n	4e7e <__kernel_rem_pio2f+0x216>
    4e5e:	f105 4280 	add.w	r2, r5, #1073741824	; 0x40000000
    4e62:	3a01      	subs	r2, #1
    4e64:	ab06      	add	r3, sp, #24
    4e66:	eb03 0282 	add.w	r2, r3, r2, lsl #2
    4e6a:	2000      	movs	r0, #0
    4e6c:	f852 3904 	ldr.w	r3, [r2], #-4
    4e70:	4542      	cmp	r2, r8
    4e72:	ea40 0003 	orr.w	r0, r0, r3
    4e76:	d1f9      	bne.n	4e6c <__kernel_rem_pio2f+0x204>
    4e78:	2800      	cmp	r0, #0
    4e7a:	f040 810c 	bne.w	5096 <__kernel_rem_pio2f+0x42e>
    4e7e:	1e73      	subs	r3, r6, #1
    4e80:	aa06      	add	r2, sp, #24
    4e82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4e86:	2b00      	cmp	r3, #0
    4e88:	f040 81ce 	bne.w	5228 <__kernel_rem_pio2f+0x5c0>
    4e8c:	9b03      	ldr	r3, [sp, #12]
    4e8e:	f04f 0e01 	mov.w	lr, #1
    4e92:	f853 2904 	ldr.w	r2, [r3], #-4
    4e96:	f10e 0e01 	add.w	lr, lr, #1
    4e9a:	2a00      	cmp	r2, #0
    4e9c:	d0f9      	beq.n	4e92 <__kernel_rem_pio2f+0x22a>
    4e9e:	44ae      	add	lr, r5
    4ea0:	1c6b      	adds	r3, r5, #1
    4ea2:	4573      	cmp	r3, lr
    4ea4:	dc2d      	bgt.n	4f02 <__kernel_rem_pio2f+0x29a>
    4ea6:	9a02      	ldr	r2, [sp, #8]
    4ea8:	1898      	adds	r0, r3, r2
    4eaa:	9a01      	ldr	r2, [sp, #4]
    4eac:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    4eb0:	1951      	adds	r1, r2, r5
    4eb2:	eb0e 0c02 	add.w	ip, lr, r2
    4eb6:	9a65      	ldr	r2, [sp, #404]	; 0x194
    4eb8:	3801      	subs	r0, #1
    4eba:	eb02 0080 	add.w	r0, r2, r0, lsl #2
    4ebe:	aa1a      	add	r2, sp, #104	; 0x68
    4ec0:	eb02 0181 	add.w	r1, r2, r1, lsl #2
    4ec4:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
    4ec8:	aa42      	add	r2, sp, #264	; 0x108
    4eca:	eb02 0583 	add.w	r5, r2, r3, lsl #2
    4ece:	f850 3f04 	ldr.w	r3, [r0, #4]!
    4ed2:	ee07 3a90 	vmov	s15, r3
    4ed6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    4eda:	2f00      	cmp	r7, #0
    4edc:	ece1 7a01 	vstmia	r1!, {s15}
    4ee0:	eddf 7a0a 	vldr	s15, [pc, #40]	; 4f0c <__kernel_rem_pio2f+0x2a4>
    4ee4:	db09      	blt.n	4efa <__kernel_rem_pio2f+0x292>
    4ee6:	464b      	mov	r3, r9
    4ee8:	460a      	mov	r2, r1
    4eea:	ecf3 6a01 	vldmia	r3!, {s13}
    4eee:	ed32 7a01 	vldmdb	r2!, {s14}
    4ef2:	42a3      	cmp	r3, r4
    4ef4:	eee6 7a87 	vfma.f32	s15, s13, s14
    4ef8:	d1f7      	bne.n	4eea <__kernel_rem_pio2f+0x282>
    4efa:	4561      	cmp	r1, ip
    4efc:	ece5 7a01 	vstmia	r5!, {s15}
    4f00:	d1e5      	bne.n	4ece <__kernel_rem_pio2f+0x266>
    4f02:	4675      	mov	r5, lr
    4f04:	e718      	b.n	4d38 <__kernel_rem_pio2f+0xd0>
    4f06:	bf00      	nop
    4f08:	00006fa8 	.word	0x00006fa8
    4f0c:	00000000 	.word	0x00000000
    4f10:	43800000 	.word	0x43800000
    4f14:	3b800000 	.word	0x3b800000
    4f18:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    4f1c:	ee30 9a49 	vsub.f32	s18, s0, s18
    4f20:	2800      	cmp	r0, #0
    4f22:	d093      	beq.n	4e4c <__kernel_rem_pio2f+0x1e4>
    4f24:	4650      	mov	r0, sl
    4f26:	9105      	str	r1, [sp, #20]
    4f28:	f000 fa50 	bl	53cc <scalbnf>
    4f2c:	ee39 9a40 	vsub.f32	s18, s18, s0
    4f30:	9905      	ldr	r1, [sp, #20]
    4f32:	eeb5 9a40 	vcmp.f32	s18, #0.0
    4f36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4f3a:	d08c      	beq.n	4e56 <__kernel_rem_pio2f+0x1ee>
    4f3c:	eeb0 0a49 	vmov.f32	s0, s18
    4f40:	f1ca 0000 	rsb	r0, sl, #0
    4f44:	ee09 ba90 	vmov	s19, fp
    4f48:	4688      	mov	r8, r1
    4f4a:	f8dd b010 	ldr.w	fp, [sp, #16]
    4f4e:	f000 fa3d 	bl	53cc <scalbnf>
    4f52:	ed1f 7a11 	vldr	s14, [pc, #-68]	; 4f10 <__kernel_rem_pio2f+0x2a8>
    4f56:	eeb4 0ac7 	vcmpe.f32	s0, s14
    4f5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    4f5e:	f2c0 8171 	blt.w	5244 <__kernel_rem_pio2f+0x5dc>
    4f62:	ed5f 7a14 	vldr	s15, [pc, #-80]	; 4f14 <__kernel_rem_pio2f+0x2ac>
    4f66:	ee60 7a27 	vmul.f32	s15, s0, s15
    4f6a:	a906      	add	r1, sp, #24
    4f6c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    4f70:	1c6b      	adds	r3, r5, #1
    4f72:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    4f76:	f10a 0a08 	add.w	sl, sl, #8
    4f7a:	eea7 0ac7 	vfms.f32	s0, s15, s14
    4f7e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    4f82:	eebd 0ac0 	vcvt.s32.f32	s0, s0
    4f86:	ee10 2a10 	vmov	r2, s0
    4f8a:	f841 2025 	str.w	r2, [r1, r5, lsl #2]
    4f8e:	ee17 2a90 	vmov	r2, s15
    4f92:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    4f96:	4650      	mov	r0, sl
    4f98:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    4f9c:	9301      	str	r3, [sp, #4]
    4f9e:	f000 fa15 	bl	53cc <scalbnf>
    4fa2:	9b01      	ldr	r3, [sp, #4]
    4fa4:	2b00      	cmp	r3, #0
    4fa6:	f2c0 8159 	blt.w	525c <__kernel_rem_pio2f+0x5f4>
    4faa:	009f      	lsls	r7, r3, #2
    4fac:	ac42      	add	r4, sp, #264	; 0x108
    4fae:	aa06      	add	r2, sp, #24
    4fb0:	1d38      	adds	r0, r7, #4
    4fb2:	eb04 0e07 	add.w	lr, r4, r7
    4fb6:	ed1f 7a29 	vldr	s14, [pc, #-164]	; 4f14 <__kernel_rem_pio2f+0x2ac>
    4fba:	4410      	add	r0, r2
    4fbc:	f10e 0204 	add.w	r2, lr, #4
    4fc0:	ed70 7a01 	vldmdb	r0!, {s15}
    4fc4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    4fc8:	ee67 7a80 	vmul.f32	s15, s15, s0
    4fcc:	ee20 0a07 	vmul.f32	s0, s0, s14
    4fd0:	ed62 7a01 	vstmdb	r2!, {s15}
    4fd4:	42a2      	cmp	r2, r4
    4fd6:	d1f3      	bne.n	4fc0 <__kernel_rem_pio2f+0x358>
    4fd8:	f50d 7c82 	add.w	ip, sp, #260	; 0x104
    4fdc:	2500      	movs	r5, #0
    4fde:	2e00      	cmp	r6, #0
    4fe0:	f2c0 8114 	blt.w	520c <__kernel_rem_pio2f+0x5a4>
    4fe4:	48a9      	ldr	r0, [pc, #676]	; (528c <__kernel_rem_pio2f+0x624>)
    4fe6:	ed9f 7aaa 	vldr	s14, [pc, #680]	; 5290 <__kernel_rem_pio2f+0x628>
    4fea:	eddf 7aaa 	vldr	s15, [pc, #680]	; 5294 <__kernel_rem_pio2f+0x62c>
    4fee:	4671      	mov	r1, lr
    4ff0:	2200      	movs	r2, #0
    4ff2:	e004      	b.n	4ffe <__kernel_rem_pio2f+0x396>
    4ff4:	4295      	cmp	r5, r2
    4ff6:	db09      	blt.n	500c <__kernel_rem_pio2f+0x3a4>
    4ff8:	3004      	adds	r0, #4
    4ffa:	ed90 7a00 	vldr	s14, [r0]
    4ffe:	ecf1 6a01 	vldmia	r1!, {s13}
    5002:	3201      	adds	r2, #1
    5004:	4296      	cmp	r6, r2
    5006:	eee6 7a87 	vfma.f32	s15, s13, s14
    500a:	daf3      	bge.n	4ff4 <__kernel_rem_pio2f+0x38c>
    500c:	f1ae 0e04 	sub.w	lr, lr, #4
    5010:	aa56      	add	r2, sp, #344	; 0x158
    5012:	eb02 0285 	add.w	r2, r2, r5, lsl #2
    5016:	45f4      	cmp	ip, lr
    5018:	ed42 7a28 	vstr	s15, [r2, #-160]	; 0xffffff60
    501c:	f105 0501 	add.w	r5, r5, #1
    5020:	d1dd      	bne.n	4fde <__kernel_rem_pio2f+0x376>
    5022:	9a64      	ldr	r2, [sp, #400]	; 0x190
    5024:	2a03      	cmp	r2, #3
    5026:	f200 80ae 	bhi.w	5186 <__kernel_rem_pio2f+0x51e>
    502a:	e8df f002 	tbb	[pc, r2]
    502e:	b5dc      	.short	0xb5dc
    5030:	50b5      	.short	0x50b5
    5032:	d110      	bne.n	5056 <__kernel_rem_pio2f+0x3ee>
    5034:	1e6b      	subs	r3, r5, #1
    5036:	aa06      	add	r2, sp, #24
    5038:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    503c:	1209      	asrs	r1, r1, #8
    503e:	e6cb      	b.n	4dd8 <__kernel_rem_pio2f+0x170>
    5040:	1e6a      	subs	r2, r5, #1
    5042:	ab06      	add	r3, sp, #24
    5044:	f10d 0e18 	add.w	lr, sp, #24
    5048:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    504c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    5050:	f84e 3022 	str.w	r3, [lr, r2, lsl #2]
    5054:	e6f8      	b.n	4e48 <__kernel_rem_pio2f+0x1e0>
    5056:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    505a:	eeb4 9ae7 	vcmpe.f32	s18, s15
    505e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5062:	da0b      	bge.n	507c <__kernel_rem_pio2f+0x414>
    5064:	2100      	movs	r1, #0
    5066:	e6f1      	b.n	4e4c <__kernel_rem_pio2f+0x1e4>
    5068:	eddf 7a8a 	vldr	s15, [pc, #552]	; 5294 <__kernel_rem_pio2f+0x62c>
    506c:	ece0 7a01 	vstmia	r0!, {s15}
    5070:	4570      	cmp	r0, lr
    5072:	f105 0501 	add.w	r5, r5, #1
    5076:	f47f ae35 	bne.w	4ce4 <__kernel_rem_pio2f+0x7c>
    507a:	e64b      	b.n	4d14 <__kernel_rem_pio2f+0xac>
    507c:	2d00      	cmp	r5, #0
    507e:	f10b 0b01 	add.w	fp, fp, #1
    5082:	bfc8      	it	gt
    5084:	2102      	movgt	r1, #2
    5086:	f73f aeae 	bgt.w	4de6 <__kernel_rem_pio2f+0x17e>
    508a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    508e:	ee37 9ac9 	vsub.f32	s18, s15, s18
    5092:	2102      	movs	r1, #2
    5094:	e6da      	b.n	4e4c <__kernel_rem_pio2f+0x1e4>
    5096:	aa06      	add	r2, sp, #24
    5098:	ee09 ba90 	vmov	s19, fp
    509c:	f852 202e 	ldr.w	r2, [r2, lr, lsl #2]
    50a0:	f8dd b010 	ldr.w	fp, [sp, #16]
    50a4:	4673      	mov	r3, lr
    50a6:	4688      	mov	r8, r1
    50a8:	f1aa 0a08 	sub.w	sl, sl, #8
    50ac:	2a00      	cmp	r2, #0
    50ae:	f47f af72 	bne.w	4f96 <__kernel_rem_pio2f+0x32e>
    50b2:	f10e 4280 	add.w	r2, lr, #1073741824	; 0x40000000
    50b6:	3a01      	subs	r2, #1
    50b8:	a906      	add	r1, sp, #24
    50ba:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    50be:	f852 1904 	ldr.w	r1, [r2], #-4
    50c2:	3b01      	subs	r3, #1
    50c4:	f1aa 0a08 	sub.w	sl, sl, #8
    50c8:	2900      	cmp	r1, #0
    50ca:	d0f8      	beq.n	50be <__kernel_rem_pio2f+0x456>
    50cc:	e763      	b.n	4f96 <__kernel_rem_pio2f+0x32e>
    50ce:	2b00      	cmp	r3, #0
    50d0:	f340 80c1 	ble.w	5256 <__kernel_rem_pio2f+0x5ee>
    50d4:	f103 4280 	add.w	r2, r3, #1073741824	; 0x40000000
    50d8:	3a01      	subs	r2, #1
    50da:	0090      	lsls	r0, r2, #2
    50dc:	a956      	add	r1, sp, #344	; 0x158
    50de:	19cd      	adds	r5, r1, r7
    50e0:	1d04      	adds	r4, r0, #4
    50e2:	a92e      	add	r1, sp, #184	; 0xb8
    50e4:	3008      	adds	r0, #8
    50e6:	ed15 7a28 	vldr	s14, [r5, #-160]	; 0xffffff60
    50ea:	440c      	add	r4, r1
    50ec:	4408      	add	r0, r1
    50ee:	ad2f      	add	r5, sp, #188	; 0xbc
    50f0:	ed74 7a01 	vldmdb	r4!, {s15}
    50f4:	ee77 6a87 	vadd.f32	s13, s15, s14
    50f8:	ee77 7ae6 	vsub.f32	s15, s15, s13
    50fc:	ee77 7a87 	vadd.f32	s15, s15, s14
    5100:	eeb0 7a66 	vmov.f32	s14, s13
    5104:	ed60 7a01 	vstmdb	r0!, {s15}
    5108:	42a8      	cmp	r0, r5
    510a:	edc4 6a00 	vstr	s13, [r4]
    510e:	d1ef      	bne.n	50f0 <__kernel_rem_pio2f+0x488>
    5110:	2b01      	cmp	r3, #1
    5112:	f340 80a0 	ble.w	5256 <__kernel_rem_pio2f+0x5ee>
    5116:	0092      	lsls	r2, r2, #2
    5118:	ab56      	add	r3, sp, #344	; 0x158
    511a:	441f      	add	r7, r3
    511c:	f102 0008 	add.w	r0, r2, #8
    5120:	ab2e      	add	r3, sp, #184	; 0xb8
    5122:	4418      	add	r0, r3
    5124:	3204      	adds	r2, #4
    5126:	ed17 7a28 	vldr	s14, [r7, #-160]	; 0xffffff60
    512a:	4413      	add	r3, r2
    512c:	ac30      	add	r4, sp, #192	; 0xc0
    512e:	4602      	mov	r2, r0
    5130:	ed73 7a01 	vldmdb	r3!, {s15}
    5134:	ee77 6a27 	vadd.f32	s13, s14, s15
    5138:	ee77 7ae6 	vsub.f32	s15, s15, s13
    513c:	ee77 7a87 	vadd.f32	s15, s15, s14
    5140:	eeb0 7a66 	vmov.f32	s14, s13
    5144:	ed62 7a01 	vstmdb	r2!, {s15}
    5148:	4294      	cmp	r4, r2
    514a:	edc3 6a00 	vstr	s13, [r3]
    514e:	d1ef      	bne.n	5130 <__kernel_rem_pio2f+0x4c8>
    5150:	eddf 7a50 	vldr	s15, [pc, #320]	; 5294 <__kernel_rem_pio2f+0x62c>
    5154:	ed30 7a01 	vldmdb	r0!, {s14}
    5158:	4284      	cmp	r4, r0
    515a:	ee77 7a87 	vadd.f32	s15, s15, s14
    515e:	d1f9      	bne.n	5154 <__kernel_rem_pio2f+0x4ec>
    5160:	4643      	mov	r3, r8
    5162:	2b00      	cmp	r3, #0
    5164:	d065      	beq.n	5232 <__kernel_rem_pio2f+0x5ca>
    5166:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
    516a:	ed9d 7a2f 	vldr	s14, [sp, #188]	; 0xbc
    516e:	eef1 7a67 	vneg.f32	s15, s15
    5172:	eef1 6a66 	vneg.f32	s13, s13
    5176:	eeb1 7a47 	vneg.f32	s14, s14
    517a:	edcb 7a02 	vstr	s15, [fp, #8]
    517e:	edcb 6a00 	vstr	s13, [fp]
    5182:	ed8b 7a01 	vstr	s14, [fp, #4]
    5186:	ee19 3a90 	vmov	r3, s19
    518a:	f003 0007 	and.w	r0, r3, #7
    518e:	b057      	add	sp, #348	; 0x15c
    5190:	ecbd 8b04 	vpop	{d8-d9}
    5194:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5198:	1d3a      	adds	r2, r7, #4
    519a:	a82e      	add	r0, sp, #184	; 0xb8
    519c:	eddf 7a3d 	vldr	s15, [pc, #244]	; 5294 <__kernel_rem_pio2f+0x62c>
    51a0:	4402      	add	r2, r0
    51a2:	ed32 7a01 	vldmdb	r2!, {s14}
    51a6:	4282      	cmp	r2, r0
    51a8:	ee77 7a87 	vadd.f32	s15, s15, s14
    51ac:	d1f9      	bne.n	51a2 <__kernel_rem_pio2f+0x53a>
    51ae:	4642      	mov	r2, r8
    51b0:	b37a      	cbz	r2, 5212 <__kernel_rem_pio2f+0x5aa>
    51b2:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
    51b6:	eeb1 7a67 	vneg.f32	s14, s15
    51ba:	2b00      	cmp	r3, #0
    51bc:	ee76 7ae7 	vsub.f32	s15, s13, s15
    51c0:	ed8b 7a00 	vstr	s14, [fp]
    51c4:	dd0a      	ble.n	51dc <__kernel_rem_pio2f+0x574>
    51c6:	a82f      	add	r0, sp, #188	; 0xbc
    51c8:	2201      	movs	r2, #1
    51ca:	ecb0 7a01 	vldmia	r0!, {s14}
    51ce:	3201      	adds	r2, #1
    51d0:	4293      	cmp	r3, r2
    51d2:	ee77 7a87 	vadd.f32	s15, s15, s14
    51d6:	daf8      	bge.n	51ca <__kernel_rem_pio2f+0x562>
    51d8:	4643      	mov	r3, r8
    51da:	b10b      	cbz	r3, 51e0 <__kernel_rem_pio2f+0x578>
    51dc:	eef1 7a67 	vneg.f32	s15, s15
    51e0:	edcb 7a01 	vstr	s15, [fp, #4]
    51e4:	e7cf      	b.n	5186 <__kernel_rem_pio2f+0x51e>
    51e6:	aa56      	add	r2, sp, #344	; 0x158
    51e8:	443a      	add	r2, r7
    51ea:	eddf 7a2a 	vldr	s15, [pc, #168]	; 5294 <__kernel_rem_pio2f+0x62c>
    51ee:	3a9c      	subs	r2, #156	; 0x9c
    51f0:	ed32 7a01 	vldmdb	r2!, {s14}
    51f4:	3b01      	subs	r3, #1
    51f6:	1c59      	adds	r1, r3, #1
    51f8:	ee77 7a87 	vadd.f32	s15, s15, s14
    51fc:	d1f8      	bne.n	51f0 <__kernel_rem_pio2f+0x588>
    51fe:	4643      	mov	r3, r8
    5200:	b10b      	cbz	r3, 5206 <__kernel_rem_pio2f+0x59e>
    5202:	eef1 7a67 	vneg.f32	s15, s15
    5206:	edcb 7a00 	vstr	s15, [fp]
    520a:	e7bc      	b.n	5186 <__kernel_rem_pio2f+0x51e>
    520c:	eddf 7a21 	vldr	s15, [pc, #132]	; 5294 <__kernel_rem_pio2f+0x62c>
    5210:	e6fc      	b.n	500c <__kernel_rem_pio2f+0x3a4>
    5212:	ed9d 7a2e 	vldr	s14, [sp, #184]	; 0xb8
    5216:	edcb 7a00 	vstr	s15, [fp]
    521a:	2b00      	cmp	r3, #0
    521c:	ee77 7a67 	vsub.f32	s15, s14, s15
    5220:	dcd1      	bgt.n	51c6 <__kernel_rem_pio2f+0x55e>
    5222:	edcb 7a01 	vstr	s15, [fp, #4]
    5226:	e7ae      	b.n	5186 <__kernel_rem_pio2f+0x51e>
    5228:	f04f 0e01 	mov.w	lr, #1
    522c:	e637      	b.n	4e9e <__kernel_rem_pio2f+0x236>
    522e:	2000      	movs	r0, #0
    5230:	e5f6      	b.n	4e20 <__kernel_rem_pio2f+0x1b8>
    5232:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
    5234:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
    5236:	edcb 7a02 	vstr	s15, [fp, #8]
    523a:	f8cb 2000 	str.w	r2, [fp]
    523e:	f8cb 3004 	str.w	r3, [fp, #4]
    5242:	e7a0      	b.n	5186 <__kernel_rem_pio2f+0x51e>
    5244:	eebd 0ac0 	vcvt.s32.f32	s0, s0
    5248:	a906      	add	r1, sp, #24
    524a:	ee10 2a10 	vmov	r2, s0
    524e:	462b      	mov	r3, r5
    5250:	f841 2025 	str.w	r2, [r1, r5, lsl #2]
    5254:	e69f      	b.n	4f96 <__kernel_rem_pio2f+0x32e>
    5256:	eddf 7a0f 	vldr	s15, [pc, #60]	; 5294 <__kernel_rem_pio2f+0x62c>
    525a:	e781      	b.n	5160 <__kernel_rem_pio2f+0x4f8>
    525c:	9a64      	ldr	r2, [sp, #400]	; 0x190
    525e:	2a03      	cmp	r2, #3
    5260:	d891      	bhi.n	5186 <__kernel_rem_pio2f+0x51e>
    5262:	a101      	add	r1, pc, #4	; (adr r1, 5268 <__kernel_rem_pio2f+0x600>)
    5264:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
    5268:	00005285 	.word	0x00005285
    526c:	0000527f 	.word	0x0000527f
    5270:	0000527f 	.word	0x0000527f
    5274:	00005257 	.word	0x00005257
    5278:	9b01      	ldr	r3, [sp, #4]
    527a:	009c      	lsls	r4, r3, #2
    527c:	e54a      	b.n	4d14 <__kernel_rem_pio2f+0xac>
    527e:	eddf 7a05 	vldr	s15, [pc, #20]	; 5294 <__kernel_rem_pio2f+0x62c>
    5282:	e794      	b.n	51ae <__kernel_rem_pio2f+0x546>
    5284:	eddf 7a03 	vldr	s15, [pc, #12]	; 5294 <__kernel_rem_pio2f+0x62c>
    5288:	e7b9      	b.n	51fe <__kernel_rem_pio2f+0x596>
    528a:	bf00      	nop
    528c:	00006fb4 	.word	0x00006fb4
    5290:	3fc90000 	.word	0x3fc90000
    5294:	00000000 	.word	0x00000000

00005298 <__kernel_sinf>:
    5298:	ee10 3a10 	vmov	r3, s0
    529c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    52a0:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
    52a4:	da04      	bge.n	52b0 <__kernel_sinf+0x18>
    52a6:	eefd 7ac0 	vcvt.s32.f32	s15, s0
    52aa:	ee17 3a90 	vmov	r3, s15
    52ae:	b323      	cbz	r3, 52fa <__kernel_sinf+0x62>
    52b0:	ee60 7a00 	vmul.f32	s15, s0, s0
    52b4:	ed9f 5a15 	vldr	s10, [pc, #84]	; 530c <__kernel_sinf+0x74>
    52b8:	eddf 5a15 	vldr	s11, [pc, #84]	; 5310 <__kernel_sinf+0x78>
    52bc:	ed9f 6a15 	vldr	s12, [pc, #84]	; 5314 <__kernel_sinf+0x7c>
    52c0:	eddf 6a15 	vldr	s13, [pc, #84]	; 5318 <__kernel_sinf+0x80>
    52c4:	ed9f 7a15 	vldr	s14, [pc, #84]	; 531c <__kernel_sinf+0x84>
    52c8:	eee7 5a85 	vfma.f32	s11, s15, s10
    52cc:	ee20 5a27 	vmul.f32	s10, s0, s15
    52d0:	eea7 6aa5 	vfma.f32	s12, s15, s11
    52d4:	eee7 6a86 	vfma.f32	s13, s15, s12
    52d8:	eea7 7aa6 	vfma.f32	s14, s15, s13
    52dc:	b170      	cbz	r0, 52fc <__kernel_sinf+0x64>
    52de:	ee27 7a45 	vnmul.f32	s14, s14, s10
    52e2:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
    52e6:	eea0 7aa6 	vfma.f32	s14, s1, s13
    52ea:	eddf 6a0d 	vldr	s13, [pc, #52]	; 5320 <__kernel_sinf+0x88>
    52ee:	eed7 0a87 	vfnms.f32	s1, s15, s14
    52f2:	eee5 0a26 	vfma.f32	s1, s10, s13
    52f6:	ee30 0a60 	vsub.f32	s0, s0, s1
    52fa:	4770      	bx	lr
    52fc:	eddf 6a09 	vldr	s13, [pc, #36]	; 5324 <__kernel_sinf+0x8c>
    5300:	eee7 6a87 	vfma.f32	s13, s15, s14
    5304:	eea5 0a26 	vfma.f32	s0, s10, s13
    5308:	4770      	bx	lr
    530a:	bf00      	nop
    530c:	2f2ec9d3 	.word	0x2f2ec9d3
    5310:	b2d72f34 	.word	0xb2d72f34
    5314:	3638ef1b 	.word	0x3638ef1b
    5318:	b9500d01 	.word	0xb9500d01
    531c:	3c088889 	.word	0x3c088889
    5320:	3e2aaaab 	.word	0x3e2aaaab
    5324:	be2aaaab 	.word	0xbe2aaaab

00005328 <matherr>:
    5328:	2000      	movs	r0, #0
    532a:	4770      	bx	lr

0000532c <fabsf>:
    532c:	ee10 3a10 	vmov	r3, s0
    5330:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    5334:	ee00 3a10 	vmov	s0, r3
    5338:	4770      	bx	lr
    533a:	bf00      	nop

0000533c <floorf>:
    533c:	ee10 2a10 	vmov	r2, s0
    5340:	f022 4100 	bic.w	r1, r2, #2147483648	; 0x80000000
    5344:	0dcb      	lsrs	r3, r1, #23
    5346:	3b7f      	subs	r3, #127	; 0x7f
    5348:	2b16      	cmp	r3, #22
    534a:	dc17      	bgt.n	537c <floorf+0x40>
    534c:	2b00      	cmp	r3, #0
    534e:	ee10 0a10 	vmov	r0, s0
    5352:	db19      	blt.n	5388 <floorf+0x4c>
    5354:	491a      	ldr	r1, [pc, #104]	; (53c0 <floorf+0x84>)
    5356:	4119      	asrs	r1, r3
    5358:	420a      	tst	r2, r1
    535a:	d022      	beq.n	53a2 <floorf+0x66>
    535c:	eddf 7a19 	vldr	s15, [pc, #100]	; 53c4 <floorf+0x88>
    5360:	ee70 7a27 	vadd.f32	s15, s0, s15
    5364:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    5368:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    536c:	dd19      	ble.n	53a2 <floorf+0x66>
    536e:	2a00      	cmp	r2, #0
    5370:	db18      	blt.n	53a4 <floorf+0x68>
    5372:	ea20 0301 	bic.w	r3, r0, r1
    5376:	ee00 3a10 	vmov	s0, r3
    537a:	4770      	bx	lr
    537c:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
    5380:	d30f      	bcc.n	53a2 <floorf+0x66>
    5382:	ee30 0a00 	vadd.f32	s0, s0, s0
    5386:	4770      	bx	lr
    5388:	eddf 7a0e 	vldr	s15, [pc, #56]	; 53c4 <floorf+0x88>
    538c:	ee70 7a27 	vadd.f32	s15, s0, s15
    5390:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    5394:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    5398:	dd03      	ble.n	53a2 <floorf+0x66>
    539a:	2a00      	cmp	r2, #0
    539c:	db08      	blt.n	53b0 <floorf+0x74>
    539e:	ed9f 0a0a 	vldr	s0, [pc, #40]	; 53c8 <floorf+0x8c>
    53a2:	4770      	bx	lr
    53a4:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
    53a8:	fa42 f303 	asr.w	r3, r2, r3
    53ac:	4418      	add	r0, r3
    53ae:	e7e0      	b.n	5372 <floorf+0x36>
    53b0:	2900      	cmp	r1, #0
    53b2:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
    53b6:	bf18      	it	ne
    53b8:	eeb0 0a67 	vmovne.f32	s0, s15
    53bc:	4770      	bx	lr
    53be:	bf00      	nop
    53c0:	007fffff 	.word	0x007fffff
    53c4:	7149f2ca 	.word	0x7149f2ca
    53c8:	00000000 	.word	0x00000000

000053cc <scalbnf>:
    53cc:	b508      	push	{r3, lr}
    53ce:	ee10 3a10 	vmov	r3, s0
    53d2:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
    53d6:	ed2d 8b02 	vpush	{d8}
    53da:	d011      	beq.n	5400 <scalbnf+0x34>
    53dc:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
    53e0:	d211      	bcs.n	5406 <scalbnf+0x3a>
    53e2:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
    53e6:	d313      	bcc.n	5410 <scalbnf+0x44>
    53e8:	0dd2      	lsrs	r2, r2, #23
    53ea:	4402      	add	r2, r0
    53ec:	2afe      	cmp	r2, #254	; 0xfe
    53ee:	dc2e      	bgt.n	544e <scalbnf+0x82>
    53f0:	2a00      	cmp	r2, #0
    53f2:	dd1a      	ble.n	542a <scalbnf+0x5e>
    53f4:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
    53f8:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
    53fc:	ee00 3a10 	vmov	s0, r3
    5400:	ecbd 8b02 	vpop	{d8}
    5404:	bd08      	pop	{r3, pc}
    5406:	ecbd 8b02 	vpop	{d8}
    540a:	ee30 0a00 	vadd.f32	s0, s0, s0
    540e:	bd08      	pop	{r3, pc}
    5410:	4b1d      	ldr	r3, [pc, #116]	; (5488 <scalbnf+0xbc>)
    5412:	eddf 7a1e 	vldr	s15, [pc, #120]	; 548c <scalbnf+0xc0>
    5416:	4298      	cmp	r0, r3
    5418:	ee20 0a27 	vmul.f32	s0, s0, s15
    541c:	db22      	blt.n	5464 <scalbnf+0x98>
    541e:	ee10 3a10 	vmov	r3, s0
    5422:	f3c3 52c7 	ubfx	r2, r3, #23, #8
    5426:	3a19      	subs	r2, #25
    5428:	e7df      	b.n	53ea <scalbnf+0x1e>
    542a:	f112 0f16 	cmn.w	r2, #22
    542e:	da1e      	bge.n	546e <scalbnf+0xa2>
    5430:	f24c 3350 	movw	r3, #50000	; 0xc350
    5434:	4298      	cmp	r0, r3
    5436:	dc0a      	bgt.n	544e <scalbnf+0x82>
    5438:	ed9f 8a15 	vldr	s16, [pc, #84]	; 5490 <scalbnf+0xc4>
    543c:	eef0 0a40 	vmov.f32	s1, s0
    5440:	eeb0 0a48 	vmov.f32	s0, s16
    5444:	f000 f82a 	bl	549c <copysignf>
    5448:	ee20 0a08 	vmul.f32	s0, s0, s16
    544c:	e7d8      	b.n	5400 <scalbnf+0x34>
    544e:	ed9f 8a11 	vldr	s16, [pc, #68]	; 5494 <scalbnf+0xc8>
    5452:	eef0 0a40 	vmov.f32	s1, s0
    5456:	eeb0 0a48 	vmov.f32	s0, s16
    545a:	f000 f81f 	bl	549c <copysignf>
    545e:	ee20 0a08 	vmul.f32	s0, s0, s16
    5462:	e7cd      	b.n	5400 <scalbnf+0x34>
    5464:	eddf 0a0a 	vldr	s1, [pc, #40]	; 5490 <scalbnf+0xc4>
    5468:	ee20 0a20 	vmul.f32	s0, s0, s1
    546c:	e7c8      	b.n	5400 <scalbnf+0x34>
    546e:	3219      	adds	r2, #25
    5470:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
    5474:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
    5478:	eddf 7a07 	vldr	s15, [pc, #28]	; 5498 <scalbnf+0xcc>
    547c:	ee00 3a10 	vmov	s0, r3
    5480:	ee20 0a27 	vmul.f32	s0, s0, s15
    5484:	e7bc      	b.n	5400 <scalbnf+0x34>
    5486:	bf00      	nop
    5488:	ffff3cb0 	.word	0xffff3cb0
    548c:	4c000000 	.word	0x4c000000
    5490:	0da24260 	.word	0x0da24260
    5494:	7149f2ca 	.word	0x7149f2ca
    5498:	33000000 	.word	0x33000000

0000549c <copysignf>:
    549c:	ee10 3a10 	vmov	r3, s0
    54a0:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    54a4:	ee10 3a90 	vmov	r3, s1
    54a8:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
    54ac:	4313      	orrs	r3, r2
    54ae:	ee00 3a10 	vmov	s0, r3
    54b2:	4770      	bx	lr

000054b4 <__aeabi_drsub>:
    54b4:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    54b8:	e002      	b.n	54c0 <__adddf3>
    54ba:	bf00      	nop

000054bc <__aeabi_dsub>:
    54bc:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

000054c0 <__adddf3>:
    54c0:	b530      	push	{r4, r5, lr}
    54c2:	ea4f 0441 	mov.w	r4, r1, lsl #1
    54c6:	ea4f 0543 	mov.w	r5, r3, lsl #1
    54ca:	ea94 0f05 	teq	r4, r5
    54ce:	bf08      	it	eq
    54d0:	ea90 0f02 	teqeq	r0, r2
    54d4:	bf1f      	itttt	ne
    54d6:	ea54 0c00 	orrsne.w	ip, r4, r0
    54da:	ea55 0c02 	orrsne.w	ip, r5, r2
    54de:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    54e2:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    54e6:	f000 80e2 	beq.w	56ae <__adddf3+0x1ee>
    54ea:	ea4f 5454 	mov.w	r4, r4, lsr #21
    54ee:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    54f2:	bfb8      	it	lt
    54f4:	426d      	neglt	r5, r5
    54f6:	dd0c      	ble.n	5512 <__adddf3+0x52>
    54f8:	442c      	add	r4, r5
    54fa:	ea80 0202 	eor.w	r2, r0, r2
    54fe:	ea81 0303 	eor.w	r3, r1, r3
    5502:	ea82 0000 	eor.w	r0, r2, r0
    5506:	ea83 0101 	eor.w	r1, r3, r1
    550a:	ea80 0202 	eor.w	r2, r0, r2
    550e:	ea81 0303 	eor.w	r3, r1, r3
    5512:	2d36      	cmp	r5, #54	; 0x36
    5514:	bf88      	it	hi
    5516:	bd30      	pophi	{r4, r5, pc}
    5518:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    551c:	ea4f 3101 	mov.w	r1, r1, lsl #12
    5520:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    5524:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    5528:	d002      	beq.n	5530 <__adddf3+0x70>
    552a:	4240      	negs	r0, r0
    552c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    5530:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    5534:	ea4f 3303 	mov.w	r3, r3, lsl #12
    5538:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    553c:	d002      	beq.n	5544 <__adddf3+0x84>
    553e:	4252      	negs	r2, r2
    5540:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    5544:	ea94 0f05 	teq	r4, r5
    5548:	f000 80a7 	beq.w	569a <__adddf3+0x1da>
    554c:	f1a4 0401 	sub.w	r4, r4, #1
    5550:	f1d5 0e20 	rsbs	lr, r5, #32
    5554:	db0d      	blt.n	5572 <__adddf3+0xb2>
    5556:	fa02 fc0e 	lsl.w	ip, r2, lr
    555a:	fa22 f205 	lsr.w	r2, r2, r5
    555e:	1880      	adds	r0, r0, r2
    5560:	f141 0100 	adc.w	r1, r1, #0
    5564:	fa03 f20e 	lsl.w	r2, r3, lr
    5568:	1880      	adds	r0, r0, r2
    556a:	fa43 f305 	asr.w	r3, r3, r5
    556e:	4159      	adcs	r1, r3
    5570:	e00e      	b.n	5590 <__adddf3+0xd0>
    5572:	f1a5 0520 	sub.w	r5, r5, #32
    5576:	f10e 0e20 	add.w	lr, lr, #32
    557a:	2a01      	cmp	r2, #1
    557c:	fa03 fc0e 	lsl.w	ip, r3, lr
    5580:	bf28      	it	cs
    5582:	f04c 0c02 	orrcs.w	ip, ip, #2
    5586:	fa43 f305 	asr.w	r3, r3, r5
    558a:	18c0      	adds	r0, r0, r3
    558c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    5590:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    5594:	d507      	bpl.n	55a6 <__adddf3+0xe6>
    5596:	f04f 0e00 	mov.w	lr, #0
    559a:	f1dc 0c00 	rsbs	ip, ip, #0
    559e:	eb7e 0000 	sbcs.w	r0, lr, r0
    55a2:	eb6e 0101 	sbc.w	r1, lr, r1
    55a6:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    55aa:	d31b      	bcc.n	55e4 <__adddf3+0x124>
    55ac:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    55b0:	d30c      	bcc.n	55cc <__adddf3+0x10c>
    55b2:	0849      	lsrs	r1, r1, #1
    55b4:	ea5f 0030 	movs.w	r0, r0, rrx
    55b8:	ea4f 0c3c 	mov.w	ip, ip, rrx
    55bc:	f104 0401 	add.w	r4, r4, #1
    55c0:	ea4f 5244 	mov.w	r2, r4, lsl #21
    55c4:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    55c8:	f080 809a 	bcs.w	5700 <__adddf3+0x240>
    55cc:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    55d0:	bf08      	it	eq
    55d2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    55d6:	f150 0000 	adcs.w	r0, r0, #0
    55da:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    55de:	ea41 0105 	orr.w	r1, r1, r5
    55e2:	bd30      	pop	{r4, r5, pc}
    55e4:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    55e8:	4140      	adcs	r0, r0
    55ea:	eb41 0101 	adc.w	r1, r1, r1
    55ee:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    55f2:	f1a4 0401 	sub.w	r4, r4, #1
    55f6:	d1e9      	bne.n	55cc <__adddf3+0x10c>
    55f8:	f091 0f00 	teq	r1, #0
    55fc:	bf04      	itt	eq
    55fe:	4601      	moveq	r1, r0
    5600:	2000      	moveq	r0, #0
    5602:	fab1 f381 	clz	r3, r1
    5606:	bf08      	it	eq
    5608:	3320      	addeq	r3, #32
    560a:	f1a3 030b 	sub.w	r3, r3, #11
    560e:	f1b3 0220 	subs.w	r2, r3, #32
    5612:	da0c      	bge.n	562e <__adddf3+0x16e>
    5614:	320c      	adds	r2, #12
    5616:	dd08      	ble.n	562a <__adddf3+0x16a>
    5618:	f102 0c14 	add.w	ip, r2, #20
    561c:	f1c2 020c 	rsb	r2, r2, #12
    5620:	fa01 f00c 	lsl.w	r0, r1, ip
    5624:	fa21 f102 	lsr.w	r1, r1, r2
    5628:	e00c      	b.n	5644 <__adddf3+0x184>
    562a:	f102 0214 	add.w	r2, r2, #20
    562e:	bfd8      	it	le
    5630:	f1c2 0c20 	rsble	ip, r2, #32
    5634:	fa01 f102 	lsl.w	r1, r1, r2
    5638:	fa20 fc0c 	lsr.w	ip, r0, ip
    563c:	bfdc      	itt	le
    563e:	ea41 010c 	orrle.w	r1, r1, ip
    5642:	4090      	lslle	r0, r2
    5644:	1ae4      	subs	r4, r4, r3
    5646:	bfa2      	ittt	ge
    5648:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    564c:	4329      	orrge	r1, r5
    564e:	bd30      	popge	{r4, r5, pc}
    5650:	ea6f 0404 	mvn.w	r4, r4
    5654:	3c1f      	subs	r4, #31
    5656:	da1c      	bge.n	5692 <__adddf3+0x1d2>
    5658:	340c      	adds	r4, #12
    565a:	dc0e      	bgt.n	567a <__adddf3+0x1ba>
    565c:	f104 0414 	add.w	r4, r4, #20
    5660:	f1c4 0220 	rsb	r2, r4, #32
    5664:	fa20 f004 	lsr.w	r0, r0, r4
    5668:	fa01 f302 	lsl.w	r3, r1, r2
    566c:	ea40 0003 	orr.w	r0, r0, r3
    5670:	fa21 f304 	lsr.w	r3, r1, r4
    5674:	ea45 0103 	orr.w	r1, r5, r3
    5678:	bd30      	pop	{r4, r5, pc}
    567a:	f1c4 040c 	rsb	r4, r4, #12
    567e:	f1c4 0220 	rsb	r2, r4, #32
    5682:	fa20 f002 	lsr.w	r0, r0, r2
    5686:	fa01 f304 	lsl.w	r3, r1, r4
    568a:	ea40 0003 	orr.w	r0, r0, r3
    568e:	4629      	mov	r1, r5
    5690:	bd30      	pop	{r4, r5, pc}
    5692:	fa21 f004 	lsr.w	r0, r1, r4
    5696:	4629      	mov	r1, r5
    5698:	bd30      	pop	{r4, r5, pc}
    569a:	f094 0f00 	teq	r4, #0
    569e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    56a2:	bf06      	itte	eq
    56a4:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    56a8:	3401      	addeq	r4, #1
    56aa:	3d01      	subne	r5, #1
    56ac:	e74e      	b.n	554c <__adddf3+0x8c>
    56ae:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    56b2:	bf18      	it	ne
    56b4:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    56b8:	d029      	beq.n	570e <__adddf3+0x24e>
    56ba:	ea94 0f05 	teq	r4, r5
    56be:	bf08      	it	eq
    56c0:	ea90 0f02 	teqeq	r0, r2
    56c4:	d005      	beq.n	56d2 <__adddf3+0x212>
    56c6:	ea54 0c00 	orrs.w	ip, r4, r0
    56ca:	bf04      	itt	eq
    56cc:	4619      	moveq	r1, r3
    56ce:	4610      	moveq	r0, r2
    56d0:	bd30      	pop	{r4, r5, pc}
    56d2:	ea91 0f03 	teq	r1, r3
    56d6:	bf1e      	ittt	ne
    56d8:	2100      	movne	r1, #0
    56da:	2000      	movne	r0, #0
    56dc:	bd30      	popne	{r4, r5, pc}
    56de:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    56e2:	d105      	bne.n	56f0 <__adddf3+0x230>
    56e4:	0040      	lsls	r0, r0, #1
    56e6:	4149      	adcs	r1, r1
    56e8:	bf28      	it	cs
    56ea:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    56ee:	bd30      	pop	{r4, r5, pc}
    56f0:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    56f4:	bf3c      	itt	cc
    56f6:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    56fa:	bd30      	popcc	{r4, r5, pc}
    56fc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    5700:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    5704:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    5708:	f04f 0000 	mov.w	r0, #0
    570c:	bd30      	pop	{r4, r5, pc}
    570e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    5712:	bf1a      	itte	ne
    5714:	4619      	movne	r1, r3
    5716:	4610      	movne	r0, r2
    5718:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    571c:	bf1c      	itt	ne
    571e:	460b      	movne	r3, r1
    5720:	4602      	movne	r2, r0
    5722:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    5726:	bf06      	itte	eq
    5728:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    572c:	ea91 0f03 	teqeq	r1, r3
    5730:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    5734:	bd30      	pop	{r4, r5, pc}
    5736:	bf00      	nop

00005738 <__aeabi_ui2d>:
    5738:	f090 0f00 	teq	r0, #0
    573c:	bf04      	itt	eq
    573e:	2100      	moveq	r1, #0
    5740:	4770      	bxeq	lr
    5742:	b530      	push	{r4, r5, lr}
    5744:	f44f 6480 	mov.w	r4, #1024	; 0x400
    5748:	f104 0432 	add.w	r4, r4, #50	; 0x32
    574c:	f04f 0500 	mov.w	r5, #0
    5750:	f04f 0100 	mov.w	r1, #0
    5754:	e750      	b.n	55f8 <__adddf3+0x138>
    5756:	bf00      	nop

00005758 <__aeabi_i2d>:
    5758:	f090 0f00 	teq	r0, #0
    575c:	bf04      	itt	eq
    575e:	2100      	moveq	r1, #0
    5760:	4770      	bxeq	lr
    5762:	b530      	push	{r4, r5, lr}
    5764:	f44f 6480 	mov.w	r4, #1024	; 0x400
    5768:	f104 0432 	add.w	r4, r4, #50	; 0x32
    576c:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    5770:	bf48      	it	mi
    5772:	4240      	negmi	r0, r0
    5774:	f04f 0100 	mov.w	r1, #0
    5778:	e73e      	b.n	55f8 <__adddf3+0x138>
    577a:	bf00      	nop

0000577c <__aeabi_f2d>:
    577c:	0042      	lsls	r2, r0, #1
    577e:	ea4f 01e2 	mov.w	r1, r2, asr #3
    5782:	ea4f 0131 	mov.w	r1, r1, rrx
    5786:	ea4f 7002 	mov.w	r0, r2, lsl #28
    578a:	bf1f      	itttt	ne
    578c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    5790:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    5794:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    5798:	4770      	bxne	lr
    579a:	f092 0f00 	teq	r2, #0
    579e:	bf14      	ite	ne
    57a0:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    57a4:	4770      	bxeq	lr
    57a6:	b530      	push	{r4, r5, lr}
    57a8:	f44f 7460 	mov.w	r4, #896	; 0x380
    57ac:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    57b0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    57b4:	e720      	b.n	55f8 <__adddf3+0x138>
    57b6:	bf00      	nop

000057b8 <__aeabi_ul2d>:
    57b8:	ea50 0201 	orrs.w	r2, r0, r1
    57bc:	bf08      	it	eq
    57be:	4770      	bxeq	lr
    57c0:	b530      	push	{r4, r5, lr}
    57c2:	f04f 0500 	mov.w	r5, #0
    57c6:	e00a      	b.n	57de <__aeabi_l2d+0x16>

000057c8 <__aeabi_l2d>:
    57c8:	ea50 0201 	orrs.w	r2, r0, r1
    57cc:	bf08      	it	eq
    57ce:	4770      	bxeq	lr
    57d0:	b530      	push	{r4, r5, lr}
    57d2:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    57d6:	d502      	bpl.n	57de <__aeabi_l2d+0x16>
    57d8:	4240      	negs	r0, r0
    57da:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    57de:	f44f 6480 	mov.w	r4, #1024	; 0x400
    57e2:	f104 0432 	add.w	r4, r4, #50	; 0x32
    57e6:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    57ea:	f43f aedc 	beq.w	55a6 <__adddf3+0xe6>
    57ee:	f04f 0203 	mov.w	r2, #3
    57f2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    57f6:	bf18      	it	ne
    57f8:	3203      	addne	r2, #3
    57fa:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    57fe:	bf18      	it	ne
    5800:	3203      	addne	r2, #3
    5802:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    5806:	f1c2 0320 	rsb	r3, r2, #32
    580a:	fa00 fc03 	lsl.w	ip, r0, r3
    580e:	fa20 f002 	lsr.w	r0, r0, r2
    5812:	fa01 fe03 	lsl.w	lr, r1, r3
    5816:	ea40 000e 	orr.w	r0, r0, lr
    581a:	fa21 f102 	lsr.w	r1, r1, r2
    581e:	4414      	add	r4, r2
    5820:	e6c1      	b.n	55a6 <__adddf3+0xe6>
    5822:	bf00      	nop

00005824 <__aeabi_dmul>:
    5824:	b570      	push	{r4, r5, r6, lr}
    5826:	f04f 0cff 	mov.w	ip, #255	; 0xff
    582a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    582e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    5832:	bf1d      	ittte	ne
    5834:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    5838:	ea94 0f0c 	teqne	r4, ip
    583c:	ea95 0f0c 	teqne	r5, ip
    5840:	f000 f8de 	bleq	5a00 <__aeabi_dmul+0x1dc>
    5844:	442c      	add	r4, r5
    5846:	ea81 0603 	eor.w	r6, r1, r3
    584a:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
    584e:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
    5852:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
    5856:	bf18      	it	ne
    5858:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
    585c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    5860:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    5864:	d038      	beq.n	58d8 <__aeabi_dmul+0xb4>
    5866:	fba0 ce02 	umull	ip, lr, r0, r2
    586a:	f04f 0500 	mov.w	r5, #0
    586e:	fbe1 e502 	umlal	lr, r5, r1, r2
    5872:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
    5876:	fbe0 e503 	umlal	lr, r5, r0, r3
    587a:	f04f 0600 	mov.w	r6, #0
    587e:	fbe1 5603 	umlal	r5, r6, r1, r3
    5882:	f09c 0f00 	teq	ip, #0
    5886:	bf18      	it	ne
    5888:	f04e 0e01 	orrne.w	lr, lr, #1
    588c:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
    5890:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    5894:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
    5898:	d204      	bcs.n	58a4 <__aeabi_dmul+0x80>
    589a:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
    589e:	416d      	adcs	r5, r5
    58a0:	eb46 0606 	adc.w	r6, r6, r6
    58a4:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
    58a8:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
    58ac:	ea4f 20c5 	mov.w	r0, r5, lsl #11
    58b0:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
    58b4:	ea4f 2ece 	mov.w	lr, lr, lsl #11
    58b8:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    58bc:	bf88      	it	hi
    58be:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    58c2:	d81e      	bhi.n	5902 <__aeabi_dmul+0xde>
    58c4:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
    58c8:	bf08      	it	eq
    58ca:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
    58ce:	f150 0000 	adcs.w	r0, r0, #0
    58d2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    58d6:	bd70      	pop	{r4, r5, r6, pc}
    58d8:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
    58dc:	ea46 0101 	orr.w	r1, r6, r1
    58e0:	ea40 0002 	orr.w	r0, r0, r2
    58e4:	ea81 0103 	eor.w	r1, r1, r3
    58e8:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
    58ec:	bfc2      	ittt	gt
    58ee:	ebd4 050c 	rsbsgt	r5, r4, ip
    58f2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    58f6:	bd70      	popgt	{r4, r5, r6, pc}
    58f8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    58fc:	f04f 0e00 	mov.w	lr, #0
    5900:	3c01      	subs	r4, #1
    5902:	f300 80ab 	bgt.w	5a5c <__aeabi_dmul+0x238>
    5906:	f114 0f36 	cmn.w	r4, #54	; 0x36
    590a:	bfde      	ittt	le
    590c:	2000      	movle	r0, #0
    590e:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
    5912:	bd70      	pople	{r4, r5, r6, pc}
    5914:	f1c4 0400 	rsb	r4, r4, #0
    5918:	3c20      	subs	r4, #32
    591a:	da35      	bge.n	5988 <__aeabi_dmul+0x164>
    591c:	340c      	adds	r4, #12
    591e:	dc1b      	bgt.n	5958 <__aeabi_dmul+0x134>
    5920:	f104 0414 	add.w	r4, r4, #20
    5924:	f1c4 0520 	rsb	r5, r4, #32
    5928:	fa00 f305 	lsl.w	r3, r0, r5
    592c:	fa20 f004 	lsr.w	r0, r0, r4
    5930:	fa01 f205 	lsl.w	r2, r1, r5
    5934:	ea40 0002 	orr.w	r0, r0, r2
    5938:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
    593c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    5940:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    5944:	fa21 f604 	lsr.w	r6, r1, r4
    5948:	eb42 0106 	adc.w	r1, r2, r6
    594c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    5950:	bf08      	it	eq
    5952:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    5956:	bd70      	pop	{r4, r5, r6, pc}
    5958:	f1c4 040c 	rsb	r4, r4, #12
    595c:	f1c4 0520 	rsb	r5, r4, #32
    5960:	fa00 f304 	lsl.w	r3, r0, r4
    5964:	fa20 f005 	lsr.w	r0, r0, r5
    5968:	fa01 f204 	lsl.w	r2, r1, r4
    596c:	ea40 0002 	orr.w	r0, r0, r2
    5970:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    5974:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    5978:	f141 0100 	adc.w	r1, r1, #0
    597c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    5980:	bf08      	it	eq
    5982:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    5986:	bd70      	pop	{r4, r5, r6, pc}
    5988:	f1c4 0520 	rsb	r5, r4, #32
    598c:	fa00 f205 	lsl.w	r2, r0, r5
    5990:	ea4e 0e02 	orr.w	lr, lr, r2
    5994:	fa20 f304 	lsr.w	r3, r0, r4
    5998:	fa01 f205 	lsl.w	r2, r1, r5
    599c:	ea43 0302 	orr.w	r3, r3, r2
    59a0:	fa21 f004 	lsr.w	r0, r1, r4
    59a4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    59a8:	fa21 f204 	lsr.w	r2, r1, r4
    59ac:	ea20 0002 	bic.w	r0, r0, r2
    59b0:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    59b4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    59b8:	bf08      	it	eq
    59ba:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    59be:	bd70      	pop	{r4, r5, r6, pc}
    59c0:	f094 0f00 	teq	r4, #0
    59c4:	d10f      	bne.n	59e6 <__aeabi_dmul+0x1c2>
    59c6:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    59ca:	0040      	lsls	r0, r0, #1
    59cc:	eb41 0101 	adc.w	r1, r1, r1
    59d0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    59d4:	bf08      	it	eq
    59d6:	3c01      	subeq	r4, #1
    59d8:	d0f7      	beq.n	59ca <__aeabi_dmul+0x1a6>
    59da:	ea41 0106 	orr.w	r1, r1, r6
    59de:	f095 0f00 	teq	r5, #0
    59e2:	bf18      	it	ne
    59e4:	4770      	bxne	lr
    59e6:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    59ea:	0052      	lsls	r2, r2, #1
    59ec:	eb43 0303 	adc.w	r3, r3, r3
    59f0:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    59f4:	bf08      	it	eq
    59f6:	3d01      	subeq	r5, #1
    59f8:	d0f7      	beq.n	59ea <__aeabi_dmul+0x1c6>
    59fa:	ea43 0306 	orr.w	r3, r3, r6
    59fe:	4770      	bx	lr
    5a00:	ea94 0f0c 	teq	r4, ip
    5a04:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    5a08:	bf18      	it	ne
    5a0a:	ea95 0f0c 	teqne	r5, ip
    5a0e:	d00c      	beq.n	5a2a <__aeabi_dmul+0x206>
    5a10:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    5a14:	bf18      	it	ne
    5a16:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    5a1a:	d1d1      	bne.n	59c0 <__aeabi_dmul+0x19c>
    5a1c:	ea81 0103 	eor.w	r1, r1, r3
    5a20:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    5a24:	f04f 0000 	mov.w	r0, #0
    5a28:	bd70      	pop	{r4, r5, r6, pc}
    5a2a:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    5a2e:	bf06      	itte	eq
    5a30:	4610      	moveq	r0, r2
    5a32:	4619      	moveq	r1, r3
    5a34:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    5a38:	d019      	beq.n	5a6e <__aeabi_dmul+0x24a>
    5a3a:	ea94 0f0c 	teq	r4, ip
    5a3e:	d102      	bne.n	5a46 <__aeabi_dmul+0x222>
    5a40:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    5a44:	d113      	bne.n	5a6e <__aeabi_dmul+0x24a>
    5a46:	ea95 0f0c 	teq	r5, ip
    5a4a:	d105      	bne.n	5a58 <__aeabi_dmul+0x234>
    5a4c:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    5a50:	bf1c      	itt	ne
    5a52:	4610      	movne	r0, r2
    5a54:	4619      	movne	r1, r3
    5a56:	d10a      	bne.n	5a6e <__aeabi_dmul+0x24a>
    5a58:	ea81 0103 	eor.w	r1, r1, r3
    5a5c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    5a60:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    5a64:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    5a68:	f04f 0000 	mov.w	r0, #0
    5a6c:	bd70      	pop	{r4, r5, r6, pc}
    5a6e:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    5a72:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    5a76:	bd70      	pop	{r4, r5, r6, pc}

00005a78 <__aeabi_ddiv>:
    5a78:	b570      	push	{r4, r5, r6, lr}
    5a7a:	f04f 0cff 	mov.w	ip, #255	; 0xff
    5a7e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    5a82:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    5a86:	bf1d      	ittte	ne
    5a88:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    5a8c:	ea94 0f0c 	teqne	r4, ip
    5a90:	ea95 0f0c 	teqne	r5, ip
    5a94:	f000 f8a7 	bleq	5be6 <__aeabi_ddiv+0x16e>
    5a98:	eba4 0405 	sub.w	r4, r4, r5
    5a9c:	ea81 0e03 	eor.w	lr, r1, r3
    5aa0:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    5aa4:	ea4f 3101 	mov.w	r1, r1, lsl #12
    5aa8:	f000 8088 	beq.w	5bbc <__aeabi_ddiv+0x144>
    5aac:	ea4f 3303 	mov.w	r3, r3, lsl #12
    5ab0:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    5ab4:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    5ab8:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    5abc:	ea4f 2202 	mov.w	r2, r2, lsl #8
    5ac0:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    5ac4:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    5ac8:	ea4f 2600 	mov.w	r6, r0, lsl #8
    5acc:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
    5ad0:	429d      	cmp	r5, r3
    5ad2:	bf08      	it	eq
    5ad4:	4296      	cmpeq	r6, r2
    5ad6:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
    5ada:	f504 7440 	add.w	r4, r4, #768	; 0x300
    5ade:	d202      	bcs.n	5ae6 <__aeabi_ddiv+0x6e>
    5ae0:	085b      	lsrs	r3, r3, #1
    5ae2:	ea4f 0232 	mov.w	r2, r2, rrx
    5ae6:	1ab6      	subs	r6, r6, r2
    5ae8:	eb65 0503 	sbc.w	r5, r5, r3
    5aec:	085b      	lsrs	r3, r3, #1
    5aee:	ea4f 0232 	mov.w	r2, r2, rrx
    5af2:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    5af6:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
    5afa:	ebb6 0e02 	subs.w	lr, r6, r2
    5afe:	eb75 0e03 	sbcs.w	lr, r5, r3
    5b02:	bf22      	ittt	cs
    5b04:	1ab6      	subcs	r6, r6, r2
    5b06:	4675      	movcs	r5, lr
    5b08:	ea40 000c 	orrcs.w	r0, r0, ip
    5b0c:	085b      	lsrs	r3, r3, #1
    5b0e:	ea4f 0232 	mov.w	r2, r2, rrx
    5b12:	ebb6 0e02 	subs.w	lr, r6, r2
    5b16:	eb75 0e03 	sbcs.w	lr, r5, r3
    5b1a:	bf22      	ittt	cs
    5b1c:	1ab6      	subcs	r6, r6, r2
    5b1e:	4675      	movcs	r5, lr
    5b20:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    5b24:	085b      	lsrs	r3, r3, #1
    5b26:	ea4f 0232 	mov.w	r2, r2, rrx
    5b2a:	ebb6 0e02 	subs.w	lr, r6, r2
    5b2e:	eb75 0e03 	sbcs.w	lr, r5, r3
    5b32:	bf22      	ittt	cs
    5b34:	1ab6      	subcs	r6, r6, r2
    5b36:	4675      	movcs	r5, lr
    5b38:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    5b3c:	085b      	lsrs	r3, r3, #1
    5b3e:	ea4f 0232 	mov.w	r2, r2, rrx
    5b42:	ebb6 0e02 	subs.w	lr, r6, r2
    5b46:	eb75 0e03 	sbcs.w	lr, r5, r3
    5b4a:	bf22      	ittt	cs
    5b4c:	1ab6      	subcs	r6, r6, r2
    5b4e:	4675      	movcs	r5, lr
    5b50:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    5b54:	ea55 0e06 	orrs.w	lr, r5, r6
    5b58:	d018      	beq.n	5b8c <__aeabi_ddiv+0x114>
    5b5a:	ea4f 1505 	mov.w	r5, r5, lsl #4
    5b5e:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    5b62:	ea4f 1606 	mov.w	r6, r6, lsl #4
    5b66:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    5b6a:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    5b6e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    5b72:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    5b76:	d1c0      	bne.n	5afa <__aeabi_ddiv+0x82>
    5b78:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    5b7c:	d10b      	bne.n	5b96 <__aeabi_ddiv+0x11e>
    5b7e:	ea41 0100 	orr.w	r1, r1, r0
    5b82:	f04f 0000 	mov.w	r0, #0
    5b86:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
    5b8a:	e7b6      	b.n	5afa <__aeabi_ddiv+0x82>
    5b8c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    5b90:	bf04      	itt	eq
    5b92:	4301      	orreq	r1, r0
    5b94:	2000      	moveq	r0, #0
    5b96:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    5b9a:	bf88      	it	hi
    5b9c:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    5ba0:	f63f aeaf 	bhi.w	5902 <__aeabi_dmul+0xde>
    5ba4:	ebb5 0c03 	subs.w	ip, r5, r3
    5ba8:	bf04      	itt	eq
    5baa:	ebb6 0c02 	subseq.w	ip, r6, r2
    5bae:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    5bb2:	f150 0000 	adcs.w	r0, r0, #0
    5bb6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    5bba:	bd70      	pop	{r4, r5, r6, pc}
    5bbc:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
    5bc0:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    5bc4:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    5bc8:	bfc2      	ittt	gt
    5bca:	ebd4 050c 	rsbsgt	r5, r4, ip
    5bce:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    5bd2:	bd70      	popgt	{r4, r5, r6, pc}
    5bd4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    5bd8:	f04f 0e00 	mov.w	lr, #0
    5bdc:	3c01      	subs	r4, #1
    5bde:	e690      	b.n	5902 <__aeabi_dmul+0xde>
    5be0:	ea45 0e06 	orr.w	lr, r5, r6
    5be4:	e68d      	b.n	5902 <__aeabi_dmul+0xde>
    5be6:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    5bea:	ea94 0f0c 	teq	r4, ip
    5bee:	bf08      	it	eq
    5bf0:	ea95 0f0c 	teqeq	r5, ip
    5bf4:	f43f af3b 	beq.w	5a6e <__aeabi_dmul+0x24a>
    5bf8:	ea94 0f0c 	teq	r4, ip
    5bfc:	d10a      	bne.n	5c14 <__aeabi_ddiv+0x19c>
    5bfe:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    5c02:	f47f af34 	bne.w	5a6e <__aeabi_dmul+0x24a>
    5c06:	ea95 0f0c 	teq	r5, ip
    5c0a:	f47f af25 	bne.w	5a58 <__aeabi_dmul+0x234>
    5c0e:	4610      	mov	r0, r2
    5c10:	4619      	mov	r1, r3
    5c12:	e72c      	b.n	5a6e <__aeabi_dmul+0x24a>
    5c14:	ea95 0f0c 	teq	r5, ip
    5c18:	d106      	bne.n	5c28 <__aeabi_ddiv+0x1b0>
    5c1a:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    5c1e:	f43f aefd 	beq.w	5a1c <__aeabi_dmul+0x1f8>
    5c22:	4610      	mov	r0, r2
    5c24:	4619      	mov	r1, r3
    5c26:	e722      	b.n	5a6e <__aeabi_dmul+0x24a>
    5c28:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    5c2c:	bf18      	it	ne
    5c2e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    5c32:	f47f aec5 	bne.w	59c0 <__aeabi_dmul+0x19c>
    5c36:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    5c3a:	f47f af0d 	bne.w	5a58 <__aeabi_dmul+0x234>
    5c3e:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    5c42:	f47f aeeb 	bne.w	5a1c <__aeabi_dmul+0x1f8>
    5c46:	e712      	b.n	5a6e <__aeabi_dmul+0x24a>

00005c48 <__gedf2>:
    5c48:	f04f 3cff 	mov.w	ip, #4294967295
    5c4c:	e006      	b.n	5c5c <__cmpdf2+0x4>
    5c4e:	bf00      	nop

00005c50 <__ledf2>:
    5c50:	f04f 0c01 	mov.w	ip, #1
    5c54:	e002      	b.n	5c5c <__cmpdf2+0x4>
    5c56:	bf00      	nop

00005c58 <__cmpdf2>:
    5c58:	f04f 0c01 	mov.w	ip, #1
    5c5c:	f84d cd04 	str.w	ip, [sp, #-4]!
    5c60:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    5c64:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    5c68:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    5c6c:	bf18      	it	ne
    5c6e:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
    5c72:	d01b      	beq.n	5cac <__cmpdf2+0x54>
    5c74:	b001      	add	sp, #4
    5c76:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
    5c7a:	bf0c      	ite	eq
    5c7c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
    5c80:	ea91 0f03 	teqne	r1, r3
    5c84:	bf02      	ittt	eq
    5c86:	ea90 0f02 	teqeq	r0, r2
    5c8a:	2000      	moveq	r0, #0
    5c8c:	4770      	bxeq	lr
    5c8e:	f110 0f00 	cmn.w	r0, #0
    5c92:	ea91 0f03 	teq	r1, r3
    5c96:	bf58      	it	pl
    5c98:	4299      	cmppl	r1, r3
    5c9a:	bf08      	it	eq
    5c9c:	4290      	cmpeq	r0, r2
    5c9e:	bf2c      	ite	cs
    5ca0:	17d8      	asrcs	r0, r3, #31
    5ca2:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
    5ca6:	f040 0001 	orr.w	r0, r0, #1
    5caa:	4770      	bx	lr
    5cac:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    5cb0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    5cb4:	d102      	bne.n	5cbc <__cmpdf2+0x64>
    5cb6:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    5cba:	d107      	bne.n	5ccc <__cmpdf2+0x74>
    5cbc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    5cc0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    5cc4:	d1d6      	bne.n	5c74 <__cmpdf2+0x1c>
    5cc6:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    5cca:	d0d3      	beq.n	5c74 <__cmpdf2+0x1c>
    5ccc:	f85d 0b04 	ldr.w	r0, [sp], #4
    5cd0:	4770      	bx	lr
    5cd2:	bf00      	nop

00005cd4 <__aeabi_cdrcmple>:
    5cd4:	4684      	mov	ip, r0
    5cd6:	4610      	mov	r0, r2
    5cd8:	4662      	mov	r2, ip
    5cda:	468c      	mov	ip, r1
    5cdc:	4619      	mov	r1, r3
    5cde:	4663      	mov	r3, ip
    5ce0:	e000      	b.n	5ce4 <__aeabi_cdcmpeq>
    5ce2:	bf00      	nop

00005ce4 <__aeabi_cdcmpeq>:
    5ce4:	b501      	push	{r0, lr}
    5ce6:	f7ff ffb7 	bl	5c58 <__cmpdf2>
    5cea:	2800      	cmp	r0, #0
    5cec:	bf48      	it	mi
    5cee:	f110 0f00 	cmnmi.w	r0, #0
    5cf2:	bd01      	pop	{r0, pc}

00005cf4 <__aeabi_dcmpeq>:
    5cf4:	f84d ed08 	str.w	lr, [sp, #-8]!
    5cf8:	f7ff fff4 	bl	5ce4 <__aeabi_cdcmpeq>
    5cfc:	bf0c      	ite	eq
    5cfe:	2001      	moveq	r0, #1
    5d00:	2000      	movne	r0, #0
    5d02:	f85d fb08 	ldr.w	pc, [sp], #8
    5d06:	bf00      	nop

00005d08 <__aeabi_dcmplt>:
    5d08:	f84d ed08 	str.w	lr, [sp, #-8]!
    5d0c:	f7ff ffea 	bl	5ce4 <__aeabi_cdcmpeq>
    5d10:	bf34      	ite	cc
    5d12:	2001      	movcc	r0, #1
    5d14:	2000      	movcs	r0, #0
    5d16:	f85d fb08 	ldr.w	pc, [sp], #8
    5d1a:	bf00      	nop

00005d1c <__aeabi_dcmple>:
    5d1c:	f84d ed08 	str.w	lr, [sp, #-8]!
    5d20:	f7ff ffe0 	bl	5ce4 <__aeabi_cdcmpeq>
    5d24:	bf94      	ite	ls
    5d26:	2001      	movls	r0, #1
    5d28:	2000      	movhi	r0, #0
    5d2a:	f85d fb08 	ldr.w	pc, [sp], #8
    5d2e:	bf00      	nop

00005d30 <__aeabi_dcmpge>:
    5d30:	f84d ed08 	str.w	lr, [sp, #-8]!
    5d34:	f7ff ffce 	bl	5cd4 <__aeabi_cdrcmple>
    5d38:	bf94      	ite	ls
    5d3a:	2001      	movls	r0, #1
    5d3c:	2000      	movhi	r0, #0
    5d3e:	f85d fb08 	ldr.w	pc, [sp], #8
    5d42:	bf00      	nop

00005d44 <__aeabi_dcmpgt>:
    5d44:	f84d ed08 	str.w	lr, [sp, #-8]!
    5d48:	f7ff ffc4 	bl	5cd4 <__aeabi_cdrcmple>
    5d4c:	bf34      	ite	cc
    5d4e:	2001      	movcc	r0, #1
    5d50:	2000      	movcs	r0, #0
    5d52:	f85d fb08 	ldr.w	pc, [sp], #8
    5d56:	bf00      	nop

00005d58 <__aeabi_dcmpun>:
    5d58:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    5d5c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    5d60:	d102      	bne.n	5d68 <__aeabi_dcmpun+0x10>
    5d62:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    5d66:	d10a      	bne.n	5d7e <__aeabi_dcmpun+0x26>
    5d68:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    5d6c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    5d70:	d102      	bne.n	5d78 <__aeabi_dcmpun+0x20>
    5d72:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    5d76:	d102      	bne.n	5d7e <__aeabi_dcmpun+0x26>
    5d78:	f04f 0000 	mov.w	r0, #0
    5d7c:	4770      	bx	lr
    5d7e:	f04f 0001 	mov.w	r0, #1
    5d82:	4770      	bx	lr

00005d84 <__aeabi_d2iz>:
    5d84:	ea4f 0241 	mov.w	r2, r1, lsl #1
    5d88:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    5d8c:	d215      	bcs.n	5dba <__aeabi_d2iz+0x36>
    5d8e:	d511      	bpl.n	5db4 <__aeabi_d2iz+0x30>
    5d90:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    5d94:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    5d98:	d912      	bls.n	5dc0 <__aeabi_d2iz+0x3c>
    5d9a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    5d9e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    5da2:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    5da6:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    5daa:	fa23 f002 	lsr.w	r0, r3, r2
    5dae:	bf18      	it	ne
    5db0:	4240      	negne	r0, r0
    5db2:	4770      	bx	lr
    5db4:	f04f 0000 	mov.w	r0, #0
    5db8:	4770      	bx	lr
    5dba:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    5dbe:	d105      	bne.n	5dcc <__aeabi_d2iz+0x48>
    5dc0:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
    5dc4:	bf08      	it	eq
    5dc6:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
    5dca:	4770      	bx	lr
    5dcc:	f04f 0000 	mov.w	r0, #0
    5dd0:	4770      	bx	lr
    5dd2:	bf00      	nop

00005dd4 <__aeabi_d2uiz>:
    5dd4:	004a      	lsls	r2, r1, #1
    5dd6:	d211      	bcs.n	5dfc <__aeabi_d2uiz+0x28>
    5dd8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    5ddc:	d211      	bcs.n	5e02 <__aeabi_d2uiz+0x2e>
    5dde:	d50d      	bpl.n	5dfc <__aeabi_d2uiz+0x28>
    5de0:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    5de4:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    5de8:	d40e      	bmi.n	5e08 <__aeabi_d2uiz+0x34>
    5dea:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    5dee:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    5df2:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    5df6:	fa23 f002 	lsr.w	r0, r3, r2
    5dfa:	4770      	bx	lr
    5dfc:	f04f 0000 	mov.w	r0, #0
    5e00:	4770      	bx	lr
    5e02:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    5e06:	d102      	bne.n	5e0e <__aeabi_d2uiz+0x3a>
    5e08:	f04f 30ff 	mov.w	r0, #4294967295
    5e0c:	4770      	bx	lr
    5e0e:	f04f 0000 	mov.w	r0, #0
    5e12:	4770      	bx	lr

00005e14 <__aeabi_d2f>:
    5e14:	ea4f 0241 	mov.w	r2, r1, lsl #1
    5e18:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    5e1c:	bf24      	itt	cs
    5e1e:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    5e22:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    5e26:	d90d      	bls.n	5e44 <__aeabi_d2f+0x30>
    5e28:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    5e2c:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    5e30:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    5e34:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    5e38:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    5e3c:	bf08      	it	eq
    5e3e:	f020 0001 	biceq.w	r0, r0, #1
    5e42:	4770      	bx	lr
    5e44:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    5e48:	d121      	bne.n	5e8e <__aeabi_d2f+0x7a>
    5e4a:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    5e4e:	bfbc      	itt	lt
    5e50:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    5e54:	4770      	bxlt	lr
    5e56:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    5e5a:	ea4f 5252 	mov.w	r2, r2, lsr #21
    5e5e:	f1c2 0218 	rsb	r2, r2, #24
    5e62:	f1c2 0c20 	rsb	ip, r2, #32
    5e66:	fa10 f30c 	lsls.w	r3, r0, ip
    5e6a:	fa20 f002 	lsr.w	r0, r0, r2
    5e6e:	bf18      	it	ne
    5e70:	f040 0001 	orrne.w	r0, r0, #1
    5e74:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    5e78:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    5e7c:	fa03 fc0c 	lsl.w	ip, r3, ip
    5e80:	ea40 000c 	orr.w	r0, r0, ip
    5e84:	fa23 f302 	lsr.w	r3, r3, r2
    5e88:	ea4f 0343 	mov.w	r3, r3, lsl #1
    5e8c:	e7cc      	b.n	5e28 <__aeabi_d2f+0x14>
    5e8e:	ea7f 5362 	mvns.w	r3, r2, asr #21
    5e92:	d107      	bne.n	5ea4 <__aeabi_d2f+0x90>
    5e94:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    5e98:	bf1e      	ittt	ne
    5e9a:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    5e9e:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    5ea2:	4770      	bxne	lr
    5ea4:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    5ea8:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    5eac:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    5eb0:	4770      	bx	lr
    5eb2:	bf00      	nop

00005eb4 <__aeabi_atexit>:
    5eb4:	460b      	mov	r3, r1
    5eb6:	4601      	mov	r1, r0
    5eb8:	4618      	mov	r0, r3
    5eba:	f000 b801 	b.w	5ec0 <__cxa_atexit>
    5ebe:	bf00      	nop

00005ec0 <__cxa_atexit>:
    5ec0:	4613      	mov	r3, r2
    5ec2:	460a      	mov	r2, r1
    5ec4:	4601      	mov	r1, r0
    5ec6:	2002      	movs	r0, #2
    5ec8:	f000 bb52 	b.w	6570 <__register_exitproc>

00005ecc <__errno>:
    5ecc:	4b01      	ldr	r3, [pc, #4]	; (5ed4 <__errno+0x8>)
    5ece:	6818      	ldr	r0, [r3, #0]
    5ed0:	4770      	bx	lr
    5ed2:	bf00      	nop
    5ed4:	1fff0ec8 	.word	0x1fff0ec8

00005ed8 <__libc_init_array>:
    5ed8:	b570      	push	{r4, r5, r6, lr}
    5eda:	4e0f      	ldr	r6, [pc, #60]	; (5f18 <__libc_init_array+0x40>)
    5edc:	4d0f      	ldr	r5, [pc, #60]	; (5f1c <__libc_init_array+0x44>)
    5ede:	1b76      	subs	r6, r6, r5
    5ee0:	10b6      	asrs	r6, r6, #2
    5ee2:	bf18      	it	ne
    5ee4:	2400      	movne	r4, #0
    5ee6:	d005      	beq.n	5ef4 <__libc_init_array+0x1c>
    5ee8:	3401      	adds	r4, #1
    5eea:	f855 3b04 	ldr.w	r3, [r5], #4
    5eee:	4798      	blx	r3
    5ef0:	42a6      	cmp	r6, r4
    5ef2:	d1f9      	bne.n	5ee8 <__libc_init_array+0x10>
    5ef4:	4e0a      	ldr	r6, [pc, #40]	; (5f20 <__libc_init_array+0x48>)
    5ef6:	4d0b      	ldr	r5, [pc, #44]	; (5f24 <__libc_init_array+0x4c>)
    5ef8:	1b76      	subs	r6, r6, r5
    5efa:	f001 f873 	bl	6fe4 <_init>
    5efe:	10b6      	asrs	r6, r6, #2
    5f00:	bf18      	it	ne
    5f02:	2400      	movne	r4, #0
    5f04:	d006      	beq.n	5f14 <__libc_init_array+0x3c>
    5f06:	3401      	adds	r4, #1
    5f08:	f855 3b04 	ldr.w	r3, [r5], #4
    5f0c:	4798      	blx	r3
    5f0e:	42a6      	cmp	r6, r4
    5f10:	d1f9      	bne.n	5f06 <__libc_init_array+0x2e>
    5f12:	bd70      	pop	{r4, r5, r6, pc}
    5f14:	bd70      	pop	{r4, r5, r6, pc}
    5f16:	bf00      	nop
    5f18:	00006ff0 	.word	0x00006ff0
    5f1c:	00006ff0 	.word	0x00006ff0
    5f20:	00006ffc 	.word	0x00006ffc
    5f24:	00006ff0 	.word	0x00006ff0

00005f28 <malloc>:
    5f28:	4b02      	ldr	r3, [pc, #8]	; (5f34 <malloc+0xc>)
    5f2a:	4601      	mov	r1, r0
    5f2c:	6818      	ldr	r0, [r3, #0]
    5f2e:	f000 b803 	b.w	5f38 <_malloc_r>
    5f32:	bf00      	nop
    5f34:	1fff0ec8 	.word	0x1fff0ec8

00005f38 <_malloc_r>:
    5f38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5f3c:	f101 050b 	add.w	r5, r1, #11
    5f40:	2d16      	cmp	r5, #22
    5f42:	b083      	sub	sp, #12
    5f44:	4606      	mov	r6, r0
    5f46:	f240 809f 	bls.w	6088 <_malloc_r+0x150>
    5f4a:	f035 0507 	bics.w	r5, r5, #7
    5f4e:	f100 80bf 	bmi.w	60d0 <_malloc_r+0x198>
    5f52:	42a9      	cmp	r1, r5
    5f54:	f200 80bc 	bhi.w	60d0 <_malloc_r+0x198>
    5f58:	f000 faf4 	bl	6544 <__malloc_lock>
    5f5c:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
    5f60:	f0c0 829c 	bcc.w	649c <_malloc_r+0x564>
    5f64:	0a6b      	lsrs	r3, r5, #9
    5f66:	f000 80ba 	beq.w	60de <_malloc_r+0x1a6>
    5f6a:	2b04      	cmp	r3, #4
    5f6c:	f200 8183 	bhi.w	6276 <_malloc_r+0x33e>
    5f70:	09a8      	lsrs	r0, r5, #6
    5f72:	f100 0e39 	add.w	lr, r0, #57	; 0x39
    5f76:	ea4f 034e 	mov.w	r3, lr, lsl #1
    5f7a:	3038      	adds	r0, #56	; 0x38
    5f7c:	4fc4      	ldr	r7, [pc, #784]	; (6290 <_malloc_r+0x358>)
    5f7e:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    5f82:	f1a3 0108 	sub.w	r1, r3, #8
    5f86:	685c      	ldr	r4, [r3, #4]
    5f88:	42a1      	cmp	r1, r4
    5f8a:	d107      	bne.n	5f9c <_malloc_r+0x64>
    5f8c:	e0ac      	b.n	60e8 <_malloc_r+0x1b0>
    5f8e:	2a00      	cmp	r2, #0
    5f90:	f280 80ac 	bge.w	60ec <_malloc_r+0x1b4>
    5f94:	68e4      	ldr	r4, [r4, #12]
    5f96:	42a1      	cmp	r1, r4
    5f98:	f000 80a6 	beq.w	60e8 <_malloc_r+0x1b0>
    5f9c:	6863      	ldr	r3, [r4, #4]
    5f9e:	f023 0303 	bic.w	r3, r3, #3
    5fa2:	1b5a      	subs	r2, r3, r5
    5fa4:	2a0f      	cmp	r2, #15
    5fa6:	ddf2      	ble.n	5f8e <_malloc_r+0x56>
    5fa8:	49b9      	ldr	r1, [pc, #740]	; (6290 <_malloc_r+0x358>)
    5faa:	693c      	ldr	r4, [r7, #16]
    5fac:	f101 0e08 	add.w	lr, r1, #8
    5fb0:	4574      	cmp	r4, lr
    5fb2:	f000 81b3 	beq.w	631c <_malloc_r+0x3e4>
    5fb6:	6863      	ldr	r3, [r4, #4]
    5fb8:	f023 0303 	bic.w	r3, r3, #3
    5fbc:	1b5a      	subs	r2, r3, r5
    5fbe:	2a0f      	cmp	r2, #15
    5fc0:	f300 8199 	bgt.w	62f6 <_malloc_r+0x3be>
    5fc4:	2a00      	cmp	r2, #0
    5fc6:	f8c1 e014 	str.w	lr, [r1, #20]
    5fca:	f8c1 e010 	str.w	lr, [r1, #16]
    5fce:	f280 809e 	bge.w	610e <_malloc_r+0x1d6>
    5fd2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    5fd6:	f080 8167 	bcs.w	62a8 <_malloc_r+0x370>
    5fda:	08db      	lsrs	r3, r3, #3
    5fdc:	f103 0c01 	add.w	ip, r3, #1
    5fe0:	2201      	movs	r2, #1
    5fe2:	109b      	asrs	r3, r3, #2
    5fe4:	fa02 f303 	lsl.w	r3, r2, r3
    5fe8:	684a      	ldr	r2, [r1, #4]
    5fea:	f851 803c 	ldr.w	r8, [r1, ip, lsl #3]
    5fee:	f8c4 8008 	str.w	r8, [r4, #8]
    5ff2:	eb01 09cc 	add.w	r9, r1, ip, lsl #3
    5ff6:	431a      	orrs	r2, r3
    5ff8:	f1a9 0308 	sub.w	r3, r9, #8
    5ffc:	60e3      	str	r3, [r4, #12]
    5ffe:	604a      	str	r2, [r1, #4]
    6000:	f841 403c 	str.w	r4, [r1, ip, lsl #3]
    6004:	f8c8 400c 	str.w	r4, [r8, #12]
    6008:	1083      	asrs	r3, r0, #2
    600a:	2401      	movs	r4, #1
    600c:	409c      	lsls	r4, r3
    600e:	4294      	cmp	r4, r2
    6010:	f200 808a 	bhi.w	6128 <_malloc_r+0x1f0>
    6014:	4214      	tst	r4, r2
    6016:	d106      	bne.n	6026 <_malloc_r+0xee>
    6018:	f020 0003 	bic.w	r0, r0, #3
    601c:	0064      	lsls	r4, r4, #1
    601e:	4214      	tst	r4, r2
    6020:	f100 0004 	add.w	r0, r0, #4
    6024:	d0fa      	beq.n	601c <_malloc_r+0xe4>
    6026:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
    602a:	46cc      	mov	ip, r9
    602c:	4680      	mov	r8, r0
    602e:	f8dc 100c 	ldr.w	r1, [ip, #12]
    6032:	458c      	cmp	ip, r1
    6034:	d107      	bne.n	6046 <_malloc_r+0x10e>
    6036:	e173      	b.n	6320 <_malloc_r+0x3e8>
    6038:	2a00      	cmp	r2, #0
    603a:	f280 8181 	bge.w	6340 <_malloc_r+0x408>
    603e:	68c9      	ldr	r1, [r1, #12]
    6040:	458c      	cmp	ip, r1
    6042:	f000 816d 	beq.w	6320 <_malloc_r+0x3e8>
    6046:	684b      	ldr	r3, [r1, #4]
    6048:	f023 0303 	bic.w	r3, r3, #3
    604c:	1b5a      	subs	r2, r3, r5
    604e:	2a0f      	cmp	r2, #15
    6050:	ddf2      	ble.n	6038 <_malloc_r+0x100>
    6052:	460c      	mov	r4, r1
    6054:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    6058:	f854 8f08 	ldr.w	r8, [r4, #8]!
    605c:	194b      	adds	r3, r1, r5
    605e:	f045 0501 	orr.w	r5, r5, #1
    6062:	604d      	str	r5, [r1, #4]
    6064:	f042 0101 	orr.w	r1, r2, #1
    6068:	f8c8 c00c 	str.w	ip, [r8, #12]
    606c:	4630      	mov	r0, r6
    606e:	f8cc 8008 	str.w	r8, [ip, #8]
    6072:	617b      	str	r3, [r7, #20]
    6074:	613b      	str	r3, [r7, #16]
    6076:	f8c3 e00c 	str.w	lr, [r3, #12]
    607a:	f8c3 e008 	str.w	lr, [r3, #8]
    607e:	6059      	str	r1, [r3, #4]
    6080:	509a      	str	r2, [r3, r2]
    6082:	f000 fa61 	bl	6548 <__malloc_unlock>
    6086:	e01f      	b.n	60c8 <_malloc_r+0x190>
    6088:	2910      	cmp	r1, #16
    608a:	d821      	bhi.n	60d0 <_malloc_r+0x198>
    608c:	f000 fa5a 	bl	6544 <__malloc_lock>
    6090:	2510      	movs	r5, #16
    6092:	2306      	movs	r3, #6
    6094:	2002      	movs	r0, #2
    6096:	4f7e      	ldr	r7, [pc, #504]	; (6290 <_malloc_r+0x358>)
    6098:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    609c:	f1a3 0208 	sub.w	r2, r3, #8
    60a0:	685c      	ldr	r4, [r3, #4]
    60a2:	4294      	cmp	r4, r2
    60a4:	f000 8145 	beq.w	6332 <_malloc_r+0x3fa>
    60a8:	6863      	ldr	r3, [r4, #4]
    60aa:	68e1      	ldr	r1, [r4, #12]
    60ac:	68a5      	ldr	r5, [r4, #8]
    60ae:	f023 0303 	bic.w	r3, r3, #3
    60b2:	4423      	add	r3, r4
    60b4:	4630      	mov	r0, r6
    60b6:	685a      	ldr	r2, [r3, #4]
    60b8:	60e9      	str	r1, [r5, #12]
    60ba:	f042 0201 	orr.w	r2, r2, #1
    60be:	608d      	str	r5, [r1, #8]
    60c0:	605a      	str	r2, [r3, #4]
    60c2:	f000 fa41 	bl	6548 <__malloc_unlock>
    60c6:	3408      	adds	r4, #8
    60c8:	4620      	mov	r0, r4
    60ca:	b003      	add	sp, #12
    60cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    60d0:	2400      	movs	r4, #0
    60d2:	230c      	movs	r3, #12
    60d4:	4620      	mov	r0, r4
    60d6:	6033      	str	r3, [r6, #0]
    60d8:	b003      	add	sp, #12
    60da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    60de:	2380      	movs	r3, #128	; 0x80
    60e0:	f04f 0e40 	mov.w	lr, #64	; 0x40
    60e4:	203f      	movs	r0, #63	; 0x3f
    60e6:	e749      	b.n	5f7c <_malloc_r+0x44>
    60e8:	4670      	mov	r0, lr
    60ea:	e75d      	b.n	5fa8 <_malloc_r+0x70>
    60ec:	4423      	add	r3, r4
    60ee:	68e1      	ldr	r1, [r4, #12]
    60f0:	685a      	ldr	r2, [r3, #4]
    60f2:	68a5      	ldr	r5, [r4, #8]
    60f4:	f042 0201 	orr.w	r2, r2, #1
    60f8:	60e9      	str	r1, [r5, #12]
    60fa:	4630      	mov	r0, r6
    60fc:	608d      	str	r5, [r1, #8]
    60fe:	605a      	str	r2, [r3, #4]
    6100:	f000 fa22 	bl	6548 <__malloc_unlock>
    6104:	3408      	adds	r4, #8
    6106:	4620      	mov	r0, r4
    6108:	b003      	add	sp, #12
    610a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    610e:	4423      	add	r3, r4
    6110:	4630      	mov	r0, r6
    6112:	685a      	ldr	r2, [r3, #4]
    6114:	f042 0201 	orr.w	r2, r2, #1
    6118:	605a      	str	r2, [r3, #4]
    611a:	f000 fa15 	bl	6548 <__malloc_unlock>
    611e:	3408      	adds	r4, #8
    6120:	4620      	mov	r0, r4
    6122:	b003      	add	sp, #12
    6124:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6128:	68bc      	ldr	r4, [r7, #8]
    612a:	6863      	ldr	r3, [r4, #4]
    612c:	f023 0803 	bic.w	r8, r3, #3
    6130:	45a8      	cmp	r8, r5
    6132:	d304      	bcc.n	613e <_malloc_r+0x206>
    6134:	ebc5 0308 	rsb	r3, r5, r8
    6138:	2b0f      	cmp	r3, #15
    613a:	f300 808c 	bgt.w	6256 <_malloc_r+0x31e>
    613e:	4b55      	ldr	r3, [pc, #340]	; (6294 <_malloc_r+0x35c>)
    6140:	f8df 9160 	ldr.w	r9, [pc, #352]	; 62a4 <_malloc_r+0x36c>
    6144:	681a      	ldr	r2, [r3, #0]
    6146:	f8d9 3000 	ldr.w	r3, [r9]
    614a:	3301      	adds	r3, #1
    614c:	442a      	add	r2, r5
    614e:	eb04 0a08 	add.w	sl, r4, r8
    6152:	f000 8160 	beq.w	6416 <_malloc_r+0x4de>
    6156:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    615a:	320f      	adds	r2, #15
    615c:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
    6160:	f022 020f 	bic.w	r2, r2, #15
    6164:	4611      	mov	r1, r2
    6166:	4630      	mov	r0, r6
    6168:	9201      	str	r2, [sp, #4]
    616a:	f000 f9ef 	bl	654c <_sbrk_r>
    616e:	f1b0 3fff 	cmp.w	r0, #4294967295
    6172:	4683      	mov	fp, r0
    6174:	9a01      	ldr	r2, [sp, #4]
    6176:	f000 8158 	beq.w	642a <_malloc_r+0x4f2>
    617a:	4582      	cmp	sl, r0
    617c:	f200 80fc 	bhi.w	6378 <_malloc_r+0x440>
    6180:	4b45      	ldr	r3, [pc, #276]	; (6298 <_malloc_r+0x360>)
    6182:	6819      	ldr	r1, [r3, #0]
    6184:	45da      	cmp	sl, fp
    6186:	4411      	add	r1, r2
    6188:	6019      	str	r1, [r3, #0]
    618a:	f000 8153 	beq.w	6434 <_malloc_r+0x4fc>
    618e:	f8d9 0000 	ldr.w	r0, [r9]
    6192:	f8df e110 	ldr.w	lr, [pc, #272]	; 62a4 <_malloc_r+0x36c>
    6196:	3001      	adds	r0, #1
    6198:	bf1b      	ittet	ne
    619a:	ebca 0a0b 	rsbne	sl, sl, fp
    619e:	4451      	addne	r1, sl
    61a0:	f8ce b000 	streq.w	fp, [lr]
    61a4:	6019      	strne	r1, [r3, #0]
    61a6:	f01b 0107 	ands.w	r1, fp, #7
    61aa:	f000 8117 	beq.w	63dc <_malloc_r+0x4a4>
    61ae:	f1c1 0008 	rsb	r0, r1, #8
    61b2:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
    61b6:	4483      	add	fp, r0
    61b8:	3108      	adds	r1, #8
    61ba:	445a      	add	r2, fp
    61bc:	f3c2 020b 	ubfx	r2, r2, #0, #12
    61c0:	ebc2 0901 	rsb	r9, r2, r1
    61c4:	4649      	mov	r1, r9
    61c6:	4630      	mov	r0, r6
    61c8:	9301      	str	r3, [sp, #4]
    61ca:	f000 f9bf 	bl	654c <_sbrk_r>
    61ce:	1c43      	adds	r3, r0, #1
    61d0:	9b01      	ldr	r3, [sp, #4]
    61d2:	f000 813f 	beq.w	6454 <_malloc_r+0x51c>
    61d6:	ebcb 0200 	rsb	r2, fp, r0
    61da:	444a      	add	r2, r9
    61dc:	f042 0201 	orr.w	r2, r2, #1
    61e0:	6819      	ldr	r1, [r3, #0]
    61e2:	f8c7 b008 	str.w	fp, [r7, #8]
    61e6:	4449      	add	r1, r9
    61e8:	42bc      	cmp	r4, r7
    61ea:	f8cb 2004 	str.w	r2, [fp, #4]
    61ee:	6019      	str	r1, [r3, #0]
    61f0:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 6298 <_malloc_r+0x360>
    61f4:	d016      	beq.n	6224 <_malloc_r+0x2ec>
    61f6:	f1b8 0f0f 	cmp.w	r8, #15
    61fa:	f240 80fd 	bls.w	63f8 <_malloc_r+0x4c0>
    61fe:	6862      	ldr	r2, [r4, #4]
    6200:	f1a8 030c 	sub.w	r3, r8, #12
    6204:	f023 0307 	bic.w	r3, r3, #7
    6208:	18e0      	adds	r0, r4, r3
    620a:	f002 0201 	and.w	r2, r2, #1
    620e:	f04f 0e05 	mov.w	lr, #5
    6212:	431a      	orrs	r2, r3
    6214:	2b0f      	cmp	r3, #15
    6216:	6062      	str	r2, [r4, #4]
    6218:	f8c0 e004 	str.w	lr, [r0, #4]
    621c:	f8c0 e008 	str.w	lr, [r0, #8]
    6220:	f200 811c 	bhi.w	645c <_malloc_r+0x524>
    6224:	4b1d      	ldr	r3, [pc, #116]	; (629c <_malloc_r+0x364>)
    6226:	68bc      	ldr	r4, [r7, #8]
    6228:	681a      	ldr	r2, [r3, #0]
    622a:	4291      	cmp	r1, r2
    622c:	bf88      	it	hi
    622e:	6019      	strhi	r1, [r3, #0]
    6230:	4b1b      	ldr	r3, [pc, #108]	; (62a0 <_malloc_r+0x368>)
    6232:	681a      	ldr	r2, [r3, #0]
    6234:	4291      	cmp	r1, r2
    6236:	6862      	ldr	r2, [r4, #4]
    6238:	bf88      	it	hi
    623a:	6019      	strhi	r1, [r3, #0]
    623c:	f022 0203 	bic.w	r2, r2, #3
    6240:	4295      	cmp	r5, r2
    6242:	eba2 0305 	sub.w	r3, r2, r5
    6246:	d801      	bhi.n	624c <_malloc_r+0x314>
    6248:	2b0f      	cmp	r3, #15
    624a:	dc04      	bgt.n	6256 <_malloc_r+0x31e>
    624c:	4630      	mov	r0, r6
    624e:	f000 f97b 	bl	6548 <__malloc_unlock>
    6252:	2400      	movs	r4, #0
    6254:	e738      	b.n	60c8 <_malloc_r+0x190>
    6256:	1962      	adds	r2, r4, r5
    6258:	f043 0301 	orr.w	r3, r3, #1
    625c:	f045 0501 	orr.w	r5, r5, #1
    6260:	6065      	str	r5, [r4, #4]
    6262:	4630      	mov	r0, r6
    6264:	60ba      	str	r2, [r7, #8]
    6266:	6053      	str	r3, [r2, #4]
    6268:	f000 f96e 	bl	6548 <__malloc_unlock>
    626c:	3408      	adds	r4, #8
    626e:	4620      	mov	r0, r4
    6270:	b003      	add	sp, #12
    6272:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6276:	2b14      	cmp	r3, #20
    6278:	d971      	bls.n	635e <_malloc_r+0x426>
    627a:	2b54      	cmp	r3, #84	; 0x54
    627c:	f200 80a4 	bhi.w	63c8 <_malloc_r+0x490>
    6280:	0b28      	lsrs	r0, r5, #12
    6282:	f100 0e6f 	add.w	lr, r0, #111	; 0x6f
    6286:	ea4f 034e 	mov.w	r3, lr, lsl #1
    628a:	306e      	adds	r0, #110	; 0x6e
    628c:	e676      	b.n	5f7c <_malloc_r+0x44>
    628e:	bf00      	nop
    6290:	1fff0ecc 	.word	0x1fff0ecc
    6294:	1fff1a40 	.word	0x1fff1a40
    6298:	1fff1a44 	.word	0x1fff1a44
    629c:	1fff1a3c 	.word	0x1fff1a3c
    62a0:	1fff1a38 	.word	0x1fff1a38
    62a4:	1fff12d8 	.word	0x1fff12d8
    62a8:	0a5a      	lsrs	r2, r3, #9
    62aa:	2a04      	cmp	r2, #4
    62ac:	d95e      	bls.n	636c <_malloc_r+0x434>
    62ae:	2a14      	cmp	r2, #20
    62b0:	f200 80b3 	bhi.w	641a <_malloc_r+0x4e2>
    62b4:	f102 015c 	add.w	r1, r2, #92	; 0x5c
    62b8:	0049      	lsls	r1, r1, #1
    62ba:	325b      	adds	r2, #91	; 0x5b
    62bc:	eb07 0c81 	add.w	ip, r7, r1, lsl #2
    62c0:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
    62c4:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 64a4 <_malloc_r+0x56c>
    62c8:	f1ac 0c08 	sub.w	ip, ip, #8
    62cc:	458c      	cmp	ip, r1
    62ce:	f000 8088 	beq.w	63e2 <_malloc_r+0x4aa>
    62d2:	684a      	ldr	r2, [r1, #4]
    62d4:	f022 0203 	bic.w	r2, r2, #3
    62d8:	4293      	cmp	r3, r2
    62da:	d202      	bcs.n	62e2 <_malloc_r+0x3aa>
    62dc:	6889      	ldr	r1, [r1, #8]
    62de:	458c      	cmp	ip, r1
    62e0:	d1f7      	bne.n	62d2 <_malloc_r+0x39a>
    62e2:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    62e6:	687a      	ldr	r2, [r7, #4]
    62e8:	f8c4 c00c 	str.w	ip, [r4, #12]
    62ec:	60a1      	str	r1, [r4, #8]
    62ee:	f8cc 4008 	str.w	r4, [ip, #8]
    62f2:	60cc      	str	r4, [r1, #12]
    62f4:	e688      	b.n	6008 <_malloc_r+0xd0>
    62f6:	1963      	adds	r3, r4, r5
    62f8:	f042 0701 	orr.w	r7, r2, #1
    62fc:	f045 0501 	orr.w	r5, r5, #1
    6300:	6065      	str	r5, [r4, #4]
    6302:	4630      	mov	r0, r6
    6304:	614b      	str	r3, [r1, #20]
    6306:	610b      	str	r3, [r1, #16]
    6308:	f8c3 e00c 	str.w	lr, [r3, #12]
    630c:	f8c3 e008 	str.w	lr, [r3, #8]
    6310:	605f      	str	r7, [r3, #4]
    6312:	509a      	str	r2, [r3, r2]
    6314:	3408      	adds	r4, #8
    6316:	f000 f917 	bl	6548 <__malloc_unlock>
    631a:	e6d5      	b.n	60c8 <_malloc_r+0x190>
    631c:	684a      	ldr	r2, [r1, #4]
    631e:	e673      	b.n	6008 <_malloc_r+0xd0>
    6320:	f108 0801 	add.w	r8, r8, #1
    6324:	f018 0f03 	tst.w	r8, #3
    6328:	f10c 0c08 	add.w	ip, ip, #8
    632c:	f47f ae7f 	bne.w	602e <_malloc_r+0xf6>
    6330:	e030      	b.n	6394 <_malloc_r+0x45c>
    6332:	68dc      	ldr	r4, [r3, #12]
    6334:	42a3      	cmp	r3, r4
    6336:	bf08      	it	eq
    6338:	3002      	addeq	r0, #2
    633a:	f43f ae35 	beq.w	5fa8 <_malloc_r+0x70>
    633e:	e6b3      	b.n	60a8 <_malloc_r+0x170>
    6340:	440b      	add	r3, r1
    6342:	460c      	mov	r4, r1
    6344:	685a      	ldr	r2, [r3, #4]
    6346:	68c9      	ldr	r1, [r1, #12]
    6348:	f854 5f08 	ldr.w	r5, [r4, #8]!
    634c:	f042 0201 	orr.w	r2, r2, #1
    6350:	605a      	str	r2, [r3, #4]
    6352:	4630      	mov	r0, r6
    6354:	60e9      	str	r1, [r5, #12]
    6356:	608d      	str	r5, [r1, #8]
    6358:	f000 f8f6 	bl	6548 <__malloc_unlock>
    635c:	e6b4      	b.n	60c8 <_malloc_r+0x190>
    635e:	f103 0e5c 	add.w	lr, r3, #92	; 0x5c
    6362:	f103 005b 	add.w	r0, r3, #91	; 0x5b
    6366:	ea4f 034e 	mov.w	r3, lr, lsl #1
    636a:	e607      	b.n	5f7c <_malloc_r+0x44>
    636c:	099a      	lsrs	r2, r3, #6
    636e:	f102 0139 	add.w	r1, r2, #57	; 0x39
    6372:	0049      	lsls	r1, r1, #1
    6374:	3238      	adds	r2, #56	; 0x38
    6376:	e7a1      	b.n	62bc <_malloc_r+0x384>
    6378:	42bc      	cmp	r4, r7
    637a:	4b4a      	ldr	r3, [pc, #296]	; (64a4 <_malloc_r+0x56c>)
    637c:	f43f af00 	beq.w	6180 <_malloc_r+0x248>
    6380:	689c      	ldr	r4, [r3, #8]
    6382:	6862      	ldr	r2, [r4, #4]
    6384:	f022 0203 	bic.w	r2, r2, #3
    6388:	e75a      	b.n	6240 <_malloc_r+0x308>
    638a:	f859 3908 	ldr.w	r3, [r9], #-8
    638e:	4599      	cmp	r9, r3
    6390:	f040 8082 	bne.w	6498 <_malloc_r+0x560>
    6394:	f010 0f03 	tst.w	r0, #3
    6398:	f100 30ff 	add.w	r0, r0, #4294967295
    639c:	d1f5      	bne.n	638a <_malloc_r+0x452>
    639e:	687b      	ldr	r3, [r7, #4]
    63a0:	ea23 0304 	bic.w	r3, r3, r4
    63a4:	607b      	str	r3, [r7, #4]
    63a6:	0064      	lsls	r4, r4, #1
    63a8:	429c      	cmp	r4, r3
    63aa:	f63f aebd 	bhi.w	6128 <_malloc_r+0x1f0>
    63ae:	2c00      	cmp	r4, #0
    63b0:	f43f aeba 	beq.w	6128 <_malloc_r+0x1f0>
    63b4:	421c      	tst	r4, r3
    63b6:	4640      	mov	r0, r8
    63b8:	f47f ae35 	bne.w	6026 <_malloc_r+0xee>
    63bc:	0064      	lsls	r4, r4, #1
    63be:	421c      	tst	r4, r3
    63c0:	f100 0004 	add.w	r0, r0, #4
    63c4:	d0fa      	beq.n	63bc <_malloc_r+0x484>
    63c6:	e62e      	b.n	6026 <_malloc_r+0xee>
    63c8:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    63cc:	d818      	bhi.n	6400 <_malloc_r+0x4c8>
    63ce:	0be8      	lsrs	r0, r5, #15
    63d0:	f100 0e78 	add.w	lr, r0, #120	; 0x78
    63d4:	ea4f 034e 	mov.w	r3, lr, lsl #1
    63d8:	3077      	adds	r0, #119	; 0x77
    63da:	e5cf      	b.n	5f7c <_malloc_r+0x44>
    63dc:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    63e0:	e6eb      	b.n	61ba <_malloc_r+0x282>
    63e2:	2101      	movs	r1, #1
    63e4:	f8d8 3004 	ldr.w	r3, [r8, #4]
    63e8:	1092      	asrs	r2, r2, #2
    63ea:	fa01 f202 	lsl.w	r2, r1, r2
    63ee:	431a      	orrs	r2, r3
    63f0:	f8c8 2004 	str.w	r2, [r8, #4]
    63f4:	4661      	mov	r1, ip
    63f6:	e777      	b.n	62e8 <_malloc_r+0x3b0>
    63f8:	2301      	movs	r3, #1
    63fa:	f8cb 3004 	str.w	r3, [fp, #4]
    63fe:	e725      	b.n	624c <_malloc_r+0x314>
    6400:	f240 5254 	movw	r2, #1364	; 0x554
    6404:	4293      	cmp	r3, r2
    6406:	d820      	bhi.n	644a <_malloc_r+0x512>
    6408:	0ca8      	lsrs	r0, r5, #18
    640a:	f100 0e7d 	add.w	lr, r0, #125	; 0x7d
    640e:	ea4f 034e 	mov.w	r3, lr, lsl #1
    6412:	307c      	adds	r0, #124	; 0x7c
    6414:	e5b2      	b.n	5f7c <_malloc_r+0x44>
    6416:	3210      	adds	r2, #16
    6418:	e6a4      	b.n	6164 <_malloc_r+0x22c>
    641a:	2a54      	cmp	r2, #84	; 0x54
    641c:	d826      	bhi.n	646c <_malloc_r+0x534>
    641e:	0b1a      	lsrs	r2, r3, #12
    6420:	f102 016f 	add.w	r1, r2, #111	; 0x6f
    6424:	0049      	lsls	r1, r1, #1
    6426:	326e      	adds	r2, #110	; 0x6e
    6428:	e748      	b.n	62bc <_malloc_r+0x384>
    642a:	68bc      	ldr	r4, [r7, #8]
    642c:	6862      	ldr	r2, [r4, #4]
    642e:	f022 0203 	bic.w	r2, r2, #3
    6432:	e705      	b.n	6240 <_malloc_r+0x308>
    6434:	f3ca 000b 	ubfx	r0, sl, #0, #12
    6438:	2800      	cmp	r0, #0
    643a:	f47f aea8 	bne.w	618e <_malloc_r+0x256>
    643e:	4442      	add	r2, r8
    6440:	68bb      	ldr	r3, [r7, #8]
    6442:	f042 0201 	orr.w	r2, r2, #1
    6446:	605a      	str	r2, [r3, #4]
    6448:	e6ec      	b.n	6224 <_malloc_r+0x2ec>
    644a:	23fe      	movs	r3, #254	; 0xfe
    644c:	f04f 0e7f 	mov.w	lr, #127	; 0x7f
    6450:	207e      	movs	r0, #126	; 0x7e
    6452:	e593      	b.n	5f7c <_malloc_r+0x44>
    6454:	2201      	movs	r2, #1
    6456:	f04f 0900 	mov.w	r9, #0
    645a:	e6c1      	b.n	61e0 <_malloc_r+0x2a8>
    645c:	f104 0108 	add.w	r1, r4, #8
    6460:	4630      	mov	r0, r6
    6462:	f000 f949 	bl	66f8 <_free_r>
    6466:	f8d9 1000 	ldr.w	r1, [r9]
    646a:	e6db      	b.n	6224 <_malloc_r+0x2ec>
    646c:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    6470:	d805      	bhi.n	647e <_malloc_r+0x546>
    6472:	0bda      	lsrs	r2, r3, #15
    6474:	f102 0178 	add.w	r1, r2, #120	; 0x78
    6478:	0049      	lsls	r1, r1, #1
    647a:	3277      	adds	r2, #119	; 0x77
    647c:	e71e      	b.n	62bc <_malloc_r+0x384>
    647e:	f240 5154 	movw	r1, #1364	; 0x554
    6482:	428a      	cmp	r2, r1
    6484:	d805      	bhi.n	6492 <_malloc_r+0x55a>
    6486:	0c9a      	lsrs	r2, r3, #18
    6488:	f102 017d 	add.w	r1, r2, #125	; 0x7d
    648c:	0049      	lsls	r1, r1, #1
    648e:	327c      	adds	r2, #124	; 0x7c
    6490:	e714      	b.n	62bc <_malloc_r+0x384>
    6492:	21fe      	movs	r1, #254	; 0xfe
    6494:	227e      	movs	r2, #126	; 0x7e
    6496:	e711      	b.n	62bc <_malloc_r+0x384>
    6498:	687b      	ldr	r3, [r7, #4]
    649a:	e784      	b.n	63a6 <_malloc_r+0x46e>
    649c:	08e8      	lsrs	r0, r5, #3
    649e:	1c43      	adds	r3, r0, #1
    64a0:	005b      	lsls	r3, r3, #1
    64a2:	e5f8      	b.n	6096 <_malloc_r+0x15e>
    64a4:	1fff0ecc 	.word	0x1fff0ecc

000064a8 <memset>:
    64a8:	b470      	push	{r4, r5, r6}
    64aa:	0784      	lsls	r4, r0, #30
    64ac:	d046      	beq.n	653c <memset+0x94>
    64ae:	1e54      	subs	r4, r2, #1
    64b0:	2a00      	cmp	r2, #0
    64b2:	d041      	beq.n	6538 <memset+0x90>
    64b4:	b2cd      	uxtb	r5, r1
    64b6:	4603      	mov	r3, r0
    64b8:	e002      	b.n	64c0 <memset+0x18>
    64ba:	1e62      	subs	r2, r4, #1
    64bc:	b3e4      	cbz	r4, 6538 <memset+0x90>
    64be:	4614      	mov	r4, r2
    64c0:	f803 5b01 	strb.w	r5, [r3], #1
    64c4:	079a      	lsls	r2, r3, #30
    64c6:	d1f8      	bne.n	64ba <memset+0x12>
    64c8:	2c03      	cmp	r4, #3
    64ca:	d92e      	bls.n	652a <memset+0x82>
    64cc:	b2cd      	uxtb	r5, r1
    64ce:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    64d2:	2c0f      	cmp	r4, #15
    64d4:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    64d8:	d919      	bls.n	650e <memset+0x66>
    64da:	f103 0210 	add.w	r2, r3, #16
    64de:	4626      	mov	r6, r4
    64e0:	3e10      	subs	r6, #16
    64e2:	2e0f      	cmp	r6, #15
    64e4:	f842 5c10 	str.w	r5, [r2, #-16]
    64e8:	f842 5c0c 	str.w	r5, [r2, #-12]
    64ec:	f842 5c08 	str.w	r5, [r2, #-8]
    64f0:	f842 5c04 	str.w	r5, [r2, #-4]
    64f4:	f102 0210 	add.w	r2, r2, #16
    64f8:	d8f2      	bhi.n	64e0 <memset+0x38>
    64fa:	f1a4 0210 	sub.w	r2, r4, #16
    64fe:	f022 020f 	bic.w	r2, r2, #15
    6502:	f004 040f 	and.w	r4, r4, #15
    6506:	3210      	adds	r2, #16
    6508:	2c03      	cmp	r4, #3
    650a:	4413      	add	r3, r2
    650c:	d90d      	bls.n	652a <memset+0x82>
    650e:	461e      	mov	r6, r3
    6510:	4622      	mov	r2, r4
    6512:	3a04      	subs	r2, #4
    6514:	2a03      	cmp	r2, #3
    6516:	f846 5b04 	str.w	r5, [r6], #4
    651a:	d8fa      	bhi.n	6512 <memset+0x6a>
    651c:	1f22      	subs	r2, r4, #4
    651e:	f022 0203 	bic.w	r2, r2, #3
    6522:	3204      	adds	r2, #4
    6524:	4413      	add	r3, r2
    6526:	f004 0403 	and.w	r4, r4, #3
    652a:	b12c      	cbz	r4, 6538 <memset+0x90>
    652c:	b2c9      	uxtb	r1, r1
    652e:	441c      	add	r4, r3
    6530:	f803 1b01 	strb.w	r1, [r3], #1
    6534:	42a3      	cmp	r3, r4
    6536:	d1fb      	bne.n	6530 <memset+0x88>
    6538:	bc70      	pop	{r4, r5, r6}
    653a:	4770      	bx	lr
    653c:	4614      	mov	r4, r2
    653e:	4603      	mov	r3, r0
    6540:	e7c2      	b.n	64c8 <memset+0x20>
    6542:	bf00      	nop

00006544 <__malloc_lock>:
    6544:	4770      	bx	lr
    6546:	bf00      	nop

00006548 <__malloc_unlock>:
    6548:	4770      	bx	lr
    654a:	bf00      	nop

0000654c <_sbrk_r>:
    654c:	b538      	push	{r3, r4, r5, lr}
    654e:	4c07      	ldr	r4, [pc, #28]	; (656c <_sbrk_r+0x20>)
    6550:	2300      	movs	r3, #0
    6552:	4605      	mov	r5, r0
    6554:	4608      	mov	r0, r1
    6556:	6023      	str	r3, [r4, #0]
    6558:	f7fb fbd4 	bl	1d04 <_sbrk>
    655c:	1c43      	adds	r3, r0, #1
    655e:	d000      	beq.n	6562 <_sbrk_r+0x16>
    6560:	bd38      	pop	{r3, r4, r5, pc}
    6562:	6823      	ldr	r3, [r4, #0]
    6564:	2b00      	cmp	r3, #0
    6566:	d0fb      	beq.n	6560 <_sbrk_r+0x14>
    6568:	602b      	str	r3, [r5, #0]
    656a:	bd38      	pop	{r3, r4, r5, pc}
    656c:	1fff1a80 	.word	0x1fff1a80

00006570 <__register_exitproc>:
    6570:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6574:	4c25      	ldr	r4, [pc, #148]	; (660c <__register_exitproc+0x9c>)
    6576:	6825      	ldr	r5, [r4, #0]
    6578:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
    657c:	4606      	mov	r6, r0
    657e:	4688      	mov	r8, r1
    6580:	4692      	mov	sl, r2
    6582:	4699      	mov	r9, r3
    6584:	b3c4      	cbz	r4, 65f8 <__register_exitproc+0x88>
    6586:	6860      	ldr	r0, [r4, #4]
    6588:	281f      	cmp	r0, #31
    658a:	dc17      	bgt.n	65bc <__register_exitproc+0x4c>
    658c:	1c43      	adds	r3, r0, #1
    658e:	b176      	cbz	r6, 65ae <__register_exitproc+0x3e>
    6590:	eb04 0580 	add.w	r5, r4, r0, lsl #2
    6594:	2201      	movs	r2, #1
    6596:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
    659a:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
    659e:	4082      	lsls	r2, r0
    65a0:	4311      	orrs	r1, r2
    65a2:	2e02      	cmp	r6, #2
    65a4:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
    65a8:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
    65ac:	d01e      	beq.n	65ec <__register_exitproc+0x7c>
    65ae:	3002      	adds	r0, #2
    65b0:	6063      	str	r3, [r4, #4]
    65b2:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
    65b6:	2000      	movs	r0, #0
    65b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    65bc:	4b14      	ldr	r3, [pc, #80]	; (6610 <__register_exitproc+0xa0>)
    65be:	b303      	cbz	r3, 6602 <__register_exitproc+0x92>
    65c0:	f44f 70c8 	mov.w	r0, #400	; 0x190
    65c4:	f7ff fcb0 	bl	5f28 <malloc>
    65c8:	4604      	mov	r4, r0
    65ca:	b1d0      	cbz	r0, 6602 <__register_exitproc+0x92>
    65cc:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
    65d0:	2700      	movs	r7, #0
    65d2:	e880 0088 	stmia.w	r0, {r3, r7}
    65d6:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    65da:	4638      	mov	r0, r7
    65dc:	2301      	movs	r3, #1
    65de:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
    65e2:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
    65e6:	2e00      	cmp	r6, #0
    65e8:	d0e1      	beq.n	65ae <__register_exitproc+0x3e>
    65ea:	e7d1      	b.n	6590 <__register_exitproc+0x20>
    65ec:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
    65f0:	430a      	orrs	r2, r1
    65f2:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    65f6:	e7da      	b.n	65ae <__register_exitproc+0x3e>
    65f8:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
    65fc:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    6600:	e7c1      	b.n	6586 <__register_exitproc+0x16>
    6602:	f04f 30ff 	mov.w	r0, #4294967295
    6606:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    660a:	bf00      	nop
    660c:	00006fe0 	.word	0x00006fe0
    6610:	00005f29 	.word	0x00005f29

00006614 <register_fini>:
    6614:	4b02      	ldr	r3, [pc, #8]	; (6620 <register_fini+0xc>)
    6616:	b113      	cbz	r3, 661e <register_fini+0xa>
    6618:	4802      	ldr	r0, [pc, #8]	; (6624 <register_fini+0x10>)
    661a:	f000 b805 	b.w	6628 <atexit>
    661e:	4770      	bx	lr
    6620:	00000000 	.word	0x00000000
    6624:	00006635 	.word	0x00006635

00006628 <atexit>:
    6628:	2300      	movs	r3, #0
    662a:	4601      	mov	r1, r0
    662c:	461a      	mov	r2, r3
    662e:	4618      	mov	r0, r3
    6630:	f7ff bf9e 	b.w	6570 <__register_exitproc>

00006634 <__libc_fini_array>:
    6634:	b538      	push	{r3, r4, r5, lr}
    6636:	4d07      	ldr	r5, [pc, #28]	; (6654 <__libc_fini_array+0x20>)
    6638:	4c07      	ldr	r4, [pc, #28]	; (6658 <__libc_fini_array+0x24>)
    663a:	1b2c      	subs	r4, r5, r4
    663c:	10a4      	asrs	r4, r4, #2
    663e:	d005      	beq.n	664c <__libc_fini_array+0x18>
    6640:	3c01      	subs	r4, #1
    6642:	f855 3d04 	ldr.w	r3, [r5, #-4]!
    6646:	4798      	blx	r3
    6648:	2c00      	cmp	r4, #0
    664a:	d1f9      	bne.n	6640 <__libc_fini_array+0xc>
    664c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    6650:	f000 bcd4 	b.w	6ffc <__init_array_end>
	...

0000665c <_malloc_trim_r>:
    665c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    665e:	4f23      	ldr	r7, [pc, #140]	; (66ec <_malloc_trim_r+0x90>)
    6660:	460c      	mov	r4, r1
    6662:	4606      	mov	r6, r0
    6664:	f7ff ff6e 	bl	6544 <__malloc_lock>
    6668:	68bb      	ldr	r3, [r7, #8]
    666a:	685d      	ldr	r5, [r3, #4]
    666c:	f025 0503 	bic.w	r5, r5, #3
    6670:	1b29      	subs	r1, r5, r4
    6672:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
    6676:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
    667a:	f021 010f 	bic.w	r1, r1, #15
    667e:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
    6682:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    6686:	db07      	blt.n	6698 <_malloc_trim_r+0x3c>
    6688:	2100      	movs	r1, #0
    668a:	4630      	mov	r0, r6
    668c:	f7ff ff5e 	bl	654c <_sbrk_r>
    6690:	68bb      	ldr	r3, [r7, #8]
    6692:	442b      	add	r3, r5
    6694:	4298      	cmp	r0, r3
    6696:	d004      	beq.n	66a2 <_malloc_trim_r+0x46>
    6698:	4630      	mov	r0, r6
    669a:	f7ff ff55 	bl	6548 <__malloc_unlock>
    669e:	2000      	movs	r0, #0
    66a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    66a2:	4261      	negs	r1, r4
    66a4:	4630      	mov	r0, r6
    66a6:	f7ff ff51 	bl	654c <_sbrk_r>
    66aa:	3001      	adds	r0, #1
    66ac:	d00d      	beq.n	66ca <_malloc_trim_r+0x6e>
    66ae:	4b10      	ldr	r3, [pc, #64]	; (66f0 <_malloc_trim_r+0x94>)
    66b0:	68ba      	ldr	r2, [r7, #8]
    66b2:	6819      	ldr	r1, [r3, #0]
    66b4:	1b2d      	subs	r5, r5, r4
    66b6:	f045 0501 	orr.w	r5, r5, #1
    66ba:	4630      	mov	r0, r6
    66bc:	1b09      	subs	r1, r1, r4
    66be:	6055      	str	r5, [r2, #4]
    66c0:	6019      	str	r1, [r3, #0]
    66c2:	f7ff ff41 	bl	6548 <__malloc_unlock>
    66c6:	2001      	movs	r0, #1
    66c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    66ca:	2100      	movs	r1, #0
    66cc:	4630      	mov	r0, r6
    66ce:	f7ff ff3d 	bl	654c <_sbrk_r>
    66d2:	68ba      	ldr	r2, [r7, #8]
    66d4:	1a83      	subs	r3, r0, r2
    66d6:	2b0f      	cmp	r3, #15
    66d8:	ddde      	ble.n	6698 <_malloc_trim_r+0x3c>
    66da:	4c06      	ldr	r4, [pc, #24]	; (66f4 <_malloc_trim_r+0x98>)
    66dc:	4904      	ldr	r1, [pc, #16]	; (66f0 <_malloc_trim_r+0x94>)
    66de:	6824      	ldr	r4, [r4, #0]
    66e0:	f043 0301 	orr.w	r3, r3, #1
    66e4:	1b00      	subs	r0, r0, r4
    66e6:	6053      	str	r3, [r2, #4]
    66e8:	6008      	str	r0, [r1, #0]
    66ea:	e7d5      	b.n	6698 <_malloc_trim_r+0x3c>
    66ec:	1fff0ecc 	.word	0x1fff0ecc
    66f0:	1fff1a44 	.word	0x1fff1a44
    66f4:	1fff12d8 	.word	0x1fff12d8

000066f8 <_free_r>:
    66f8:	2900      	cmp	r1, #0
    66fa:	d045      	beq.n	6788 <_free_r+0x90>
    66fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6700:	460d      	mov	r5, r1
    6702:	4680      	mov	r8, r0
    6704:	f7ff ff1e 	bl	6544 <__malloc_lock>
    6708:	f855 7c04 	ldr.w	r7, [r5, #-4]
    670c:	496a      	ldr	r1, [pc, #424]	; (68b8 <_free_r+0x1c0>)
    670e:	f027 0301 	bic.w	r3, r7, #1
    6712:	f1a5 0408 	sub.w	r4, r5, #8
    6716:	18e2      	adds	r2, r4, r3
    6718:	688e      	ldr	r6, [r1, #8]
    671a:	6850      	ldr	r0, [r2, #4]
    671c:	42b2      	cmp	r2, r6
    671e:	f020 0003 	bic.w	r0, r0, #3
    6722:	d062      	beq.n	67ea <_free_r+0xf2>
    6724:	07fe      	lsls	r6, r7, #31
    6726:	6050      	str	r0, [r2, #4]
    6728:	d40b      	bmi.n	6742 <_free_r+0x4a>
    672a:	f855 7c08 	ldr.w	r7, [r5, #-8]
    672e:	1be4      	subs	r4, r4, r7
    6730:	f101 0e08 	add.w	lr, r1, #8
    6734:	68a5      	ldr	r5, [r4, #8]
    6736:	4575      	cmp	r5, lr
    6738:	443b      	add	r3, r7
    673a:	d06f      	beq.n	681c <_free_r+0x124>
    673c:	68e7      	ldr	r7, [r4, #12]
    673e:	60ef      	str	r7, [r5, #12]
    6740:	60bd      	str	r5, [r7, #8]
    6742:	1815      	adds	r5, r2, r0
    6744:	686d      	ldr	r5, [r5, #4]
    6746:	07ed      	lsls	r5, r5, #31
    6748:	d542      	bpl.n	67d0 <_free_r+0xd8>
    674a:	f043 0201 	orr.w	r2, r3, #1
    674e:	6062      	str	r2, [r4, #4]
    6750:	50e3      	str	r3, [r4, r3]
    6752:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    6756:	d218      	bcs.n	678a <_free_r+0x92>
    6758:	08db      	lsrs	r3, r3, #3
    675a:	1c5a      	adds	r2, r3, #1
    675c:	684d      	ldr	r5, [r1, #4]
    675e:	f851 7032 	ldr.w	r7, [r1, r2, lsl #3]
    6762:	60a7      	str	r7, [r4, #8]
    6764:	2001      	movs	r0, #1
    6766:	109b      	asrs	r3, r3, #2
    6768:	fa00 f303 	lsl.w	r3, r0, r3
    676c:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
    6770:	431d      	orrs	r5, r3
    6772:	3808      	subs	r0, #8
    6774:	60e0      	str	r0, [r4, #12]
    6776:	604d      	str	r5, [r1, #4]
    6778:	f841 4032 	str.w	r4, [r1, r2, lsl #3]
    677c:	60fc      	str	r4, [r7, #12]
    677e:	4640      	mov	r0, r8
    6780:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    6784:	f7ff bee0 	b.w	6548 <__malloc_unlock>
    6788:	4770      	bx	lr
    678a:	0a5a      	lsrs	r2, r3, #9
    678c:	2a04      	cmp	r2, #4
    678e:	d853      	bhi.n	6838 <_free_r+0x140>
    6790:	099a      	lsrs	r2, r3, #6
    6792:	f102 0739 	add.w	r7, r2, #57	; 0x39
    6796:	007f      	lsls	r7, r7, #1
    6798:	f102 0538 	add.w	r5, r2, #56	; 0x38
    679c:	eb01 0087 	add.w	r0, r1, r7, lsl #2
    67a0:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
    67a4:	4944      	ldr	r1, [pc, #272]	; (68b8 <_free_r+0x1c0>)
    67a6:	3808      	subs	r0, #8
    67a8:	4290      	cmp	r0, r2
    67aa:	d04d      	beq.n	6848 <_free_r+0x150>
    67ac:	6851      	ldr	r1, [r2, #4]
    67ae:	f021 0103 	bic.w	r1, r1, #3
    67b2:	428b      	cmp	r3, r1
    67b4:	d202      	bcs.n	67bc <_free_r+0xc4>
    67b6:	6892      	ldr	r2, [r2, #8]
    67b8:	4290      	cmp	r0, r2
    67ba:	d1f7      	bne.n	67ac <_free_r+0xb4>
    67bc:	68d0      	ldr	r0, [r2, #12]
    67be:	60e0      	str	r0, [r4, #12]
    67c0:	60a2      	str	r2, [r4, #8]
    67c2:	6084      	str	r4, [r0, #8]
    67c4:	60d4      	str	r4, [r2, #12]
    67c6:	4640      	mov	r0, r8
    67c8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    67cc:	f7ff bebc 	b.w	6548 <__malloc_unlock>
    67d0:	6895      	ldr	r5, [r2, #8]
    67d2:	4f3a      	ldr	r7, [pc, #232]	; (68bc <_free_r+0x1c4>)
    67d4:	42bd      	cmp	r5, r7
    67d6:	4403      	add	r3, r0
    67d8:	d03f      	beq.n	685a <_free_r+0x162>
    67da:	68d0      	ldr	r0, [r2, #12]
    67dc:	60e8      	str	r0, [r5, #12]
    67de:	f043 0201 	orr.w	r2, r3, #1
    67e2:	6085      	str	r5, [r0, #8]
    67e4:	6062      	str	r2, [r4, #4]
    67e6:	50e3      	str	r3, [r4, r3]
    67e8:	e7b3      	b.n	6752 <_free_r+0x5a>
    67ea:	07ff      	lsls	r7, r7, #31
    67ec:	4403      	add	r3, r0
    67ee:	d407      	bmi.n	6800 <_free_r+0x108>
    67f0:	f855 2c08 	ldr.w	r2, [r5, #-8]
    67f4:	1aa4      	subs	r4, r4, r2
    67f6:	4413      	add	r3, r2
    67f8:	68a0      	ldr	r0, [r4, #8]
    67fa:	68e2      	ldr	r2, [r4, #12]
    67fc:	60c2      	str	r2, [r0, #12]
    67fe:	6090      	str	r0, [r2, #8]
    6800:	4a2f      	ldr	r2, [pc, #188]	; (68c0 <_free_r+0x1c8>)
    6802:	6812      	ldr	r2, [r2, #0]
    6804:	f043 0001 	orr.w	r0, r3, #1
    6808:	4293      	cmp	r3, r2
    680a:	6060      	str	r0, [r4, #4]
    680c:	608c      	str	r4, [r1, #8]
    680e:	d3b6      	bcc.n	677e <_free_r+0x86>
    6810:	4b2c      	ldr	r3, [pc, #176]	; (68c4 <_free_r+0x1cc>)
    6812:	4640      	mov	r0, r8
    6814:	6819      	ldr	r1, [r3, #0]
    6816:	f7ff ff21 	bl	665c <_malloc_trim_r>
    681a:	e7b0      	b.n	677e <_free_r+0x86>
    681c:	1811      	adds	r1, r2, r0
    681e:	6849      	ldr	r1, [r1, #4]
    6820:	07c9      	lsls	r1, r1, #31
    6822:	d444      	bmi.n	68ae <_free_r+0x1b6>
    6824:	6891      	ldr	r1, [r2, #8]
    6826:	68d2      	ldr	r2, [r2, #12]
    6828:	60ca      	str	r2, [r1, #12]
    682a:	4403      	add	r3, r0
    682c:	f043 0001 	orr.w	r0, r3, #1
    6830:	6091      	str	r1, [r2, #8]
    6832:	6060      	str	r0, [r4, #4]
    6834:	50e3      	str	r3, [r4, r3]
    6836:	e7a2      	b.n	677e <_free_r+0x86>
    6838:	2a14      	cmp	r2, #20
    683a:	d817      	bhi.n	686c <_free_r+0x174>
    683c:	f102 075c 	add.w	r7, r2, #92	; 0x5c
    6840:	007f      	lsls	r7, r7, #1
    6842:	f102 055b 	add.w	r5, r2, #91	; 0x5b
    6846:	e7a9      	b.n	679c <_free_r+0xa4>
    6848:	10aa      	asrs	r2, r5, #2
    684a:	684b      	ldr	r3, [r1, #4]
    684c:	2501      	movs	r5, #1
    684e:	fa05 f202 	lsl.w	r2, r5, r2
    6852:	4313      	orrs	r3, r2
    6854:	604b      	str	r3, [r1, #4]
    6856:	4602      	mov	r2, r0
    6858:	e7b1      	b.n	67be <_free_r+0xc6>
    685a:	f043 0201 	orr.w	r2, r3, #1
    685e:	614c      	str	r4, [r1, #20]
    6860:	610c      	str	r4, [r1, #16]
    6862:	60e5      	str	r5, [r4, #12]
    6864:	60a5      	str	r5, [r4, #8]
    6866:	6062      	str	r2, [r4, #4]
    6868:	50e3      	str	r3, [r4, r3]
    686a:	e788      	b.n	677e <_free_r+0x86>
    686c:	2a54      	cmp	r2, #84	; 0x54
    686e:	d806      	bhi.n	687e <_free_r+0x186>
    6870:	0b1a      	lsrs	r2, r3, #12
    6872:	f102 076f 	add.w	r7, r2, #111	; 0x6f
    6876:	007f      	lsls	r7, r7, #1
    6878:	f102 056e 	add.w	r5, r2, #110	; 0x6e
    687c:	e78e      	b.n	679c <_free_r+0xa4>
    687e:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    6882:	d806      	bhi.n	6892 <_free_r+0x19a>
    6884:	0bda      	lsrs	r2, r3, #15
    6886:	f102 0778 	add.w	r7, r2, #120	; 0x78
    688a:	007f      	lsls	r7, r7, #1
    688c:	f102 0577 	add.w	r5, r2, #119	; 0x77
    6890:	e784      	b.n	679c <_free_r+0xa4>
    6892:	f240 5054 	movw	r0, #1364	; 0x554
    6896:	4282      	cmp	r2, r0
    6898:	d806      	bhi.n	68a8 <_free_r+0x1b0>
    689a:	0c9a      	lsrs	r2, r3, #18
    689c:	f102 077d 	add.w	r7, r2, #125	; 0x7d
    68a0:	007f      	lsls	r7, r7, #1
    68a2:	f102 057c 	add.w	r5, r2, #124	; 0x7c
    68a6:	e779      	b.n	679c <_free_r+0xa4>
    68a8:	27fe      	movs	r7, #254	; 0xfe
    68aa:	257e      	movs	r5, #126	; 0x7e
    68ac:	e776      	b.n	679c <_free_r+0xa4>
    68ae:	f043 0201 	orr.w	r2, r3, #1
    68b2:	6062      	str	r2, [r4, #4]
    68b4:	50e3      	str	r3, [r4, r3]
    68b6:	e762      	b.n	677e <_free_r+0x86>
    68b8:	1fff0ecc 	.word	0x1fff0ecc
    68bc:	1fff0ed4 	.word	0x1fff0ed4
    68c0:	1fff12d4 	.word	0x1fff12d4
    68c4:	1fff1a40 	.word	0x1fff1a40
    68c8:	72617453 	.word	0x72617453
    68cc:	676e6974 	.word	0x676e6974
    68d0:	00000021 	.word	0x00000021
    68d4:	706f7453 	.word	0x706f7453
    68d8:	676e6970 	.word	0x676e6970
    68dc:	00000021 	.word	0x00000021
    68e0:	ffff0020 	.word	0xffff0020

000068e4 <vtable for ControlledDcMotor>:
	...
    68ec:	00001d31 00001d31 00001d31              1...1...1...

000068f8 <vtable for FE_ControlledDcMotor>:
	...
    6900:	00000dc1 00000e29 00000be5              ....).......

0000690c <vtable for PS_ControlledDcMotor>:
	...
    6914:	000014e1 00001549 00001305              ....I.......

00006920 <pin2sc1a>:
    6920:	09080e05 07060c0d 9303040f 0e058f8e     ................
    6930:	0c0d0908 040f0706 ffffffff 8effffff     ................
    6940:	8412118f 91878685 ffffffff ffffffff     ................
    6950:	ff8b8aff ffffffff ffffffff ffffffff     ................
    6960:	97179303 921a8101                       ........

00006968 <digital_pin_to_info_PGM>:
    6968:	43fe0840 4004a040 43fe0844 4004a044     @..C@..@D..CD..@
    6978:	43fe1800 4004c000 43fe0030 40049030     ...C...@0..C0..@
    6988:	43fe0034 40049034 43fe181c 4004c01c     4..C4..@...C...@
    6998:	43fe1810 4004c010 43fe1808 4004c008     ...C...@...C...@
    69a8:	43fe180c 4004c00c 43fe100c 4004b00c     ...C...@...C...@
    69b8:	43fe1010 4004b010 43fe1018 4004b018     ...C...@...C...@
    69c8:	43fe101c 4004b01c 43fe1014 4004b014     ...C...@...C...@
    69d8:	43fe1804 4004c004 43fe1000 4004b000     ...C...@...C...@
    69e8:	43fe0800 4004a000 43fe0804 4004a004     ...C...@...C...@
    69f8:	43fe080c 4004a00c 43fe0808 4004a008     ...C...@...C...@
    6a08:	43fe1814 4004c014 43fe1818 4004c018     ...C...@...C...@
    6a18:	43fe1004 4004b004 43fe1008 4004b008     ...C...@...C...@
    6a28:	43fe2068 4004d068 43fe0014 40049014     h .Ch..@...C...@
    6a38:	43fe0038 40049038 43fe003c 4004903c     8..C8..@<..C<..@
    6a48:	43fe0040 40049040 43fe0848 4004a048     @..C@..@H..CH..@
    6a58:	43fe084c 4004a04c 43fe0828 4004a028     L..CL..@(..C(..@
    6a68:	43fe082c 4004a02c 43fe2060 4004d060     ,..C,..@` .C`..@
    6a78:	43fe2064 4004d064 43fe1020 4004b020     d .Cd..@ ..C ..@
    6a88:	43fe1024 4004b024 43fe1028 4004b028     $..C$..@(..C(..@
    6a98:	43fe102c 4004b02c 43fe0044 40049044     ,..C,..@D..CD..@
    6aa8:	43fe0070 40049070 43fe0074 40049074     p..Cp..@t..Ct..@
    6ab8:	43fe0068 40049068 43fe0850 4004a050     h..Ch..@P..CP..@
    6ac8:	43fe0858 4004a058 43fe085c 4004a05c     X..CX..@\..C\..@
    6ad8:	43fe0854 4004a054 43fe1820 4004c020     T..CT..@ ..C ..@
    6ae8:	43fe1824 4004c024 43fe0810 4004a010     $..C$..@...C...@
    6af8:	43fe0814 4004a014 43fe1838 4004c038     ...C...@8..C8..@
    6b08:	43fe1834 4004c034 43fe1830 4004c030     4..C4..@0..C0..@
    6b18:	43fe183c 4004c03c 43fe182c 4004c02c     <..C<..@,..C,..@
    6b28:	43fe2028 4004d028 43fe202c 4004d02c     ( .C(..@, .C,..@
    6b38:	43fe2000 4004d000 43fe2004 4004d004     . .C...@. .C...@
    6b48:	43fe2008 4004d008 43fe200c 4004d00c     . .C...@. .C...@
    6b58:	43fe2010 4004d010 43fe2014 4004d014     . .C...@. .C...@
    6b68:	ffff0a0d 006e616e 0066766f 00666e69     ....nan.ovf.inf.

00006b78 <vtable for usb_serial_class>:
	...
    6b80:	00003cf1 00003ce9 00003ce5 00003ce1     .<...<...<...<..
    6b90:	00003cdd 00003cd9 00003cd5 00003cd1     .<...<...<...<..

00006ba0 <usb_endpoint_config_table>:
    6ba0:	15191500                                ....

00006ba4 <usb_descriptor_list>:
    6ba4:	00000100 1fff09fc 00000012 00000200     ................
    6bb4:	1fff0a28 00000043 00000300 1fff0a84     (...C...........
    6bc4:	00000000 04090301 1fff0a10 00000000     ................
    6bd4:	04090302 1fff0a6c 00000000 04090303     ....l...........
    6be4:	1fff0a88 00000000 00000000 00000000     ................
    6bf4:	00000000 646f6d66 00000000              ....fmod....

00006c00 <Zero>:
	...
    6c0c:	80000000                                ....

00006c10 <npio2_hw>:
    6c10:	3fc90f00 40490f00 4096cb00 40c90f00     ...?..I@...@...@
    6c20:	40fb5300 4116cb00 412fed00 41490f00     .S.@...A../A..IA
    6c30:	41623100 417b5300 418a3a00 4196cb00     .1bA.S{A.:.A...A
    6c40:	41a35c00 41afed00 41bc7e00 41c90f00     .\.A...A.~.A...A
    6c50:	41d5a000 41e23100 41eec200 41fb5300     ...A.1.A...A.S.A
    6c60:	4203f200 420a3a00 42108300 4216cb00     ...B.:.B...B...B
    6c70:	421d1400 42235c00 4229a500 422fed00     ...B.\#B..)B../B
    6c80:	42363600 423c7e00 4242c700 42490f00     .66B.~<B..BB..IB

00006c90 <two_over_pi>:
    6c90:	000000a2 000000f9 00000083 0000006e     ............n...
    6ca0:	0000004e 00000044 00000015 00000029     N...D.......)...
    6cb0:	000000fc 00000027 00000057 000000d1     ....'...W.......
    6cc0:	000000f5 00000034 000000dd 000000c0     ....4...........
    6cd0:	000000db 00000062 00000095 00000099     ....b...........
    6ce0:	0000003c 00000043 00000090 00000041     <...C.......A...
    6cf0:	000000fe 00000051 00000063 000000ab     ....Q...c.......
    6d00:	000000de 000000bb 000000c5 00000061     ............a...
    6d10:	000000b7 00000024 0000006e 0000003a     ....$...n...:...
    6d20:	00000042 0000004d 000000d2 000000e0     B...M...........
    6d30:	00000006 00000049 0000002e 000000ea     ....I...........
    6d40:	00000009 000000d1 00000092 0000001c     ................
    6d50:	000000fe 0000001d 000000eb 0000001c     ................
    6d60:	000000b1 00000029 000000a7 0000003e     ....).......>...
    6d70:	000000e8 00000082 00000035 000000f5     ........5.......
    6d80:	0000002e 000000bb 00000044 00000084     ........D.......
    6d90:	000000e9 0000009c 00000070 00000026     ........p...&...
    6da0:	000000b4 0000005f 0000007e 00000041     ...._...~...A...
    6db0:	00000039 00000091 000000d6 00000039     9...........9...
    6dc0:	00000083 00000053 00000039 000000f4     ....S...9.......
    6dd0:	0000009c 00000084 0000005f 0000008b     ........_.......
    6de0:	000000bd 000000f9 00000028 0000003b     ........(...;...
    6df0:	0000001f 000000f8 00000097 000000ff     ................
    6e00:	000000de 00000005 00000098 0000000f     ................
    6e10:	000000ef 0000002f 00000011 0000008b     ..../...........
    6e20:	0000005a 0000000a 0000006d 0000001f     Z.......m.......
    6e30:	0000006d 00000036 0000007e 000000cf     m...6...~.......
    6e40:	00000027 000000cb 00000009 000000b7     '...............
    6e50:	0000004f 00000046 0000003f 00000066     O...F...?...f...
    6e60:	0000009e 0000005f 000000ea 0000002d     ...._.......-...
    6e70:	00000075 00000027 000000ba 000000c7     u...'...........
    6e80:	000000eb 000000e5 000000f1 0000007b     ............{...
    6e90:	0000003d 00000007 00000039 000000f7     =.......9.......
    6ea0:	0000008a 00000052 00000092 000000ea     ....R...........
    6eb0:	0000006b 000000fb 0000005f 000000b1     k......._.......
    6ec0:	0000001f 0000008d 0000005d 00000008     ........].......
    6ed0:	00000056 00000003 00000030 00000046     V.......0...F...
    6ee0:	000000fc 0000007b 0000006b 000000ab     ....{...k.......
    6ef0:	000000f0 000000cf 000000bc 00000020     ............ ...
    6f00:	0000009a 000000f4 00000036 0000001d     ........6.......
    6f10:	000000a9 000000e3 00000091 00000061     ............a...
    6f20:	0000005e 000000e6 0000001b 00000008     ^...............
    6f30:	00000065 00000099 00000085 0000005f     e..........._...
    6f40:	00000014 000000a0 00000068 00000040     ........h...@...
    6f50:	0000008d 000000ff 000000d8 00000080     ................
    6f60:	0000004d 00000073 00000027 00000031     M...s...'...1...
    6f70:	00000006 00000006 00000015 00000056     ............V...
    6f80:	000000ca 00000073 000000a8 000000c9     ....s...........
    6f90:	00000060 000000e2 0000007b 000000c0     `.......{.......
    6fa0:	0000008c 0000006b                       ....k...

00006fa8 <init_jk>:
    6fa8:	00000004 00000007 00000009              ............

00006fb4 <PIo2>:
    6fb4:	3fc90000 39f00000 37da0000 33a20000     ...?...9...7...3
    6fc4:	2e840000 2b500000 27c20000 22d00000     ......P+...'..."
    6fd4:	1fc40000 1bc60000 17440000              ..........D.

00006fe0 <_global_impure_ptr>:
    6fe0:	1fff0aa0                                ....

00006fe4 <_init>:
    6fe4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6fe6:	bf00      	nop
    6fe8:	bcf8      	pop	{r3, r4, r5, r6, r7}
    6fea:	bc08      	pop	{r3}
    6fec:	469e      	mov	lr, r3
    6fee:	4770      	bx	lr

00006ff0 <__init_array_start>:
    6ff0:	00006615 	.word	0x00006615

00006ff4 <__frame_dummy_init_array_entry>:
    6ff4:	00000435 00000595                       5.......

Disassembly of section .fini:

00006ffc <_fini>:
    6ffc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6ffe:	bf00      	nop

Disassembly of section .data:

1fff0730 <port_E_isr>:
#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
PORT_ISR_FUNCTION_CLZ(D)
PORT_ISR_FUNCTION_CLZ(E)
1fff0730:	b538      	push	{r3, r4, r5, lr}
1fff0732:	4b08      	ldr	r3, [pc, #32]	; (1fff0754 <port_E_isr+0x24>)
1fff0734:	681c      	ldr	r4, [r3, #0]
1fff0736:	601c      	str	r4, [r3, #0]
1fff0738:	b154      	cbz	r4, 1fff0750 <port_E_isr+0x20>
1fff073a:	4d07      	ldr	r5, [pc, #28]	; (1fff0758 <port_E_isr+0x28>)
1fff073c:	fa94 f3a4 	rbit	r3, r4
1fff0740:	fab3 f383 	clz	r3, r3
1fff0744:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff0748:	4798      	blx	r3
1fff074a:	1e63      	subs	r3, r4, #1
1fff074c:	401c      	ands	r4, r3
1fff074e:	d1f5      	bne.n	1fff073c <port_E_isr+0xc>
1fff0750:	bd38      	pop	{r3, r4, r5, pc}
1fff0752:	bf00      	nop
1fff0754:	4004d0a0 	.word	0x4004d0a0
1fff0758:	1fff0968 	.word	0x1fff0968

1fff075c <port_D_isr>:

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
PORT_ISR_FUNCTION_CLZ(D)
1fff075c:	b538      	push	{r3, r4, r5, lr}
1fff075e:	4b08      	ldr	r3, [pc, #32]	; (1fff0780 <port_D_isr+0x24>)
1fff0760:	681c      	ldr	r4, [r3, #0]
1fff0762:	601c      	str	r4, [r3, #0]
1fff0764:	b154      	cbz	r4, 1fff077c <port_D_isr+0x20>
1fff0766:	4d07      	ldr	r5, [pc, #28]	; (1fff0784 <port_D_isr+0x28>)
1fff0768:	fa94 f3a4 	rbit	r3, r4
1fff076c:	fab3 f383 	clz	r3, r3
1fff0770:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff0774:	4798      	blx	r3
1fff0776:	1e63      	subs	r3, r4, #1
1fff0778:	401c      	ands	r4, r3
1fff077a:	d1f5      	bne.n	1fff0768 <port_D_isr+0xc>
1fff077c:	bd38      	pop	{r3, r4, r5, pc}
1fff077e:	bf00      	nop
1fff0780:	4004c0a0 	.word	0x4004c0a0
1fff0784:	1fff0928 	.word	0x1fff0928

1fff0788 <port_C_isr>:
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
PORT_ISR_FUNCTION_CLZ(C)
1fff0788:	b538      	push	{r3, r4, r5, lr}
1fff078a:	4b08      	ldr	r3, [pc, #32]	; (1fff07ac <port_C_isr+0x24>)
1fff078c:	681c      	ldr	r4, [r3, #0]
1fff078e:	601c      	str	r4, [r3, #0]
1fff0790:	b154      	cbz	r4, 1fff07a8 <port_C_isr+0x20>
1fff0792:	4d07      	ldr	r5, [pc, #28]	; (1fff07b0 <port_C_isr+0x28>)
1fff0794:	fa94 f3a4 	rbit	r3, r4
1fff0798:	fab3 f383 	clz	r3, r3
1fff079c:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff07a0:	4798      	blx	r3
1fff07a2:	1e63      	subs	r3, r4, #1
1fff07a4:	401c      	ands	r4, r3
1fff07a6:	d1f5      	bne.n	1fff0794 <port_C_isr+0xc>
1fff07a8:	bd38      	pop	{r3, r4, r5, pc}
1fff07aa:	bf00      	nop
1fff07ac:	4004b0a0 	.word	0x4004b0a0
1fff07b0:	1fff08f8 	.word	0x1fff08f8

1fff07b4 <port_B_isr>:
	}
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
PORT_ISR_FUNCTION_CLZ(B)
1fff07b4:	b538      	push	{r3, r4, r5, lr}
1fff07b6:	4b08      	ldr	r3, [pc, #32]	; (1fff07d8 <port_B_isr+0x24>)
1fff07b8:	681c      	ldr	r4, [r3, #0]
1fff07ba:	601c      	str	r4, [r3, #0]
1fff07bc:	b154      	cbz	r4, 1fff07d4 <port_B_isr+0x20>
1fff07be:	4d07      	ldr	r5, [pc, #28]	; (1fff07dc <port_B_isr+0x28>)
1fff07c0:	fa94 f3a4 	rbit	r3, r4
1fff07c4:	fab3 f383 	clz	r3, r3
1fff07c8:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff07cc:	4798      	blx	r3
1fff07ce:	1e63      	subs	r3, r4, #1
1fff07d0:	401c      	ands	r4, r3
1fff07d2:	d1f5      	bne.n	1fff07c0 <port_B_isr+0xc>
1fff07d4:	bd38      	pop	{r3, r4, r5, pc}
1fff07d6:	bf00      	nop
1fff07d8:	4004a0a0 	.word	0x4004a0a0
1fff07dc:	1fff0898 	.word	0x1fff0898

1fff07e0 <port_A_isr>:
		}                                                     \
	}
// END PORT_ISR_FUNCTION_CLZ

#if defined(KINETISK)
PORT_ISR_FUNCTION_CLZ(A)
1fff07e0:	b538      	push	{r3, r4, r5, lr}
1fff07e2:	4b08      	ldr	r3, [pc, #32]	; (1fff0804 <port_A_isr+0x24>)
1fff07e4:	681c      	ldr	r4, [r3, #0]
1fff07e6:	601c      	str	r4, [r3, #0]
1fff07e8:	b154      	cbz	r4, 1fff0800 <port_A_isr+0x20>
1fff07ea:	4d07      	ldr	r5, [pc, #28]	; (1fff0808 <port_A_isr+0x28>)
1fff07ec:	fa94 f3a4 	rbit	r3, r4
1fff07f0:	fab3 f383 	clz	r3, r3
1fff07f4:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
1fff07f8:	4798      	blx	r3
1fff07fa:	1e63      	subs	r3, r4, #1
1fff07fc:	401c      	ands	r4, r3
1fff07fe:	d1f5      	bne.n	1fff07ec <port_A_isr+0xc>
1fff0800:	bd38      	pop	{r3, r4, r5, pc}
1fff0802:	bf00      	nop
1fff0804:	400490a0 	.word	0x400490a0
1fff0808:	1fff0820 	.word	0x1fff0820

1fff080c <__dso_handle>:
1fff080c:	00000000                                ....

1fff0810 <waveformAmplitudeFE>:
1fff0810:	000008ae                                ....

1fff0814 <waveformAmplitudePS>:
1fff0814:	00000bf0                                ....

1fff0818 <analog_config_bits>:
1fff0818:	0000040a                                         .

1fff0819 <analog_num_average>:
1fff0819:	84000004                                         ...

1fff081c <__brkval>:
1fff081c:	1fff1a84                                ....

1fff0820 <isr_table_portA>:
1fff0820:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff0830:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff0840:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff0850:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff0860:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff0870:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff0880:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff0890:	00001d9d 00001d9d                       ........

1fff0898 <isr_table_portB>:
1fff0898:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff08a8:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff08b8:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff08c8:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff08d8:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff08e8:	00001d9d 00001d9d 00001d9d 00001d9d     ................

1fff08f8 <isr_table_portC>:
1fff08f8:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff0908:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff0918:	00001d9d 00001d9d 00001d9d 00001d9d     ................

1fff0928 <isr_table_portD>:
1fff0928:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff0938:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff0948:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff0958:	00001d9d 00001d9d 00001d9d 00001d9d     ................

1fff0968 <isr_table_portE>:
1fff0968:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff0978:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff0988:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff0998:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff09a8:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff09b8:	00001d9d 00001d9d 00001d9d 00001d9d     ................
1fff09c8:	00001d9d 00001d9d 00001d9d              ............

1fff09d4 <analog_write_res>:
1fff09d4:	00000008                                ....

1fff09d8 <usb_buffer_available>:
1fff09d8:	ffffffff                                ....

1fff09dc <funct_table>:
1fff09dc:	0000392d 0000392d 0000392d 0000392d     -9..-9..-9..-9..

1fff09ec <Serial>:
1fff09ec:	00006b80 00000000 000003e8 00000000     .k..............

1fff09fc <device_descriptor>:
1fff09fc:	01100112 40000002 048316c0 02010277     .......@....w...
1fff0a0c:	00000103                                ....

1fff0a10 <usb_string_manufacturer_name_default>:
1fff0a10:	00540318 00650065 0073006e 00640079     ..T.e.e.n.s.y.d.
1fff0a20:	00690075 006f006e                       u.i.n.o.

1fff0a28 <config_descriptor>:
1fff0a28:	00430209 c0000102 00040932 02020100     ..C.....2.......
1fff0a38:	24050001 05011000 01010124 06022404     ...$....$....$..
1fff0a48:	00062405 82050701 40001003 00010409     .$.........@....
1fff0a58:	00000a02 03050700 00004002 02840507     .........@......
1fff0a68:	00000040                                @...

1fff0a6c <usb_string_product_name_default>:
1fff0a6c:	00550316 00420053 00530020 00720065     ..U.S.B. .S.e.r.
1fff0a7c:	00610069 0000006c                       i.a.l...

1fff0a84 <string0>:
1fff0a84:	04090304                                ....

1fff0a88 <usb_string_serial_number_default>:
1fff0a88:	0000030c 00000000 00000000 00000000     ................
1fff0a98:	00000000 00010000                                ......

1fff0a9e <__fdlib_version>:
1fff0a9e:	00000001                                         ..

1fff0aa0 <impure_data>:
1fff0aa0:	00000000 1fff0d8c 1fff0df4 1fff0e5c     ............\...
	...
1fff0b48:	00000001 00000000 abcd330e e66d1234     .........3..4.m.
1fff0b58:	0005deec 0000000b 00000000 00000000     ................
	...

1fff0ec8 <_impure_ptr>:
1fff0ec8:	1fff0aa0                                ....

1fff0ecc <__malloc_av_>:
	...
1fff0ed4:	1fff0ecc 1fff0ecc 1fff0ed4 1fff0ed4     ................
1fff0ee4:	1fff0edc 1fff0edc 1fff0ee4 1fff0ee4     ................
1fff0ef4:	1fff0eec 1fff0eec 1fff0ef4 1fff0ef4     ................
1fff0f04:	1fff0efc 1fff0efc 1fff0f04 1fff0f04     ................
1fff0f14:	1fff0f0c 1fff0f0c 1fff0f14 1fff0f14     ................
1fff0f24:	1fff0f1c 1fff0f1c 1fff0f24 1fff0f24     ........$...$...
1fff0f34:	1fff0f2c 1fff0f2c 1fff0f34 1fff0f34     ,...,...4...4...
1fff0f44:	1fff0f3c 1fff0f3c 1fff0f44 1fff0f44     <...<...D...D...
1fff0f54:	1fff0f4c 1fff0f4c 1fff0f54 1fff0f54     L...L...T...T...
1fff0f64:	1fff0f5c 1fff0f5c 1fff0f64 1fff0f64     \...\...d...d...
1fff0f74:	1fff0f6c 1fff0f6c 1fff0f74 1fff0f74     l...l...t...t...
1fff0f84:	1fff0f7c 1fff0f7c 1fff0f84 1fff0f84     |...|...........
1fff0f94:	1fff0f8c 1fff0f8c 1fff0f94 1fff0f94     ................
1fff0fa4:	1fff0f9c 1fff0f9c 1fff0fa4 1fff0fa4     ................
1fff0fb4:	1fff0fac 1fff0fac 1fff0fb4 1fff0fb4     ................
1fff0fc4:	1fff0fbc 1fff0fbc 1fff0fc4 1fff0fc4     ................
1fff0fd4:	1fff0fcc 1fff0fcc 1fff0fd4 1fff0fd4     ................
1fff0fe4:	1fff0fdc 1fff0fdc 1fff0fe4 1fff0fe4     ................
1fff0ff4:	1fff0fec 1fff0fec 1fff0ff4 1fff0ff4     ................
1fff1004:	1fff0ffc 1fff0ffc 1fff1004 1fff1004     ................
1fff1014:	1fff100c 1fff100c 1fff1014 1fff1014     ................
1fff1024:	1fff101c 1fff101c 1fff1024 1fff1024     ........$...$...
1fff1034:	1fff102c 1fff102c 1fff1034 1fff1034     ,...,...4...4...
1fff1044:	1fff103c 1fff103c 1fff1044 1fff1044     <...<...D...D...
1fff1054:	1fff104c 1fff104c 1fff1054 1fff1054     L...L...T...T...
1fff1064:	1fff105c 1fff105c 1fff1064 1fff1064     \...\...d...d...
1fff1074:	1fff106c 1fff106c 1fff1074 1fff1074     l...l...t...t...
1fff1084:	1fff107c 1fff107c 1fff1084 1fff1084     |...|...........
1fff1094:	1fff108c 1fff108c 1fff1094 1fff1094     ................
1fff10a4:	1fff109c 1fff109c 1fff10a4 1fff10a4     ................
1fff10b4:	1fff10ac 1fff10ac 1fff10b4 1fff10b4     ................
1fff10c4:	1fff10bc 1fff10bc 1fff10c4 1fff10c4     ................
1fff10d4:	1fff10cc 1fff10cc 1fff10d4 1fff10d4     ................
1fff10e4:	1fff10dc 1fff10dc 1fff10e4 1fff10e4     ................
1fff10f4:	1fff10ec 1fff10ec 1fff10f4 1fff10f4     ................
1fff1104:	1fff10fc 1fff10fc 1fff1104 1fff1104     ................
1fff1114:	1fff110c 1fff110c 1fff1114 1fff1114     ................
1fff1124:	1fff111c 1fff111c 1fff1124 1fff1124     ........$...$...
1fff1134:	1fff112c 1fff112c 1fff1134 1fff1134     ,...,...4...4...
1fff1144:	1fff113c 1fff113c 1fff1144 1fff1144     <...<...D...D...
1fff1154:	1fff114c 1fff114c 1fff1154 1fff1154     L...L...T...T...
1fff1164:	1fff115c 1fff115c 1fff1164 1fff1164     \...\...d...d...
1fff1174:	1fff116c 1fff116c 1fff1174 1fff1174     l...l...t...t...
1fff1184:	1fff117c 1fff117c 1fff1184 1fff1184     |...|...........
1fff1194:	1fff118c 1fff118c 1fff1194 1fff1194     ................
1fff11a4:	1fff119c 1fff119c 1fff11a4 1fff11a4     ................
1fff11b4:	1fff11ac 1fff11ac 1fff11b4 1fff11b4     ................
1fff11c4:	1fff11bc 1fff11bc 1fff11c4 1fff11c4     ................
1fff11d4:	1fff11cc 1fff11cc 1fff11d4 1fff11d4     ................
1fff11e4:	1fff11dc 1fff11dc 1fff11e4 1fff11e4     ................
1fff11f4:	1fff11ec 1fff11ec 1fff11f4 1fff11f4     ................
1fff1204:	1fff11fc 1fff11fc 1fff1204 1fff1204     ................
1fff1214:	1fff120c 1fff120c 1fff1214 1fff1214     ................
1fff1224:	1fff121c 1fff121c 1fff1224 1fff1224     ........$...$...
1fff1234:	1fff122c 1fff122c 1fff1234 1fff1234     ,...,...4...4...
1fff1244:	1fff123c 1fff123c 1fff1244 1fff1244     <...<...D...D...
1fff1254:	1fff124c 1fff124c 1fff1254 1fff1254     L...L...T...T...
1fff1264:	1fff125c 1fff125c 1fff1264 1fff1264     \...\...d...d...
1fff1274:	1fff126c 1fff126c 1fff1274 1fff1274     l...l...t...t...
1fff1284:	1fff127c 1fff127c 1fff1284 1fff1284     |...|...........
1fff1294:	1fff128c 1fff128c 1fff1294 1fff1294     ................
1fff12a4:	1fff129c 1fff129c 1fff12a4 1fff12a4     ................
1fff12b4:	1fff12ac 1fff12ac 1fff12b4 1fff12b4     ................
1fff12c4:	1fff12bc 1fff12bc 1fff12c4 1fff12c4     ................

1fff12d4 <__malloc_trim_threshold>:
1fff12d4:	00020000                                ....

1fff12d8 <__malloc_sbrk_base>:
1fff12d8:	ffffffff                                ....
